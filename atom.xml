<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空白のBlog</title>
  
  <subtitle>For the future</subtitle>
  <link href="https://blankyang233.github.io/atom.xml" rel="self"/>
  
  <link href="https://blankyang233.github.io/"/>
  <updated>2022-07-15T14:43:19.838Z</updated>
  <id>https://blankyang233.github.io/</id>
  
  <author>
    <name>空白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NC14698 模拟战役</title>
    <link href="https://blankyang233.github.io/2022/07/15/NC14698%20%E6%A8%A1%E6%8B%9F%E6%88%98%E5%BD%B9/"/>
    <id>https://blankyang233.github.io/2022/07/15/NC14698%20%E6%A8%A1%E6%8B%9F%E6%88%98%E5%BD%B9/</id>
    <published>2022-07-15T14:42:43.000Z</published>
    <updated>2022-07-15T14:43:19.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14698">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>齐齐和司机在玩单机游戏《红色警戒IV》，现在他们的游戏地图被划分成一个n*m的方格地图。齐齐的基地在最上方的4行格内，司机的基地在最下方的4行格内。他们只有一种攻击方式：远程大炮，相关属性如下：</p><p>  1、  大炮可以打到地图的任意一个位置。 </p><p> 2、  双方每次<strong>必须</strong>动用本方的一门大炮攻击，齐齐先手，双方交替进行攻击。<br> 3、  一方大炮只能攻击另一方大炮，不能攻击本方或强制攻击未获得视野的地区。<br> 4、  被一方大炮击中的另一方大炮会产生以<strong>攻击点为中心</strong>的<strong>3*3</strong>的波及区域，波及区域内如果有其他大炮则也会产生3*3的波及区域。<br> 5、  两方的基地相距很远，所以不存在攻打敌方大炮时波及到本方大炮的情况。<br> 齐齐偷偷开了“间谍卫星”，所以他能看到司机的大炮部署，司机则无视野。但如果齐齐做出攻击，司机会立即获取到发动攻击的大炮的视野，并在回合开始时动用大炮（如果存在的话）将其摧毁（摧毁后可能产生的连锁不计入视野）。<br> 现在给出齐齐和司机的大炮部署，问齐齐在选择<strong>最优的策略</strong>下，在摧毁所有司机的大炮后可以<strong>保留最多</strong>几门本方大炮。</p><p><strong>输入描述</strong></p><p>第1行输入一个整数m，表示地图的宽度。<br>第2-5行，每行输入一串长度为m的字符串，代表司机的大炮部署。（大炮为”*“号，空地为“.”号）<br>第6-9行，每行输入一串长度为m的字符串，代表齐齐的大炮部署。（大炮为”*“号，空地为“.”号）<br>数据保证：0&lt;m≤100</p><p><strong>输出描述</strong></p><p>输出一行，一个整数。代表摧毁所有司机的大炮后最多保留几门大炮。如果不能摧毁所有司机的大炮，则输出-1。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">...</span><br><span class="line">.*.</span><br><span class="line">..*</span><br><span class="line">*..</span><br><span class="line">*..</span><br><span class="line">.**</span><br><span class="line">...</span><br><span class="line">*.*</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">*..</span><br><span class="line">..*</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">.*.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：DFS。</strong></p><p>遍历整张图，对每个点dfs访问连通点并标记，最后返回各个连通块的大炮个数（实际上对于司机只需要连通块个数即可）。然如果齐齐连通块个数小于司机的就不能完全摧毁，否则将齐齐的连通块按大炮个数从大到小排，取能保留块个数的和。</p><p>时间复杂度 $O(m)$</p><p>空间复杂度 $O(m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">10</span>][<span class="number">107</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx &gt;= r + <span class="number">4</span> || nx &lt; r || ny &lt; <span class="number">0</span> || ny &gt;= m || dt[nx][ny] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dt[nx][ny] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        ans += <span class="built_in">dfs</span>(nx, ny, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">    <span class="type">int</span> sj = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; qq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dt[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j, <span class="number">0</span>);</span><br><span class="line">                sj++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>;i &lt; <span class="number">8</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dt[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                qq.<span class="built_in">push_back</span>(<span class="built_in">dfs</span>(i, j, <span class="number">4</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qq.<span class="built_in">size</span>() &lt; sj) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">sort</span>(qq.<span class="built_in">begin</span>(), qq.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; qq.<span class="built_in">size</span>() - sj + <span class="number">1</span>;i++) ans += qq[i];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14698&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NC50243 小木棍</title>
    <link href="https://blankyang233.github.io/2022/07/15/NC50243%20%E5%B0%8F%E6%9C%A8%E6%A3%8D/"/>
    <id>https://blankyang233.github.io/2022/07/15/NC50243%20%E5%B0%8F%E6%9C%A8%E6%A3%8D/</id>
    <published>2022-07-15T14:33:09.000Z</published>
    <updated>2022-07-15T14:33:36.149Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/50243">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过50。现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。</p><p><strong>输入描述</strong></p><p>第一行为一个单独的整数N表示砍过以后的小木棍的总数。第二行为N个用空格隔开的正整数，表示N根小木棍的长度。</p><p><strong>输出描述</strong></p><p>输出仅一行，表示要求的原始木棍的最小可能长度。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5 2 1 5 2 1 5 2 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>$1 \leq N \leq 60$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：DFS。</strong></p><p>首先要枚举一个原长，再去dfs可行性，但这题关键在于剪枝。</p><p>优化：</p><ol><li>原长要整除长度和</li><li>木棍从大到小排序，方便快速剪枝</li><li>访问过的木棍不再访问</li><li>拿取后长度超额的木棍不搜索</li><li>每次拼凑一根原棍从上一次访问的木棍之后开始，因为之前的都已经不可行了</li><li>一次失败后，后面全部相同长度的不要搜索</li><li>第一根或者最后一根失败代表上一根也失败直接跳出循环</li></ol><p>以上优化缺一不可。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">67</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">67</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step = <span class="number">0</span>, <span class="type">int</span> sum = <span class="number">0</span>, <span class="type">int</span> pos = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (step == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> sum = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] || sum + a[i] &gt; len || i &gt; <span class="number">0</span> &amp;&amp; a[i - <span class="number">1</span>] == a[i] &amp;&amp; !vis[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(step + <span class="number">1</span>, sum + a[i], i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!sum || sum + a[i] == len) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i], sum += a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n, [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (len = a[<span class="number">0</span>];len &lt;= sum;len++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum % len) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; len &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50243&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NC15434 wyh的迷宫</title>
    <link href="https://blankyang233.github.io/2022/07/15/NC15434%20wyh%E7%9A%84%E8%BF%B7%E5%AE%AB/"/>
    <id>https://blankyang233.github.io/2022/07/15/NC15434%20wyh%E7%9A%84%E8%BF%B7%E5%AE%AB/</id>
    <published>2022-07-15T14:23:40.000Z</published>
    <updated>2022-07-15T14:24:14.211Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15434">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  给你一个n*m的迷宫，这个迷宫中有以下几个标识：  </p><p>  s代表起点  </p><p>  t代表终点  </p><p>  x代表障碍物  </p><p>  .代表空地  </p><p>  现在你们涵哥想知道能不能从起点走到终点不碰到障碍物（只能上下左右进行移动，并且不能移动到已经移动过的点）。 </p><p><strong>输入描述</strong></p><p>输入第一行一个整数T(1&lt;&#x3D;T&lt;&#x3D;10)<br>接下来有T组测试数据，对于每一组测试数据，第一行输入2个数n和m(1&lt;&#x3D;n,m&lt;&#x3D;500)<br>接下来n行，每行m个字符代表这个迷宫，每个字符都是上面4个中的一种<br>数据保证只有一个起点和一个终点</p><p><strong>输出描述</strong></p><p>对于每一组测试数据，如果可以的话输出YES，不可以的话输出NO</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3 5</span><br><span class="line">s...x</span><br><span class="line">x...x</span><br><span class="line">...tx</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：DFS，BFS。</strong></p><p>这道题两种搜索都能写，但dfs会好一点，因为bfs是所有路径都推到最后一步才出结果，不适合可行性的题，但如果地图太大的话，还是用bfs。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">507</span>][<span class="number">507</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">507</span>][<span class="number">507</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dt[x][y] == <span class="string">&#x27;t&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || vis[xx][yy] || dt[xx][yy] == <span class="string">&#x27;x&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(xx, yy)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sx, sy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(sx, sy))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15434&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC24911 数独挑战</title>
    <link href="https://blankyang233.github.io/2022/07/15/NC24911%20%E6%95%B0%E7%8B%AC%E6%8C%91%E6%88%98/"/>
    <id>https://blankyang233.github.io/2022/07/15/NC24911%20%E6%95%B0%E7%8B%AC%E6%8C%91%E6%88%98/</id>
    <published>2022-07-15T14:15:18.000Z</published>
    <updated>2022-07-15T14:21:14.194Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/24911">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>   数独是一种填数字游戏，英文名叫 Sudoku，起源于瑞士，上世纪 70 年代由美国一家数学逻辑游戏杂志首先发表，名为 Number Place，后在日本流行，1984 年将 Sudoku 命名为数独，即 “独立的数字” 的缩写，意思是 “在每一格只有一个数字”。  </p><p>   2004 年，曾任中国香港高等法院法官的高乐德 (Wayne Gould) 把这款游戏带到英国，成为英国流行的数学智力拼图游戏。  </p><p>  <img src="https://uploadfiles.nowcoder.com/images/20190413/312536_1555089574905_C3FA384FE95C3ED7166F10AA7FCEE023" alt="img"></p><p>  玩家需要根据 $9 \times 9$ 盘面上的已知数字，推理出所有剩余位置的数字，并满足每一行、每一列、每一个粗线九宫格内的数字包含有 1-9 的数字，且不重复。</p><p>   现在给你一个数独，请你解答出来。每个数独保证有且只有一个解。 </p><p><strong>输入描述</strong></p><p>输入仅一组数据，共 9 行 9 列，表示初始数独（其中 0 表示数独中的空位）。</p><p><strong>输出描述</strong></p><p>输出共 9 行 9 列，表示数独的解。</p><p>注意⾏末没有空格。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 3 0 0 7 0 0 0 0</span><br><span class="line">6 0 0 1 9 5 0 0 0</span><br><span class="line">0 9 8 0 0 0 0 6 0</span><br><span class="line">8 0 0 0 6 0 0 0 3</span><br><span class="line">4 0 0 8 0 3 0 0 1</span><br><span class="line">7 0 0 0 2 0 0 0 6</span><br><span class="line">0 6 0 0 0 0 2 8 0</span><br><span class="line">0 0 0 4 1 9 0 0 5</span><br><span class="line">0 0 0 0 8 0 0 7 9</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 3 4 6 7 8 9 1 2</span><br><span class="line">6 7 2 1 9 5 3 4 8</span><br><span class="line">1 9 8 3 4 2 5 6 7</span><br><span class="line">8 5 9 7 6 1 4 2 3</span><br><span class="line">4 2 6 8 5 3 7 9 1</span><br><span class="line">7 1 3 9 2 4 8 5 6</span><br><span class="line">9 6 1 5 3 7 2 8 4</span><br><span class="line">2 8 7 4 1 9 6 3 5</span><br><span class="line">3 4 5 2 8 6 1 7 9</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：DFS。</strong></p><p>可行性一般用dfs寻找一次方案，当然深度太深的要用bfs。</p><p>用 $r[i][j]$ 表示第 $i$ 行的数字 $j$ 是否被用过，$c[i][j]$ 表示第 $i$ 列的数字 $j$ 是否被用过，$cube[i][j]$ 表示第 $i$ 个小方块的数字 $j$ 是否被用过。</p><p>代码里我用了状态压缩，把 $1$ - $9$ 的情况压缩进一个 <code>int</code> 。并且我用一个 $in+j$ 一个数字表示 $(i,j)$ ，将二维压缩成一维，方便存储使用。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> dt[N][N];</span><br><span class="line"><span class="type">int</span> b[N * N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> r[N], c[N], cube[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step == cnt) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; N;j++) &#123;</span><br><span class="line">                cout &lt;&lt; dt[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = b[step] / N, y = b[step] % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= N;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((r[x] &gt;&gt; i) &amp; <span class="number">1</span>) || ((c[y] &gt;&gt; i) &amp; <span class="number">1</span>) || ((cube[x / <span class="number">3</span> * <span class="number">3</span> + y / <span class="number">3</span>] &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        r[x] |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        c[y] |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        cube[x / <span class="number">3</span> * <span class="number">3</span> + y / <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        dt[x][y] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(step + <span class="number">1</span>);</span><br><span class="line">        r[x] &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        c[y] &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        cube[x / <span class="number">3</span> * <span class="number">3</span> + y / <span class="number">3</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; N;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (!dt[i][j]) b[cnt++] = i * N + j;</span><br><span class="line">            r[i] |= <span class="number">1</span> &lt;&lt; dt[i][j];</span><br><span class="line">            c[j] |= <span class="number">1</span> &lt;&lt; dt[i][j];</span><br><span class="line">            cube[i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; dt[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/24911&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NC19910 [CQOI2007]矩形RECT</title>
    <link href="https://blankyang233.github.io/2022/07/15/NC19910%20[CQOI2007]%E7%9F%A9%E5%BD%A2RECT/"/>
    <id>https://blankyang233.github.io/2022/07/15/NC19910%20[CQOI2007]%E7%9F%A9%E5%BD%A2RECT/</id>
    <published>2022-07-15T14:02:33.000Z</published>
    <updated>2022-07-15T14:03:43.717Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/19910">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  给一个a*b矩形，由a*b个单位正方形组成。你需要沿着网格线把它分成分空的两部分，每部分所有格子连通，且至少有一个格子在原矩形的边界上。“连通”是指任两个格子都可以通过水平或者竖直路径连在一起。 求方案总数。例如3*2的矩形有15种方案。 </p><p>   <img src="https://uploadfiles.nowcoder.com/scoi/AD779F7681.jpg" alt="img"> </p><p><strong>输入描述</strong></p><p>输入仅一行，为两个整数a，b。$1\leq a\leq6$ ，$2\leq b\leq 7$ </p><p><strong>输出描述</strong></p><p>输出仅一行，即方案总数。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">52</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：DFS。</strong></p><p>计数问题用dfs较为合适，注意到只要切成两块，因此切入点和切出点各仅有一个，而且切痕不能交叉。因此枚举各边的切入点，搜索所有切痕条数，切出边一次算一条（包括自己边）。</p><p>由于枚举时会产生重复情况，因为路径的终点也能作为起点返回去算一条，但结合矩形的对称性，我们枚举横竖两边即可。先给边标号 $1,2,3,4$ ，假设 $1,2$ 是横竖两边，那么能搜索出 $11,11,12,13,14;21,22,22,23,24$ 边上所有点的切线条数，其中 $11,22$ 有两次是因为自己边作为起点和终点可以有往返两条路径。我们把其中 $11$ 作为 $33$ ，$22$ 作为 $44$ ，$21$ 作为 $34$ 即可有边的全部组合。</p><p>时间复杂度 $O(2^{mn})$</p><p>空间复杂度 $O(mn)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">7</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y || x == n || y == m) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (vis[xx][yy]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(xx, yy);</span><br><span class="line">        vis[xx][yy] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">///只需枚举横竖两条边，因为自己一边或者横竖两边之间任意路径，都会有一个重复的返回路径</span></span><br><span class="line">    <span class="comment">///根据对称性,可以看作对边自己或者对边横竖之间的所有路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">        vis[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        vis[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">        vis[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        vis[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; m;i++) &#123;</span><br><span class="line">        vis[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        vis[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, i);</span><br><span class="line">        vis[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        vis[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/19910&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NC204418 新集合</title>
    <link href="https://blankyang233.github.io/2022/07/15/NC204418%20%E6%96%B0%E9%9B%86%E5%90%88/"/>
    <id>https://blankyang233.github.io/2022/07/15/NC204418%20%E6%96%B0%E9%9B%86%E5%90%88/</id>
    <published>2022-07-15T13:35:27.000Z</published>
    <updated>2022-07-15T13:36:06.497Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/204418">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>集合 $s$ 中有整数 $1$ 到 $n$ ，牛牛想从中挑几个整数组成一个新的集合。</p><p>  现在牛妹给牛牛加了 $m$ 个限制 ，每个限制包含两个整数 $u$ 和 $v$ ( $u\neq v$)，且 $u$ 和 $v$ 不能同时出现在新集合中 。 </p><p>  请问牛牛能组成的新集合多少种。 </p><p>  <em>可以选 0 个数。</em>  </p><p>  返回一个整数，即新集合的种类数。 </p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,2,[(1,2),(2,3)]</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>当 n &#x3D; 3 时，共有 8 个子集，当加上限制 (1, 2), (2, 3) 后，合法的自己有 $[], [1], [2], [3], [1, 3]$  共 5 个 </p><p><strong>备注</strong></p><p>第一个参数为 $n$ 。第二个参数为 $m$ 。第三个参数为 $m$ 对 (u, v) 。$1 &lt; n \leq 20 \quad 1\leq m \leq 400\quad 1 \leq u, v\leq n$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：DFS。</strong></p><p>一道组合计数题，用dfs比较合适。</p><p>要注意每次深入前要检查所有冲突数对。</p><p>因为是枚举所有不定项组合，为了省时间每次深入前都记一次，就不用老老实实 $2^n$ 可能每次都跑 $n$ 次选和不选。</p><p>时间复杂度 $O(2^n)$</p><p>空间复杂度 $O(n + m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, vector&lt;Point&gt; &amp;limit, <span class="type">int</span> step = <span class="number">0</span>, <span class="type">int</span> pos = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step == n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; limit.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (limit[j].x == i &amp;&amp; vis[limit[j].y]) ok &amp;= <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (limit[j].y == i &amp;&amp; vis[limit[j].x]) ok &amp;= <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(n, limit, step + <span class="number">1</span>, i);</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;Point&gt; limit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        limit.<span class="built_in">push_back</span>(&#123; u,v &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(n, limit);</span><br><span class="line">    cout &lt;&lt; cnt + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/204418&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>HDU3038 How Many Answers Are Wrong</title>
    <link href="https://blankyang233.github.io/2022/07/11/HDU3038%20How%20Many%20Answers%20Are%20Wrong/"/>
    <id>https://blankyang233.github.io/2022/07/11/HDU3038%20How%20Many%20Answers%20Are%20Wrong/</id>
    <published>2022-07-10T16:01:38.000Z</published>
    <updated>2022-07-10T16:03:09.066Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Problem Description</strong></p><p>TT and FF are … friends. Uh… very very good friends -________-b</p><p>FF is a bad boy, he is always wooing TT to play the following game with him. This is a very humdrum game. To begin with, TT should write down a sequence of integers-_-!!(bored).<br><img src="http://acm.hdu.edu.cn/data/images/exe3038-1.JPG" alt="img"><br>Then, FF can choose a continuous subsequence from it(for example the subsequence from the third to the fifth integer inclusively). After that, FF will ask TT what the sum of the subsequence he chose is. The next, TT will answer FF’s question. Then, FF can redo this process. In the end, FF must work out the entire sequence of integers.</p><p>Boring~~Boring~~a very very boring game!!! TT doesn’t want to play with FF at all. To punish FF, she often tells FF the wrong answers on purpose.</p><p>The bad boy is not a fool man. FF detects some answers are incompatible. Of course, these contradictions make it difficult to calculate the sequence.</p><p>However, TT is a nice and lovely girl. She doesn’t have the heart to be hard on FF. To save time, she guarantees that the answers are all right if there is no logical mistakes indeed.</p><p>What’s more, if FF finds an answer to be wrong, he will ignore it when judging next answers.</p><p>But there will be so many questions that poor FF can’t make sure whether the current answer is right or wrong in a moment. So he decides to write a program to help him with this matter. The program will receive a series of questions from FF together with the answers FF has received from TT. The aim of this program is to find how many answers are wrong. Only by ignoring the wrong answers can FF work out the entire sequence of integers. Poor FF has no time to do this job. And now he is asking for your help~(Why asking trouble for himself~~Bad boy)</p><p><strong>Input</strong></p><p>Line 1: Two integers, N and M (1 &lt;&#x3D; N &lt;&#x3D; 200000, 1 &lt;&#x3D; M &lt;&#x3D; 40000). Means TT wrote N integers and FF asked her M questions.</p><p>Line 2..M+1: Line i+1 contains three integer: Ai, Bi and Si. Means TT answered FF that the sum from Ai to Bi is Si. It’s guaranteed that 0 &lt; Ai &lt;&#x3D; Bi &lt;&#x3D; N.</p><p>You can assume that any sum of subsequence is fit in 32-bit integer.</p><p><strong>Output</strong></p><p>A single line with a integer denotes how many answers are wrong.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 10 100</span><br><span class="line">7 10 28</span><br><span class="line">1 3 32</span><br><span class="line">4 6 41</span><br><span class="line">6 6 1</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>Source</strong></p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2009+Multi-University+Training+Contest+13+-+Host+by+HIT&source=1&searchmode=source">2009 Multi-University Training Contest 13 - Host by HIT</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>因为给出的是区间和，我们拆分成两端前缀和方便用带权并查集维护。</p><p>依然用向量的思想会很好理解合并和压缩过程中的计算。</p><p>时间复杂度 $O(n+m\log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">200007</span>], sum[<span class="number">200007</span>];<span class="comment">///sum[i] 指 (i,根节点]的和</span></span><br><span class="line"><span class="comment">///可以理解为一个点到点的向量长度，这样就可以用向量加减理解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> pre = fa[x];</span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    sum[x] += sum[pre];<span class="comment">///递归求和，路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<span class="comment">///不是我的锅，是他没写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++) fa[i] = i, sum[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="type">int</span> a, b, S;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; S;</span><br><span class="line">            a--;</span><br><span class="line">            <span class="type">int</span> ra = <span class="built_in">find</span>(a);</span><br><span class="line">            <span class="type">int</span> rb = <span class="built_in">find</span>(b);</span><br><span class="line">            ll A = sum[a];</span><br><span class="line">            ll B = sum[b];</span><br><span class="line">            <span class="keyword">if</span> (ra == rb) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A - B != S) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum[ra] = B + S - A;<span class="comment">///(ra,rb]的大小,可以是逆序的，这样和就是相反数</span></span><br><span class="line">                fa[ra] = rb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3038&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ1984 Navigation Nightmare</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1984%20Navigation%20Nightmare/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1984%20Navigation%20Nightmare/</id>
    <published>2022-07-10T15:44:58.000Z</published>
    <updated>2022-07-10T15:45:44.326Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1984">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>Farmer John’s pastoral neighborhood has N farms (2 &lt;&#x3D; N &lt;&#x3D; 40,000), usually numbered&#x2F;labeled 1..N. A series of M (1 &lt;&#x3D; M &lt; 40,000) vertical and horizontal roads each of varying lengths (1 &lt;&#x3D; length &lt;&#x3D; 1000) connect the farms. A map of these farms might look something like the illustration below in which farms are labeled F1..F7 for clarity and lengths between connected farms are shown as (n):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F1 --- (13) ---- F6 --- (9) ----- F3</span><br><span class="line"> |                                 |</span><br><span class="line">(3)                                |</span><br><span class="line"> |                                (7)</span><br><span class="line">F4 --- (20) -------- F2            |</span><br><span class="line"> |                                 |</span><br><span class="line">(2)                               F5</span><br><span class="line"> | </span><br><span class="line">F7 </span><br></pre></td></tr></table></figure><p>Being an ASCII diagram, it is not precisely to scale, of course.</p><p>Each farm can connect directly to at most four other farms via roads that lead exactly north, south, east, and&#x2F;or west. Moreover, farms are only located at the endpoints of roads, and some farm can be found at every endpoint of every road. No two roads cross, and precisely one path<br>(sequence of roads) links every pair of farms.</p><p>FJ lost his paper copy of the farm map and he wants to reconstruct it from backup information on his computer. This data contains lines like the following, one for every road:</p><p>There is a road of length 10 running north from Farm #23 to Farm #17<br>There is a road of length 7 running east from Farm #1 to Farm #17<br>…</p><p>As FJ is retrieving this data, he is occasionally interrupted by questions such as the following that he receives from his navigationally-challenged neighbor, farmer Bob:</p><p>What is the Manhattan distance between farms #1 and #23?</p><p>FJ answers Bob, when he can (sometimes he doesn’t yet have enough data yet). In the example above, the answer would be 17, since Bob wants to know the “Manhattan” distance between the pair of farms.<br>The Manhattan distance between two points (x1,y1) and (x2,y2) is just |x1-x2| + |y1-y2| (which is the distance a taxicab in a large city must travel over city streets in a perfect grid to connect two x,y points).</p><p>When Bob asks about a particular pair of farms, FJ might not yet have enough information to deduce the distance between them; in this case, FJ apologizes profusely and replies with “-1”.</p><p><strong>Input</strong></p><ul><li><p>Line 1: Two space-separated integers: N and M</p></li><li><p>Lines 2..M+1: Each line contains four space-separated entities, F1,<br>F2, L, and D that describe a road. F1 and F2 are numbers of<br>two farms connected by a road, L is its length, and D is a<br>character that is either ‘N’, ‘E’, ‘S’, or ‘W’ giving the<br>direction of the road from F1 to F2.</p></li><li><p>Line M+2: A single integer, K (1 &lt;&#x3D; K &lt;&#x3D; 10,000), the number of FB’s<br>queries</p></li><li><p>Lines M+3..M+K+2: Each line corresponds to a query from Farmer Bob<br>and contains three space-separated integers: F1, F2, and I. F1<br>and F2 are numbers of the two farms in the query and I is the<br>index (1 &lt;&#x3D; I &lt;&#x3D; M) in the data after which Bob asks the<br>query. Data index 1 is on line 2 of the input data, and so on.</p></li></ul><p><strong>Output</strong></p><ul><li>Lines 1..K: One integer per line, the response to each of Bob’s<br>queries.  Each line should contain either a distance<br>measurement or -1, if it is impossible to determine the<br>appropriate distance.</li></ul><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7 6</span><br><span class="line">1 6 13 E</span><br><span class="line">6 3 9 E</span><br><span class="line">3 5 7 S</span><br><span class="line">4 1 3 N</span><br><span class="line">2 4 20 W</span><br><span class="line">4 7 2 S</span><br><span class="line">3</span><br><span class="line">1 6 1</span><br><span class="line">1 4 3</span><br><span class="line">2 6 6</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">-1</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>Hint</strong></p><p>At time 1, FJ knows the distance between 1 and 6 is 13.<br>At time 3, the distance between 1 and 4 is still unknown.<br>At the end, location 6 is 3 units west and 7 north of 2, so the distance is 10.</p><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=USACO+2004+February">USACO 2004 February</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>显然用带权并查集维护子节点到根节点的坐标变化。</p><p>考虑用 $x$ 代表东西方向位移 ，$y$ 代表南北方向位移，取北和东为正方向。</p><p>压缩路径和合并都可以向量理解：</p><p>压缩路径，$\vec{ar} &#x3D; \vec{ab} + \vec{br}$ ，其中 $a$ 是待压缩节点，$b$ 是父节点，$r$ 是根节点。</p><p>合并集合，$\vec{AB} &#x3D; -\vec{aA} + \vec{ab} + \vec{bB}$ ，$a$ 和 $b$ 是条件给出节点，$A$ 和 $B$ 是条件节点所在集合的根节点，目的是把 $A$ 合并到 $B$。</p><p>输入输出极度复杂，需要先保存信息，再离线处理，在每个时间点记录答案，最后输出。</p><p>时间复杂度 $O(n + m\log n + k\log k)$</p><p>空间复杂度 $O(n+m+k)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;v[<span class="number">40007</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">40007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info1</span> &#123;</span><br><span class="line">    <span class="type">int</span> f1, f2, l;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125;in1[<span class="number">40007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info2</span> &#123;</span><br><span class="line">    <span class="type">int</span> f1, f2, t, id;</span><br><span class="line">&#125;in2[<span class="number">40007</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">40007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> pre = fa[x];</span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    v[x].x += v[pre].x;</span><br><span class="line">    v[x].y += v[pre].y;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Info2 a, Info2 b)</span> </span>&#123; <span class="keyword">return</span> a.t &lt; b.t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        cin &gt;&gt; in1[i].f1 &gt;&gt; in1[i].f2 &gt;&gt; in1[i].l &gt;&gt; in1[i].d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        cin &gt;&gt; in2[i].f1 &gt;&gt; in2[i].f2 &gt;&gt; in2[i].t;</span><br><span class="line">        in2[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(in2 + <span class="number">1</span>, in2 + <span class="number">1</span> + k, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>, pos = <span class="number">1</span>;t &lt;= m;t++) &#123;</span><br><span class="line">        <span class="type">int</span> r1 = <span class="built_in">find</span>(in1[t].f1);</span><br><span class="line">        <span class="type">int</span> r2 = <span class="built_in">find</span>(in1[t].f2);</span><br><span class="line">        <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;N&#x27;</span> || in1[t].d == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;N&#x27;</span>) y = in1[t].l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;S&#x27;</span>) y = -in1[t].l;</span><br><span class="line">            v[r1].x = -v[in1[t].f1].x + v[in1[t].f2].x;</span><br><span class="line">            v[r1].y = -v[in1[t].f1].y + y + v[in1[t].f2].y;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;E&#x27;</span> || in1[t].d == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;E&#x27;</span>) x = in1[t].l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;W&#x27;</span>) x = -in1[t].l;</span><br><span class="line">            v[r1].x = -v[in1[t].f1].x + x + v[in1[t].f2].x;</span><br><span class="line">            v[r1].y = -v[in1[t].f1].y + v[in1[t].f2].y;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[r1] = r2;</span><br><span class="line">        <span class="keyword">while</span> (t == in2[pos].t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(in2[pos].f1) == <span class="built_in">find</span>(in2[pos].f2)) &#123;</span><br><span class="line">                ans[in2[pos].id] = <span class="built_in">abs</span>(v[in2[pos].f1].x - v[in2[pos].f2].x) + <span class="built_in">abs</span>(v[in2[pos].f1].y - v[in2[pos].f2].y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ans[in2[pos].id] = <span class="number">-1</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1984&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ1417 True Liars</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1417%20True%20Liars/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1417%20True%20Liars/</id>
    <published>2022-07-10T15:29:25.000Z</published>
    <updated>2022-07-10T15:48:16.050Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1417">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>After having drifted about in a small boat for a couple of days, Akira Crusoe Maeda was finally cast ashore on a foggy island. Though he was exhausted and despaired, he was still fortunate to remember a legend of the foggy island, which he had heard from patriarchs in his childhood. This must be the island in the legend. In the legend, two tribes have inhabited the island, one is divine and the other is devilish, once members of the divine tribe bless you, your future is bright and promising, and your soul will eventually go to Heaven, in contrast, once members of the devilish tribe curse you, your future is bleak and hopeless, and your soul will eventually fall down to Hell.</p><p>In order to prevent the worst-case scenario, Akira should distinguish the devilish from the divine. But how? They looked exactly alike and he could not distinguish one from the other solely by their appearances. He still had his last hope, however. The members of the divine tribe are truth-tellers, that is, they always tell the truth and those of the devilish tribe are liars, that is, they always tell a lie.</p><p>He asked some of them whether or not some are divine. They knew one another very much and always responded to him “faithfully” according to their individual natures (i.e., they always tell the truth or always a lie). He did not dare to ask any other forms of questions, since the legend says that a devilish member would curse a person forever when he did not like the question. He had another piece of useful informationf the legend tells the populations of both tribes. These numbers in the legend are trustworthy since everyone living on this island is immortal and none have ever been born at least these millennia.</p><p>You are a good computer programmer and so requested to help Akira by writing a program that classifies the inhabitants according to their answers to his inquiries.</p><p><strong>Input</strong></p><p>The input consists of multiple data sets, each in the following format :</p><p>n p1 p2<br>xl yl a1<br>x2 y2 a2<br>…<br>xi yi ai<br>…<br>xn yn an</p><p>The first line has three non-negative integers n, p1, and p2. n is the number of questions Akira asked. pl and p2 are the populations of the divine and devilish tribes, respectively, in the legend. Each of the following n lines has two integers xi, yi and one word ai. xi and yi are the identification numbers of inhabitants, each of which is between 1 and p1 + p2, inclusive. ai is either yes, if the inhabitant xi said that the inhabitant yi was a member of the divine tribe, or no, otherwise. Note that xi and yi can be the same number since “are you a member of the divine tribe?” is a valid question. Note also that two lines may have the same x’s and y’s since Akira was very upset and might have asked the same question to the same one more than once.</p><p>You may assume that n is less than 1000 and that p1 and p2 are less than 300. A line with three zeros, i.e., 0 0 0, represents the end of the input. You can assume that each data set is consistent and no contradictory answers are included.</p><p><strong>Output</strong></p><p>For each data set, if it includes sufficient information to classify all the inhabitants, print the identification numbers of all the divine ones in ascending order, one in a line. In addition, following the output numbers, print end in a line. Otherwise, i.e., if a given data set does not include sufficient information to identify all the divine members, print no in a line.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2 1 1</span><br><span class="line">1 2 no</span><br><span class="line">2 1 no</span><br><span class="line">3 2 1</span><br><span class="line">1 1 yes</span><br><span class="line">2 2 yes</span><br><span class="line">3 3 yes</span><br><span class="line">2 2 1</span><br><span class="line">1 2 yes</span><br><span class="line">2 3 no</span><br><span class="line">5 4 3</span><br><span class="line">1 2 yes</span><br><span class="line">1 3 no</span><br><span class="line">4 5 yes</span><br><span class="line">5 6 yes</span><br><span class="line">6 7 no</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">end</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=Japan+2002+Kanazawa">Japan 2002 Kanazawa</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：并查集，背包dp。</strong></p><p>这题第一眼看上去用扩展域并查集能做，但确实能做，就是烦死人。因为扩展域并查集不记录元素之间的相对关系，之后不是判断条件矛盾，而是需要把每个关系集合的各类人数具体记录，因此一开始就记录在一个关系集合的带权并查集会更好，免去了查找某个元素在哪个关系集合的麻烦。</p><p>时间复杂度 $O(n\log(p_1+p_2) + np_1+p_2)$</p><p>空间复杂度 $O(p_1\cdot (p_1+p_2))$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：并查集，背包dp。</strong></p><p>用带权并查集是最优解，在处理完关系后能直接分类。随后是一个简单的计数dp，如果 $dp[tot][p1] &#x3D; 1$ 则说明有且仅有一种方法能凑成 $p1$ 的好人，所以是可行的，然后逆推求每次选择在各个关系集合选择类别，最后遍历编号，输出对应集合选择类别和自己相应的人的编号即可。</p><p>时间复杂度 $O(n\log(p_1+p_2) + np_1 + p_2)$</p><p>空间复杂度 $O(p_1\cdot (p_1+p_2))$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">1207</span>], feat[<span class="number">607</span>], num[<span class="number">1207</span>], cnt[<span class="number">607</span>][<span class="number">2</span>], dp[<span class="number">607</span>][<span class="number">607</span>], ans[<span class="number">607</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, p1, p2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; p1 &gt;&gt; p2, n || p1 || p2) &#123;</span><br><span class="line">        <span class="type">int</span> m = p1 + p2;</span><br><span class="line">        <span class="built_in">memset</span>(feat, <span class="number">0</span>, <span class="built_in">sizeof</span>(feat));</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span> * m;i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            string a;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; a;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&quot;yes&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x, y);</span><br><span class="line">                <span class="built_in">merge</span>(x + m, y + m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">&quot;no&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x, y + m);</span><br><span class="line">                <span class="built_in">merge</span>(x + m, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///扩展域（种类）并查集把每个元素的所有可能扩展为一个独立的种类元素，将等价的种类元素（必然同时出现）放入一个集合，构成</span></span><br><span class="line">        <span class="comment">///因为种类元素列出了所有可能，故可以容易检验新关系的合法性，只需检验与新关系矛盾的所有集合是否存在</span></span><br><span class="line">        <span class="comment">///因为构造了等价类，所以容易检验元素的等价关系（能否同时出现），但访问在同一关系集合中原元素的互相的具体种类关系需要划分等价类</span></span><br><span class="line">        <span class="comment">///确立一个标准等价类，其他同一关系集合的等价类元素以此基准分类，难点在需要检验标准等价类是否已经存在</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///带权并查集将同一关系集合的元素放入一个集合，用权值确定一个集合的元素互相的具体种类关系，使得划分了等价类非常容易</span></span><br><span class="line">        <span class="comment">///通过权值可以容易检验新关系的合法性，可以容易访问元素的种类关系（等价关系更容易）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num[<span class="built_in">find</span>(i)] &amp;&amp; !num[<span class="built_in">find</span>(i + m)]) num[<span class="built_in">find</span>(i)] = ++tot;</span><br><span class="line">            <span class="keyword">if</span> (!num[<span class="built_in">find</span>(i)]) feat[i] = <span class="number">1</span>, cnt[num[<span class="built_in">find</span>(i + m)]][<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!num[<span class="built_in">find</span>(i + m)]) feat[i] = <span class="number">0</span>, cnt[num[<span class="built_in">find</span>(i)]][<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///如果自己等价类和其他同一关系集合的等价类都没编号，则给自己等价类记录编号，自己等价类和其他等价类有且仅有一个有编号，作为基准</span></span><br><span class="line">        <span class="comment">///权值是相对于基准等价类</span></span><br><span class="line">        <span class="comment">///如果自己集合没编号，则自己在标准等价类的同一关系集合下的其他等价类，根据种类位置，种类值为1</span></span><br><span class="line">        <span class="comment">///如果自己集合有编号，则自己在标准等价类，因此种类值为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= p1;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cnt[i][<span class="number">0</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cnt[i][<span class="number">1</span>]) dp[i][j] += dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">1</span>]];</span><br><span class="line">            &#125;<span class="comment">///简单的计数DP</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[tot][p1] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = tot, j = p1;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]]) ans[i] = <span class="number">0</span>, j -= cnt[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> ans[i] = <span class="number">1</span>, j -= cnt[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (feat[i] == ans[num[<span class="built_in">find</span>(i)] ? num[<span class="built_in">find</span>(i)] : num[<span class="built_in">find</span>(i + m)]]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">///扩展域并查集遗留问题，没有把同一关系集合元素放在一起</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">607</span>], num[<span class="number">607</span>], cnt[<span class="number">607</span>][<span class="number">2</span>], dp[<span class="number">607</span>][<span class="number">607</span>], ans[<span class="number">607</span>];</span><br><span class="line"><span class="type">bool</span> v[<span class="number">607</span>];<span class="comment">///0表示与父节点同类，1表示异类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> pre = fa[x];</span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    v[x] ^= v[pre];</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, p1, p2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; p1 &gt;&gt; p2, n || p1 || p2) &#123;</span><br><span class="line">        <span class="type">int</span> m = p1 + p2;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            string a;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; a;</span><br><span class="line">            <span class="type">bool</span> z = a == <span class="string">&quot;no&quot;</span>;</span><br><span class="line">            <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">            v[rx] = v[x] ^ z ^ v[y];</span><br><span class="line">            fa[rx] = ry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="type">int</span> ri = <span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!num[ri]) num[ri] = ++tot;</span><br><span class="line">            cnt[num[ri]][v[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= p1;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cnt[i][<span class="number">0</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cnt[i][<span class="number">1</span>]) dp[i][j] += dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[tot][p1] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = tot, j = p1;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]]) ans[i] = <span class="number">0</span>, j -= cnt[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> ans[i] = <span class="number">1</span>, j -= cnt[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i] == ans[num[<span class="built_in">find</span>(i)]]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1417&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="背包dp" scheme="https://blankyang233.github.io/tags/%E8%83%8C%E5%8C%85dp/"/>
    
  </entry>
  
  <entry>
    <title>POJ1456 Supermarket</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1456%20Supermarket/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1456%20Supermarket/</id>
    <published>2022-07-10T15:15:16.000Z</published>
    <updated>2022-07-10T15:16:41.790Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1456">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>A supermarket has a set Prod of products on sale. It earns a profit px for each product x∈Prod sold by a deadline dx that is measured as an integral number of time units starting from the moment the sale begins. Each product takes precisely one unit of time for being sold. A selling schedule is an ordered subset of products Sell ≤ Prod such that the selling of each product x∈Sell, according to the ordering of Sell, completes before the deadline dx or just when dx expires. The profit of the selling schedule is Profit(Sell)&#x3D;Σx∈Sellpx. An optimal selling schedule is a schedule with a maximum profit. </p><p>For example, consider the products Prod&#x3D;{a,b,c,d} with (pa,da)&#x3D;(50,2), (pb,db)&#x3D;(10,1), (pc,dc)&#x3D;(20,2), and (pd,dd)&#x3D;(30,1). The possible selling schedules are listed in table 1. For instance, the schedule Sell&#x3D;{d,a} shows that the selling of product d starts at time 0 and ends at time 1, while the selling of product a starts at time 1 and ends at time 2. Each of these products is sold by its deadline. Sell is the optimal schedule and its profit is 80.</p><p> <img src="http://poj.org/images/1456_1.jpg" alt="img"> </p><p>Write a program that reads sets of products from an input text file and computes the profit of an optimal selling schedule for each set of products.</p><p><strong>Input</strong></p><p>A set of products starts with an integer 0 &lt;&#x3D; n &lt;&#x3D; 10000, which is the number of products in the set, and continues with n pairs pi di of integers, 1 &lt;&#x3D; pi &lt;&#x3D; 10000 and 1 &lt;&#x3D; di &lt;&#x3D; 10000, that designate the profit and the selling deadline of the i-th product. White spaces can occur freely in input. Input data terminate with an end of file and are guaranteed correct.</p><p><strong>Output</strong></p><p>For each set of products, the program prints on the standard output the profit of an optimal selling schedule for the set. Each result is printed from the beginning of a separate line.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4  50 2  10 1   20 2   30 1</span><br><span class="line"></span><br><span class="line">7  20 1   2 1   10 3  100 2   8 2</span><br><span class="line">   5 20  50 10</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">80</span><br><span class="line">185</span><br></pre></td></tr></table></figure><p><strong>Hint</strong></p><p>The sample input contains two product sets. The first set encodes the products from table 1. The second set is for 7 products. The profit of an optimal schedule for these products is 185.</p><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=Southeastern+Europe+2003">Southeastern Europe 2003</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：并查集，贪心。</strong></p><p>这道题和并查集结合起来还是挺妙的。</p><p>首先考虑一个贪心，每次先安排价值最高的。如此选择，如果一个货物在期限之前无法安排，那说明其期限之前的所有天数都被比他价值高的货物占据了，此时这个货物可以被抛弃，强行售出只会降低总收益。</p><p>为了判断货物是否存在某天能够被安排，需要知道其距离期限最近的一个可用天数，因为如果选过早的话，可能会把其他期限靠前的货物的机会使用掉。考虑使用并查集维护从过期时间向前数的第一个未占用位置，如果第一个未被占用位置为 $0$ 则说明没有位置。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：贪心，优先队列。</strong></p><p>典型的后悔贪心题。花费是常数 $1$ ，限制和收益是变量。使用小顶堆维护后悔操作，按从限制从小到大排序入队。</p><p>时间复杂度 $O(n\log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, d;</span><br><span class="line">&#125;a[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.p &gt; b.p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1e4</span>;i++) fa[i] = i;<span class="comment">///注意是天数的集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)  cin &gt;&gt; a[i].p &gt;&gt; a[i].d;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">find</span>(a[i].d);</span><br><span class="line">            <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                <span class="built_in">merge</span>(r, r - <span class="number">1</span>);<span class="comment">///以之前的第一个可用天为根，即把之前的第一个可用天当作从此天开始的可用天</span></span><br><span class="line">                sum += a[i].p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, d;</span><br><span class="line">&#125;a[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> a.d &lt; b.d; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i].p &gt;&gt; a[i].d;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; pq;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(a[i].p);</span><br><span class="line">            sum += a[i].p;</span><br><span class="line">            <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; a[i].d) &#123;</span><br><span class="line">                sum -= pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1456&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC235745 拆路</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC235745%20%E6%8B%86%E8%B7%AF/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC235745%20%E6%8B%86%E8%B7%AF/</id>
    <published>2022-07-10T14:05:46.000Z</published>
    <updated>2022-07-10T15:53:41.035Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/235745">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  有 $n$ 个城镇，城镇之间有 $m$ 条道路相连，道路可以看成无向边。每一个城镇都有自己的一个繁荣度 $v_i$ ，一个城镇 $u$ 受到的影响 $p$ 是与$u$ 直接或者间接相连的所有城镇中，繁荣度的最大值。一个城镇 $u$ 与城镇 $v$ 是被视为直接或者间接相连的，当且仅当 $u&#x3D;v$ 或者从 $u$ 出发，可以沿着某些道路到达 $v$ 。为了减少维护成本，现准备拆除其中的某一些路。具体来说，你需要维护以下两种操作：  </p><ol><li>​    ‘Q’ $a$，询问 $a$ 城镇受到的影响 $p$ ；    </li><li>​    ‘D’ $a\ b$ ，删除 $a\ b$ 之间的道路。</li></ol><p><strong>输入描述</strong></p><p>第一行输入两个整数 $n,m(1\le n,m \le 10^5)$ ，分别表示城镇的数量和道路的数量。第二行输入 $n$ 个整数 $v_1,v_2,…,v_n(1\le v_i \le 10^9)$ ，分别表示每一个城镇的繁荣度。接下来 $m$ 行，每行两个整数 $u,v(1\le u,v \le n)$ ，表示城镇 $u,v$ 之间有一条道路连接。保证不含有重边、自环。<br>接下来一行，输入一个整数 $Q(1\le Q \le 10^5)$ ，表示操作的个数。<br>接下来 $Q$ 行，每行描述一个操作，以’Q’  $a(1\le a \le n)$ 或者’D’ $a\ b(1\le a,b \le n)$ 的形式给出。对于删除操作，保证被删除的道路是存在的。</p><p><strong>输出描述</strong></p><p>对于每一个操作1，你都需要输出一个整数 $p$ ，表示城镇 $a$ 受到的影响。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4</span><br><span class="line">Q 1</span><br><span class="line">D 2 3</span><br><span class="line">Q 1</span><br><span class="line">Q 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集，离线。</strong></p><p>普通并查集不支持撤销操作，这使得这道题难以解答，但转换一下思路，撤销的逆过程是新增，是并查集适用的操作，于是可以保存所有访问数据，离线逆向处理，再将答案保存最后输出即可。</p><p>时间复杂度 $O((m \log n + q)\log q + n)$</p><p>空间复杂度 $O(q+n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> u[<span class="number">100007</span>], v[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> du[<span class="number">100007</span>], dv[<span class="number">100007</span>];</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; s;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (w[rx] &lt; w[ry]) fa[rx] = ry;</span><br><span class="line">    <span class="keyword">else</span> fa[ry] = rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cin &gt;&gt; u[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;Q&#x27;</span>) cin &gt;&gt; du[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; du[i] &gt;&gt; dv[i];</span><br><span class="line">            s.<span class="built_in">insert</span>(&#123; du[i],dv[i] &#125;);</span><br><span class="line">            s.<span class="built_in">insert</span>(&#123; dv[i],du[i] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(&#123; u[i],v[i] &#125;) == s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">merge</span>(u[i], v[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = q;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dv[i]) <span class="built_in">merge</span>(du[i], dv[i]);</span><br><span class="line">        <span class="keyword">else</span> ans[i] = w[<span class="built_in">find</span>(du[i])];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/235745&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="离线" scheme="https://blankyang233.github.io/tags/%E7%A6%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>NC51097 Parity game</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC51097%20Parity%20game/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC51097%20Parity%20game/</id>
    <published>2022-07-10T13:45:16.000Z</published>
    <updated>2022-07-10T15:09:57.450Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/51097">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Now and then you play the following game with your friend. Your friend writes down a sequence consisting of zeroes and ones. You choose a continuous subsequence (for example the subsequence from the third to the fifth digit inclusively) and ask him, whether this subsequence contains even or odd number of ones. Your friend answers your question and you can ask him about another subsequence and so on. Your task is to guess the entire sequence of numbers.<br> You suspect some of your friend’s answers may not be correct and you want to convict him of falsehood. Thus you have decided to write a program to help you in this matter. The program will receive a series of your questions together with the answers you have received from your friend. The aim of this program is to find the first answer which is provably wrong, i.e. that there exists a sequence satisfying answers to all the previous questions, but no such sequence satisfies this answer.</p><p><strong>输入描述</strong></p><p>The first line of input contains one number, which is the length of the sequence of zeroes and ones. This length is less or equal to 1000000000. In the second line, there is one positive integer which is the number of questions asked and answers to them. The number of questions and answers is less or equal to 5000. The remaining lines specify questions and answers. Each line contains one question and the answer to this question: two integers (the position of the first and last digit in the chosen subsequence) and one word which is either <code>even</code> or <code>odd</code> (the answer, i.e. the parity of the number of ones in the chosen subsequence, where <code>even</code> means an even number of ones and <code>odd</code> means an odd number).</p><p><strong>输出描述</strong></p><p>There is only one line in output containing one integer X. Number X says that there exists a sequence of zeroes and ones satisfying first X parity conditions, but there exists none satisfying X+1 conditions. If there exists a sequence of zeroes and ones satisfying all the given conditions, then number X should be the number of all the questions asked.</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5</span><br><span class="line">1 2 even</span><br><span class="line">3 4 odd</span><br><span class="line">5 6 even</span><br><span class="line">1 6 even</span><br><span class="line">7 10 odd</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>每次条件给出了一个区间 $[l,r]$ 的 $01$ 串中 $1$ 的个数是奇数还是偶数，区间很难处理，但我们可以转化为 $sum[r]-sum[l-1]$ ，即 $sum[i]$ 表示 $[1,i]$ 之间 $1$ 的个数。若 $[l,r]$ 是偶数，则 $sum[r]$ 和 $sum[l-1]$ 一定是同奇偶；否则就是异奇偶。</p><p>如此就转换成端点的种类的相对关系了，而且题目只需要我们检查条件矛盾个数，那就自然而然使用扩展域并查集。</p><p>由于节点编号很大，采用遇到一个节点初始化一个节点的策略，并用 $map$ 离散化记录。</p><p>时间复杂度 $O(q \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; fa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    n++;<span class="comment">///范围从0开始到n</span></span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>;cnt &lt; q;cnt++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (!fa.<span class="built_in">count</span>(x - <span class="number">1</span>)) fa[x - <span class="number">1</span>] = x - <span class="number">1</span>, fa[x - <span class="number">1</span> + n] = x - <span class="number">1</span> + n;</span><br><span class="line">        <span class="keyword">if</span> (!fa.<span class="built_in">count</span>(y)) fa[y] = y, fa[y + n] = y + n;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;even&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x - <span class="number">1</span>) == <span class="built_in">find</span>(y + n)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span>, y);</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span> + n, y + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;odd&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x - <span class="number">1</span>) == <span class="built_in">find</span>(y)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span>, y + n);</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span> + n, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/51097&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC16884 [NOI2001]食物链</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC16884%20[NOI2001]%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC16884%20[NOI2001]%E9%A3%9F%E7%89%A9%E9%93%BE/</id>
    <published>2022-07-10T13:31:16.000Z</published>
    <updated>2022-07-10T15:50:38.447Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16884">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。 </p><p>  现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 </p><p>  有人用两种说法对这N个动物所构成的食物链关系进行描述： </p><p>  第一种说法是“1 X Y”，表示X和Y是同类。 </p><p>  第二种说法是“2 X Y”，表示X吃Y。 </p><p>  此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 </p><p>  1） 当前的话与前面的某些真的话冲突，就是假话； </p><p>  2） 当前的话中X或Y比N大，就是假话； </p><p>  3） 当前的话表示X吃X，就是假话。 </p><p>  你的任务是根据给定的N（1≤N≤50,000）和K句话（0≤K≤100,000），输出假话的总数。 </p><p><strong>输入描述</strong></p><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D&#x3D;1，则表示X和Y是同类。<br>若D&#x3D;2，则表示X吃Y。</p><p><strong>输出描述</strong></p><p>只有一个整数，表示假话的数目。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1   </span><br><span class="line">2 1 2     </span><br><span class="line">2 2 3     </span><br><span class="line">2 3 3     </span><br><span class="line">1 1 3     </span><br><span class="line">2 3 1     </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p> <img src="https://uploadfiles.nowcoder.com/images/20180701/305473_1530452990874_8C754812CCEC7267CC44FF197D74283A" alt="img"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：并查集。</strong></p><p>用权值代表其关于根节点的种类，根节点设为 $0$ ，其他的同类为 $0$ ，根节点是猎物为 $1$ ，根节点是天敌为 $2$ 。</p><p>因为种类形成环状具有传递性关系，因此路径压缩可以利用自身权值加父节点路径压缩后的权值对 $3$ 取模即可，递归实现。</p><p>合并集合时，已知两个节点 $a$ 和 $b$ 路径压缩后的权值以及$a$ 关于 $b$ 的权值，要求出集合根节点 $A$ 认 $B$ 为父后的权值，因为具有环状传递性，所以可以利用向量的思想，$\vec{AB} &#x3D; -\vec{aA}+\vec{ab}+\vec{bB}$ ，随后对 $|\vec{AB}|$ 模 $3$ 即可，注意不要出现负数。</p><p>如果给出的关系的两个对象已经在同一个关系集合，那么检查他们关系是否和给出的条件吻合，即 $\vec{ab} &#x3D;&#x3D; \vec{aA} - \vec{bA}$ ，左边是条件右边是已有的关系，不吻合的答案加一。</p><p>时间复杂度 $O(k\log n + n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：并查集。</strong></p><p>实际上第一种解法较为繁琐，我们只关心条件之间是否矛盾，即给出的条件的两个对象已经建立了关系，检测已有关系和给出的关系是否矛盾。因此可以用扩展域并查集，其把元素的所有可能种类扩展各个独立元素，只对有具体种类的元素建立关系集合中的具体等价类（等价类的元素会同时出现），而不把相关的具体等价类并在一个集合产生完整的关系集合，利用权值进行相对分类（带权并查集是记录了一整个关系集合，并用权值做了相对根节点的关系划分），而这对于检测矛盾已经足够了。</p><p>具体地说，一个动物元素只有三种种类，我们记为 $A$，$B$，$C$，其中 $A$ 吃 $B$ ， $B$ 吃 $C$ ， $C$ 吃 $A$ 。扩展域并查集把每个动物元素扩展成这 $3$ 个有具体种类的动物元素，分别放在 $[1,n],[n+1,2n],[2n+1，3n] $ 中。</p><p>假设给出 $a$ 吃 $b$，则会合并三个等价类 $[a]$ 与 $[b+n]$ ， $[a+n]$ 与 $[b+2n]$ ， $[a+2n]$ 与 $[b]$ ，表示 $a$ 是 $A$ 时 $b$ 一定是 $B$， $a$ 是 $B$ 时 $b$ 一定是 $C$，$a$ 是 $C$ 时 $b$ 一定是 $A$ ，这样就根据条件合并了两个对象的三组具体种类的等价类。注意一个条件一定能合并三组等价类，因为这三个等价类是一个关系集合的三个具体种类表现，同样的一个等价类出现一定有其余两个等价类，且他们种类刚好补全所有情况。比如， $[a] &#x3D; [b]$ 出现则一定有 $[a+n] &#x3D; [b+n]$ 和 $[a+2n] &#x3D; [b +2n]$，因为他们是一个同一个相对关系（同类）的三个具体表现。</p><p>另一方面，对于 $a$ 吃 $b$ 的条件，如果它们已经在一个关系集合（已有相对关系），则它们之间一定产生了三个等价类，而如果这些等价类刚好是 $[a] &#x3D; [b]$ 或者 $[a] &#x3D; [b+2n]$ ，即表达 $a$ 与 $b$ 同类或者 $a$ 的天敌是 $b$ 就很容易判断出已知条件与给出的这个条件矛盾。</p><p>因此，扩展域并查集能够维护元素不同种类之间同时出现的集合，即等价类，容易直接判断出条件是否矛盾。但弊端也很明显，只适合检验某个条件相对关系是否满足现有关系，而不能直接列举出元素的相对关系，因为扩展域并查集只保存了元素具体种类的等价关系，而没有完整记录元素在关系集合中的相对关系，导致等价类之间是割裂的，没有直接相关性的。比如我想要知道动物 $a$ 和 动物 $b$ 的相对关系，就得先拿 $a$ 的某个种类所在的等价类集合作为一个基准集合，再枚举 $b$ 的所有种类($A,B,C$)是否处在这个基准集合，如果有关系则有且仅有一个具体种类处在基准集合进而判断其相对关系，而都没有处在基准集合说明 $a$ 和 $b$ 尚未建立关系。这个过程带权并查集能在合并和查询过程中直接实现，因此如果题目要求并不是检验条件矛盾这么简单的话，比如要求得知 $a$ 和 $b$ 的相对关系用以后续解题，那带权并查集会更加合适。</p><p>时间复杂度 $O(k\log n + n)$</p><p>空间复杂度 $O(n)$ ，实际上是三倍空间</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">50007</span>], dist[<span class="number">50007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x) &#123;</span><br><span class="line">        <span class="type">int</span> pre = fa[x];</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(pre);</span><br><span class="line">        dist[x] = (dist[x] + dist[pre]) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="type">int</span> delta = (dist[x] - dist[y] + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span> delta == op;</span><br><span class="line">    fa[rx] = ry;</span><br><span class="line">    dist[rx] = (op - delta + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        op--;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">merge</span>(x, y, op)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">150007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span> * n;i++) fa[i] = i;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n)ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + n) || <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + <span class="number">2</span> * n)) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">merge</span>(x, y), <span class="built_in">merge</span>(x + n, y + n), <span class="built_in">merge</span>(x + <span class="number">2</span> * n, y + <span class="number">2</span> * n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + <span class="number">2</span> * n) || <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">merge</span>(x, y + n), <span class="built_in">merge</span>(x + n, y + <span class="number">2</span> * n), <span class="built_in">merge</span>(x + <span class="number">2</span> * n, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16884&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC24608 [USACO 2011 Ope S]Learning Languages</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC24608%20[USACO%202011%20Ope%20S]Learning%20Languages/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC24608%20[USACO%202011%20Ope%20S]Learning%20Languages/</id>
    <published>2022-07-10T10:34:55.000Z</published>
    <updated>2022-07-10T15:52:29.592Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/24608">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Farmer John’s N (2 &lt;&#x3D; N &lt;&#x3D; 10,000) cows, conveniently numbered 1..N, are fluent in some M (1 &lt;&#x3D; M &lt;&#x3D; 30,000) languages, also conveniently numbered from 1..M. Cow i can speak in KiK_iKi (1 &lt;&#x3D; $K_i$ &lt;&#x3D; M) languages, namely $L_{i_1}, L_{i_2},…, L_{i_{K_i}}$ (1 &lt;&#x3D; $L_{i_j}$ &lt;&#x3D; M). FJ’s cows aren’t THAT smart, so the sum of $K_i$ over all cows i is at most 100,000.<br> Two cows can’t directly talk to each other unless both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows A and B can have a conversation if and only if there exists a sequence of cows $T_1, T_2, …, T_k$​ such that A and $T_1$​ share a language, $T_1$​ and $T_2$​ share a language, etc., and $T_k$​ and B share a language.<br> Farmer John wishes that his cows could be even more social, so he wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being a fairly frugal farmer, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:<br> * The minimum number of books he must purchase<br> * Any set of books assigned to cows in any order which will help him meet this goal; a program will grade your output.</p><p>  By way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone. </p><p> #1   #2   #3<br> Alberta           x    x<br> Bessie            x<br> Contessa     x</p><p> FJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.<br> Note that an alternate solution exists: instead, FJ could buy<br> Contessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.</p><p><strong>输入描述</strong></p><ul><li>Line 1: Two space-separated integers: N and M</li><li>Lines 2..N+1: Line i+1 describes the languages that cow i can speak with Ki+1K_i+1Ki+1 space-separated integers: $K_i$, $L_{i_1}, L_{i_2},…, L_{i_{K_i}}$.</li></ul><p><strong>输出描述</strong></p><ul><li>Line 1: A single integer that is the minimum number of books that FJ must purchase.</li><li>Lines 2..B+1: Line i+1 contains two space-separated integers: the language id # and the id # of the cow to receive book i. If multiple solutions exist, print any one.</li></ul><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 </span><br><span class="line">2 3 2 </span><br><span class="line">1 2 </span><br><span class="line">1 1 </span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>本题显然用并查集，但需要做扩展域。</p><p>牛与牛之间关系不是简单联系的，而是通过语言种类作为桥梁。因此将语言种类集合并入牛集合作为合并的桥梁集合，只要牛通过语言桥梁集合与另一只牛连通，即能够交流。</p><p>具体上，在牛的集合 $[1,n]$ 后加入语言集合 $[n+1,m]$ 即可，每次合并务必用牛作为根节点，是为了防止有些语言所有牛不会单独成为集合，干扰有效集合计数。只要把牛作为根节点，就只需要在 $[1,n]$ 计数，不会产生桥梁集合单独存在的问题。</p><p>最后牛区间中不同集合的数量减一，就是要连接的(牛-&gt;语言)边的数量。</p><p>时间复杂度 $O(nk\log (n+m)+m)$</p><p>空间复杂度 $P(n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">40007</span>];<span class="comment">///牛与书的扩展集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n + m;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="type">int</span> l;</span><br><span class="line">            cin &gt;&gt; l;</span><br><span class="line">            <span class="built_in">merge</span>(i, l + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;<span class="comment">///语言可能多出来</span></span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/24608&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC15976 小C的周末</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC15976%20%E5%B0%8FC%E7%9A%84%E5%91%A8%E6%9C%AB/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC15976%20%E5%B0%8FC%E7%9A%84%E5%91%A8%E6%9C%AB/</id>
    <published>2022-07-10T08:23:48.000Z</published>
    <updated>2022-07-10T08:24:14.514Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15976">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>愉快的周末到了，小C和他的N-1个朋友买了M个游戏，游戏编号从1~M。每个游戏都是多人游戏，他们打算周末一起打游戏。</p><p> 小C的每个朋友都决定好了要玩哪一款游戏（会有一组人打同一款游戏），并且每人手上都有一台游戏机，这种游戏机可以通过特定的游戏机连接线连接起来。</p><p> 但是，他们面临着一个问题：目前没有一个朋友的游戏机是互相连接的。所以它们必须用可用的游戏机连接线连接起来。小C决定依次使用第 i 条连接线把他的朋友 ui 和 vi 的游戏机连接起来。也就是说，假设有Q条连接线，小C只能先使用第一条，然后使用第二条，然后使用第三条。。。最后使用第Q条。</p><p> 一个游戏能开始的条件是所有玩这个游戏的朋友的游戏机都被连接起来（如果不是直接连接的话，那么就必须存在一条连接它们的路径）。他们希望尽快开始比赛。</p><p> 在每个游戏中，找出在添加了第几条连接线之后能开始游戏。如果在一个游戏中只有一个人玩，则输出0（因为他立马可以开始游戏）。如果不存在，则输出-1</p><p><strong>输入描述</strong></p><p>多组输入</p><p>第一行包含三个整数N，M，Q。</p><p>第二行给N个用空格分隔的整数，第 i 个整数代表第 i 个朋友想玩的游戏。</p><p>接下来的Q行，每行两个整数(u, v)，代表电线 i 连接的两个人的电脑</p><p>1 &lt;&#x3D; N, M &lt;&#x3D; 10^5<br>0 &lt;&#x3D; Q &lt;&#x3D; 10^5</p><p><strong>输出描述</strong></p><p>对于每个游戏，输出一个整数，表示添加了第几条连接线之后能开始游戏，每行以换行符结束</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 2 4</span><br><span class="line">1 2 2 2 1</span><br><span class="line">1 2 </span><br><span class="line">2 3</span><br><span class="line">1 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>第一个游戏有两个人参加（1，5），在添加了第三条电线之后他们电脑互相连接</p><p>第二个游戏三个人参加（2， 3， 4），在添加第四条电线之后他们电脑互相连接</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>这道题用单纯的并查集维护互联关系是不够的，需要权值去表达哪些有些连了那些人。由于每个人只可能玩一个游戏，那么只要计数相等那么就说明人齐了。</p><p>所以先用 $cnt[i]$ 记录第 $i$ 个游戏有多少人。权值用 $map$ 数组维护，$map[i]$ 代表第 $i$ 个人作为根节点时，其集合里游戏以及对应的人数。</p><p>合并时遍历被合并的权值 $map$ 加入父集合的权值 $map$ ，过程中用 $ans[i]$ 记录第 $i$ 个游戏在第几根线连接时能够开始游戏，因为要按游戏编号输出所以用游戏编号作为下标记下来。</p><p>最后按顺序输出 $ans$ 即可。</p><p>要注意有些游戏可能只有一个人，那么在输出时先判断是不是一个人，再输出 $0$ 即可；也有可能有些游戏没人玩，直接输出 $-1$ 。$ans$ 初始化为 $-1$ 因为某些游戏可能能玩的人到最后还不够所以没更改 $ans$ 就可以直接输出 $-1$。</p><p>注意是多组数据输入。</p><p>时间复杂度 $O(q\log n + (n+m)\log m)$</p><p>空间复杂度 $O(n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>], cnt[<span class="number">100007</span>], ans[<span class="number">100007</span>];<span class="comment">///fa表示连接起来的人，cnt记录每个游戏人数，ans记录答案因为最后按游戏排序</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp[<span class="number">100007</span>];<span class="comment">///mp[i][j] 第i个根节点的游戏种类及其对应数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i, mp[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            cin &gt;&gt; tmp;</span><br><span class="line">            cnt[tmp]++;</span><br><span class="line">            mp[i][tmp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>;t &lt;= q;t++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            u = <span class="built_in">find</span>(u);</span><br><span class="line">            v = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (mp[u].<span class="built_in">size</span>() &gt; mp[v].<span class="built_in">size</span>()) <span class="built_in">swap</span>(u, v);</span><br><span class="line">            fa[u] = v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp[u]) &#123;</span><br><span class="line">                mp[v][i] += j;</span><br><span class="line">                <span class="keyword">if</span> (mp[v][i] == cnt[i]) ans[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &lt;= <span class="number">1</span>) cout &lt;&lt; cnt[i] - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15976&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ1988 Cube Stacking</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1988%20Cube%20Stacking/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1988%20Cube%20Stacking/</id>
    <published>2022-07-10T08:05:22.000Z</published>
    <updated>2022-07-10T15:49:39.672Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1988">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>Farmer John and Betsy are playing a game with N (1 &lt;&#x3D; N &lt;&#x3D; 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;&#x3D; P &lt;&#x3D; 100,000) operation. There are two types of operations:<br>moves and counts.<br>* In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.<br>* In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.</p><p>Write a program that can verify the results of the game.</p><p>Input</p><p>* Line 1: A single integer, P</p><p>* Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.</p><p>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.</p><p>Output</p><p>Print the output from each of the count operations in the same order as the input file.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">M 1 6</span><br><span class="line">C 1</span><br><span class="line">M 2 4</span><br><span class="line">M 2 6</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=USACO+2004+U+S+Open">USACO 2004 U S Open</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>一道典型的带权并查集题。我们用栈底方块作为根节点，权值代表到栈底（根节点）有多少个方块。但还有个问题，两个栈合并时我们并不知道合并到底部的栈有多少个方块，该给被合并的栈的根节点多少权值，于是我们可以用另一个权值数组，或者直接用原来的根节点权值代表这个栈有多少方块，这样合并时候就能直到给根节点赋值多少了。</p><p>带权并查集的路径压缩和合并操作都能用向量理解。</p><p>首先是路径压缩，已知 $A$ 到父节点 $B$ 的权值，即 $A$ 下面到 $B$ 有多少方块，以及 $B$  到根节点的权值，那么 $A$ 到根节点的权值就是 $A$ 到父节点 $B$ 的权值加上 $B$  到根节点的权值，即 $\vec{AB} + \vec{BR} &#x3D; \vec{AR}$。这样递归实现即可，先解决 $B$ 到根节点的权值问题，再解决 $A$ 到根节点的权值问题。</p><p>其次是合并操作，我们要把栈 $A$ 放在栈 $B$ 之上，那么 $B$ 权就为 $A$ 方块数加上 $B$ 的方块数，$A$ 权就为 $B$ 的方块数，即 $\vec{AB} &#x3D; |B|$ ，$|B| &#x3D; |A|+|B|$ 。这里因为根节点的权值与其他节点意义不同，没有体现向量解释的妙qwq。</p><p>时间复杂度 $O(P\log N + N)$</p><p>空间复杂度 $O(N)$   </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">30007</span>], a[<span class="number">30007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x; <span class="comment">///返回根节点</span></span><br><span class="line">    <span class="type">int</span> pre = fa[x];<span class="comment">///保存原父节点</span></span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);<span class="comment">///更新原父节点到根节点的距离，更新父节点为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (pre != fa[pre]) a[x] += a[pre];<span class="comment">///原父节点不是根节点，则距离为原父节点到根节点距离加自身到原父节点距离</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];<span class="comment">///返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///根节点栈底元素，权值表示整个栈元素个数</span></span><br><span class="line"><span class="comment">///其他节点表示非栈底元素，权值表示到父节点的距离</span></span><br><span class="line"><span class="comment">///当然也可以把距离和栈大小分开成两个数组，而不是合并在一个权值里，会方便一点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">30000</span>;i++) a[i] = <span class="number">1</span>, fa[i] = i;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">            fa[rx] = ry;<span class="comment">///x根的父更新为y根</span></span><br><span class="line">            <span class="type">int</span> t = a[ry];<span class="comment">///y权 = 原x权+原y权，x权 = 原y权</span></span><br><span class="line">            a[ry] += a[rx];</span><br><span class="line">            a[rx] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; (<span class="built_in">find</span>(x) == x ? <span class="number">0</span> : a[x]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">///距离在查之前要更新的，因为不知道这条路径是否查询过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1988&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>CF1132D Stressful Training</title>
    <link href="https://blankyang233.github.io/2022/07/10/CF1132D%20Stressful%20Training/"/>
    <id>https://blankyang233.github.io/2022/07/10/CF1132D%20Stressful%20Training/</id>
    <published>2022-07-10T07:26:54.000Z</published>
    <updated>2022-07-10T07:27:36.489Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1132/D">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：贪心，优先队列，二分。</strong></p><p>显然，这道题可以用二分答案做。<code>check</code> 函数可以用小根堆，让维持时间最小的先充电。</p><p>但是不优化这道题会炸。有两个关键优化：一个是快读快写能省不少时间，还有一个是把维持天数当一个变量存起来以免重复运算浪费时间。其他一些小优化：用 <code>pop</code> 把元素弹出代替析构函数自己初始化能省一点时间，只让天数小于 $k$ 的电脑入队，每次充完电检测维持天数小于 $k$ 的才重新入队。优化前是超 $3$ 秒限制的，优化后是 $1.5$ 秒还算可以。</p><p>时间复杂度 $O((n+k)\log n)$ ，常数应该在 $(100,1000)$ </p><p>空间复杂度 $O(n)$ </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：贪心，二分。</strong></p><p>方法一的检验并非正解，其实有一个更妙的方法去验证电脑是否会在 $k$ 天之前关机。</p><p>我们用一个数组 $cnt[i]$ 表示有多少电脑最晚第 $i$ 天前要充一次电。比如一台电脑是初始电量是 $20$ 每天耗电 $15$ 要维持到 $8$ 天，每次充电 $40$ ，那么它最晚在第 $2$ 、$5$、$7$ 天要充一次电，于是 $cnt[{2,5,7}]$ 都要加一。</p><p>我们不关心电脑在哪天充电，我们只关心电脑最晚要在什么时候前充电，所以 $cnt[i]$ 在某些天超过 $1$ 是可行的。因为既然我们知道在这天之后有三台电脑会关机，只要在这天之前什么时候充电都行，不过要满足之前有空闲的天数。</p><p>于是，现在我们把它从 $1$ 到 $i$ 累和，得到一个结果 $sum$ ，表示到 $i$ 天要至少要充几次电，显然每天只能充一次，那么如果 $sum &gt; i$ ，则存在电脑没在最晚时间前充上电，关机了，是这个答案是不可行的。如果 $sum \leq i$ ，说明到第 $i$ 天充电次数完全够用，可以继续。</p><p>时间复杂度 $O(n+k)$ ，常数在 $(50,200)$</p><p>空间复杂度 $O(n+k)$  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;<span class="comment">///关键优化，快读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll a, b, v;<span class="comment">///关键优化，存储天数</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;<span class="comment">///大根堆重载小于，小根堆重载大于,true代表优先级小,必须是常函数或者友元函数</span></span><br><span class="line">        <span class="keyword">return</span> v &gt; x.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">200007</span>];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct cmp &#123;</span></span><br><span class="line"><span class="comment">//     bool operator()(const node &amp;a, const node &amp;b) &#123;</span></span><br><span class="line"><span class="comment">//         return a.a / a.b &gt; b.a / b.b;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;  ///也可以写个比较类</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; pq;</span><br><span class="line"><span class="comment">//priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; pq;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) pq.<span class="built_in">pop</span>();<span class="comment">///优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="keyword">if</span> (a[i].v &lt; k)pq.<span class="built_in">push</span>(a[i]); <span class="comment">///优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        node x = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (x.v &lt; i) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">///加之前判断是否能撑到这个时候</span></span><br><span class="line">        x.a += mid;</span><br><span class="line">        x.v = x.a / x.b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x.v &lt; k) pq.<span class="built_in">push</span>(x);<span class="comment">///优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) a[i].a = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) a[i].b = <span class="built_in">read</span>(), a[i].v = a[i].a / a[i].b + <span class="number">1</span>;<span class="comment">///因为一天结束才扣电，而到了这天就算，所以取下整能过几天，加一是往后一天也算到了。</span></span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">2e12</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (l &gt; <span class="number">2e12</span> ? <span class="number">-1</span> : l) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">ll a[<span class="number">200007</span>], b[<span class="number">200007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        ll tmp = a[i];</span><br><span class="line">        <span class="keyword">while</span> (tmp / b[i] + <span class="number">1</span> &lt; k &amp;&amp; r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum[tmp / b[i] + <span class="number">1</span>]++;</span><br><span class="line">            tmp += mid;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; k;i++) &#123;</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt; i) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">///充电次数超过天数，不可能实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; b[i];</span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">2e12</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (l &gt; <span class="number">2e12</span> ? <span class="number">-1</span> : l) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1132/D&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="二分" scheme="https://blankyang233.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>NC16417 [NOIP2017]奶酪</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC16417%20[NOIP2017]%E5%A5%B6%E9%85%AA/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC16417%20[NOIP2017]%E5%A5%B6%E9%85%AA/</id>
    <published>2022-07-09T18:21:02.000Z</published>
    <updated>2022-07-15T14:53:41.632Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16417">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>现有一块大奶酪，它的高度为 h，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多<strong>半径相同</strong>的球形空洞。我们可以在这块奶酪中建立空间坐标系， 在坐标系中，奶酪的下表面为 z &#x3D; 0，奶酪的上表面为 z &#x3D; h。<br> 现在， 奶酪的下表面有一只小老鼠 Jerry， 它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交， Jerry 则可以从奶酪下表面跑进空洞； 如果一个空洞与上表面相切或是相交， Jerry 则可以从空洞跑到奶酪上表面。<br> 位于奶酪下表面的 Jerry 想知道， 在<strong>不破坏奶酪</strong>的情况下，能否利用已有的空洞跑到奶酪的上表面去?<br> 空间内两点 P1(x1,y1,z1) 、P2(x2,y2,z2) 的距离公式如下：<br> $dist(P_1,P_2)&#x3D;\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$</p><p><strong>输入描述</strong></p><p>每个输入文件包含多组数据。<br>输入文件的第一行，包含一个正整数 T，代表该输入文件中所含的数据组数。<br>接下来是 T 组数据，每组数据的格式如下：<br>第一行包含三个正整数 n， h 和 r， 两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。<br>接下来的 n 行，每行包含三个整数 x, y, z， 两个数之间以一个空格分开， 表示空洞球心坐标为 (x,y,z)。</p><p><strong>输出描述</strong></p><p>输出文件包含 T 行，分别对应 T 组数据的答案，如果在第 i 组数据中， Jerry 能从下表面跑到上表面，则输出“Yes”，如果不能，则输出“No”（均不包含引号）。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 4 1</span><br><span class="line">0 0 1</span><br><span class="line">0 0 3</span><br><span class="line">2 5 1</span><br><span class="line">0 0 1</span><br><span class="line">0 0 4</span><br><span class="line">2 5 2</span><br><span class="line">0 0 2</span><br><span class="line">2 0 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20180531/304952_1527734385285_E90A87D6E2F9E148285DFB89F9CFF06F" alt="img"></p><p><strong>备注</strong></p><p>对于 20%的数据， n &#x3D; 1， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 40%的数据， 1 ≤ n ≤ 8， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 80%的数据，1 ≤ n ≤ 1,000， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 100%的数据， 1 ≤ n ≤ 1,000， 1 ≤ h , r ≤ 1,000,000,000， T ≤ 20，坐标的绝对值不超过 1,000,000,000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：计算几何，并查集。</strong></p><p>这道题可以用带权并查集维护空球体之间的连通性，以及集合的 $z$ 坐标上下限。每次读入一个球心坐标，其自身作为一个集合的 $z$ 上限是 半径加球心 $z$ 坐标，下限就是球心 $z$ 坐标减去半径。随后暴力搜索所有已有球体是否与其连通，球心距离小于等于两倍半径即相交或者相切，则合并集合，并且更新集合权值。</p><p>注意的是多组输入数据不能中途跳出，会导致不完全输入影响下一次输入。</p><p>还要注意浮点数精度问题，一般能用整数运算尽量用整数，这里要注意超长整型的问题，在计算球心距离时先判断 $x$ 和 $y$ 平面距离，再判断空间距离。不过，这道题数据没有卡浮点。</p><p>时间复杂度 $O(n^2 \log n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：DFS，计算几何。</strong></p><p>先保存每个球的坐标，然后对每个与下表面连接的球遍历连通块，如果块中某个与上表面连接就说明连通上下了，否则返回 <code>false</code> 。</p><p>时间复杂度 $O(n^2)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">1007</span>];</span><br><span class="line"><span class="type">double</span> hmn[<span class="number">1007</span>], hmx[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">&#125;p[<span class="number">1007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));</span><br><span class="line">&#125;<span class="comment">///double有可能有精度问题，能用整数就用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> h, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; h &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i, cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].z;<span class="comment">///多组数据一定要保证输入完，不然后面数据会到下一组然后炸掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        hmn[i] = p[i].z - r;</span><br><span class="line">        hmx[i] = p[i].z + r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dist</span>(p[i], p[j]) &lt;= <span class="number">2</span> * r) &#123;</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">find</span>(i);</span><br><span class="line">                <span class="type">int</span> b = <span class="built_in">find</span>(j);</span><br><span class="line">                fa[a] = b;</span><br><span class="line">                hmx[b] = <span class="built_in">max</span>(hmx[b], hmx[a]);</span><br><span class="line">                hmn[b] = <span class="built_in">min</span>(hmn[b], hmn[a]);</span><br><span class="line">                <span class="keyword">if</span> (hmx[b] &gt;= h &amp;&amp; hmn[b] &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">///不能跳出，也许有很多集合相连</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> h, r;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">&#125;a[<span class="number">1007</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Point A, Point B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) + (A.z - B.z) * (A.z - B.z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[x].z + r &gt;= h) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] || <span class="built_in">dist</span>(a[x], a[i]) &gt; <span class="number">2</span> * r) <span class="keyword">continue</span>; <span class="comment">///访问过的 或者 距离不够的 不搜索</span></span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; h &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] || a[i].z - r &gt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">///访问过的 或者 不能联通底层的 不做为起点</span></span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16417&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
    <category term="计算几何" scheme="https://blankyang233.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>NC14685 加边的无向图</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC14685%20%E5%8A%A0%E8%BE%B9%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC14685%20%E5%8A%A0%E8%BE%B9%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE/</id>
    <published>2022-07-09T17:30:48.000Z</published>
    <updated>2022-07-10T15:54:23.379Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14685">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  给你一个 n 个点，m 条边的无向图，求至少要在这个的基础上加多少条无向边使得任意两个点可达~  </p><p><strong>输入描述</strong></p><p>第一行两个正整数 n 和 m 。<br>接下来的m行中，每行两个正整数 i 、 j ，表示点i与点j之间有一条无向道路。</p><p><strong>输出描述</strong></p><p>输出一个整数，表示答案</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>对于100%的数据，有n,m&lt;&#x3D;100000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>用并查集维护点和点之间是否连通，在一个集合就是连通的。只要求出集合数量，那么减一就是要连的边。</p><p>时间复杂度 $O(m\log n + n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">merge</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) ans++;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14685&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC14545 经商</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC14545%20%E7%BB%8F%E5%95%86/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC14545%20%E7%BB%8F%E5%95%86/</id>
    <published>2022-07-09T17:09:25.000Z</published>
    <updated>2022-07-09T17:10:33.716Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14348">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>小d是一个搞房地产的土豪。每个人经商都有每个人经商的手段，当然人际关系是需要放在首位的。<br> 小d每一个月都需要列出来一个人际关系表，表示他们搞房地产的人的一个人际关系网，但是他的精力有限，对应他只能和能够接触到的人交际。比如1认识2,2认识3，那么1就可以接触3进行交际，当然1和2也可以交际。<br> 小d还很精明，他知道他和谁交际的深获得的利益大，接下来他根据自己的想法又列出来一个利益表，表示他和这些人交际需要耗用多少精力，能够获得的利益值为多少。<br> 小d想知道，他在精力范围内，能够获得的利益值到底是多少。<br> 设定小d自己的编号为1.并且对应一个人的交际次数限定为1.</p><p><strong>输入描述</strong></p><p>本题包含多组输入，第一行输入一个数t，表示测试数据的组数<br>每组数据的第一行输入三个数，N,M，C，表示这个人际关系网一共有多少个人，关系网的关系数，以及小d的精力值<br>接下来N-1行，每行两个数ai，bi。这里第i行表示和编号为i+1的人认识需要花费ai的精力，能够获得的利益值为bi。<br>再接下来M行，每行两个数x，y，表示编号为x的人能够和编号为y的人接触<br>t&lt;&#x3D;50<br>2&lt;&#x3D;N&lt;&#x3D;10000<br>1&lt;&#x3D;M&lt;&#x3D;10*N<br>1&lt;&#x3D;ai，bi&lt;&#x3D;10<br>1&lt;&#x3D;C&lt;&#x3D;500<br>1&lt;&#x3D;x,y&lt;&#x3D;N</p><p><strong>输出描述</strong></p><p>输出包含一行，表示小d能够获得的最大利益值</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 3 7</span><br><span class="line">5 10</span><br><span class="line">3 2</span><br><span class="line">4 3</span><br><span class="line">1 100</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>小明能够接触到的人的编号有：2 3 4，那么对应接触编号为2的人花费5精力能够获得10的利益值是最优方案。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：背包dp，并查集。</strong></p><p>用并查集维护关系集合，最后遍历所有元素，与 $1$ 同根的就是小d能接触到的人。接下来是背包dp，只要考虑与 $1$ 有关系的即可。</p><p>时间复杂度 $O(m \log n + cn)$</p><p>空间复杂度 $O(n+c)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10007</span>], b[<span class="number">10007</span>], fa[<span class="number">10007</span>], dp[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">    fa[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++) cin &gt;&gt; a[i] &gt;&gt; b[i], fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///后悔贪心不能用于背包问题</span></span><br><span class="line">    <span class="comment">///因为后悔贪心变量是限制和花费或收益，花费和收益中有一个是每个点相同的，后悔另一个</span></span><br><span class="line">    <span class="comment">///而背包问题限制固定，变量是花费和收益</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == <span class="built_in">find</span>(<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = c;j &gt;= a[i];j--)</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + b[i]);</span><br><span class="line">    cout &lt;&lt; dp[c] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14348&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="背包dp" scheme="https://blankyang233.github.io/tags/%E8%83%8C%E5%8C%85dp/"/>
    
  </entry>
  
</feed>
