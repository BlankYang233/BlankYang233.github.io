<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空白のBlog</title>
  
  <subtitle>For the future</subtitle>
  <link href="https://blankyang233.github.io/atom.xml" rel="self"/>
  
  <link href="https://blankyang233.github.io/"/>
  <updated>2022-07-10T14:06:26.231Z</updated>
  <id>https://blankyang233.github.io/</id>
  
  <author>
    <name>空白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NC235745 拆路</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC235745%20%E6%8B%86%E8%B7%AF/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC235745%20%E6%8B%86%E8%B7%AF/</id>
    <published>2022-07-10T14:05:46.000Z</published>
    <updated>2022-07-10T14:06:26.231Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/235745">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  有 $n$ 个城镇，城镇之间有 $m$ 条道路相连，道路可以看成无向边。每一个城镇都有自己的一个繁荣度 $v_i$ ，一个城镇 $u$ 受到的影响 $p$ 是与$u$ 直接或者间接相连的所有城镇中，繁荣度的最大值。一个城镇 $u$ 与城镇 $v$ 是被视为直接或者间接相连的，当且仅当 $u&#x3D;v$ 或者从 $u$ 出发，可以沿着某些道路到达 $v$ 。为了减少维护成本，现准备拆除其中的某一些路。具体来说，你需要维护以下两种操作：  </p><ol><li>​    ‘Q’ $a$，询问 $a$ 城镇受到的影响 $p$ ；    </li><li>​    ‘D’ $a\ b$ ，删除 $a\ b$ 之间的道路。</li></ol><p><strong>输入描述</strong></p><p>第一行输入两个整数 $n,m(1\le n,m \le 10^5)$ ，分别表示城镇的数量和道路的数量。第二行输入 $n$ 个整数 $v_1,v_2,…,v_n(1\le v_i \le 10^9)$ ，分别表示每一个城镇的繁荣度。接下来 $m$ 行，每行两个整数 $u,v(1\le u,v \le n)$ ，表示城镇 $u,v$ 之间有一条道路连接。保证不含有重边、自环。<br>接下来一行，输入一个整数 $Q(1\le Q \le 10^5)$ ，表示操作的个数。<br>接下来 $Q$ 行，每行描述一个操作，以’Q’  $a(1\le a \le n)$ 或者’D’ $a\ b(1\le a,b \le n)$ 的形式给出。对于删除操作，保证被删除的道路是存在的。</p><p><strong>输出描述</strong></p><p>对于每一个操作1，你都需要输出一个整数 $p$ ，表示城镇 $a$ 受到的影响。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4</span><br><span class="line">Q 1</span><br><span class="line">D 2 3</span><br><span class="line">Q 1</span><br><span class="line">Q 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集，离线。</strong></p><p>普通并查集不支持撤销操作，这使得这道题难以解答，但转换一下思路，撤销的逆过程是新增，是并查集适用的操作，于是可以保存所有访问数据，离线逆向处理，再将答案保存最后输出即可。</p><p>时间复杂度 $O((m \log n + q)\log q)$</p><p>空间复杂度 $O(q+n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> u[<span class="number">100007</span>], v[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> du[<span class="number">100007</span>], dv[<span class="number">100007</span>];</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; s;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (w[rx] &lt; w[ry]) fa[rx] = ry;</span><br><span class="line">    <span class="keyword">else</span> fa[ry] = rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cin &gt;&gt; u[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;Q&#x27;</span>) cin &gt;&gt; du[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; du[i] &gt;&gt; dv[i];</span><br><span class="line">            s.<span class="built_in">insert</span>(&#123; du[i],dv[i] &#125;);</span><br><span class="line">            s.<span class="built_in">insert</span>(&#123; dv[i],du[i] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(&#123; u[i],v[i] &#125;) == s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">merge</span>(u[i], v[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = q;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dv[i]) <span class="built_in">merge</span>(du[i], dv[i]);</span><br><span class="line">        <span class="keyword">else</span> ans[i] = w[<span class="built_in">find</span>(du[i])];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/235745&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="离线" scheme="https://blankyang233.github.io/tags/%E7%A6%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>NC51097 Parity game</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC51097%20Parity%20game/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC51097%20Parity%20game/</id>
    <published>2022-07-10T13:45:16.000Z</published>
    <updated>2022-07-10T13:45:58.616Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/51097">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Now and then you play the following game with your friend. Your friend writes down a sequence consisting of zeroes and ones. You choose a continuous subsequence (for example the subsequence from the third to the fifth digit inclusively) and ask him, whether this subsequence contains even or odd number of ones. Your friend answers your question and you can ask him about another subsequence and so on. Your task is to guess the entire sequence of numbers.<br> You suspect some of your friend’s answers may not be correct and you want to convict him of falsehood. Thus you have decided to write a program to help you in this matter. The program will receive a series of your questions together with the answers you have received from your friend. The aim of this program is to find the first answer which is provably wrong, i.e. that there exists a sequence satisfying answers to all the previous questions, but no such sequence satisfies this answer.</p><p><strong>输入描述</strong></p><p>The first line of input contains one number, which is the length of the sequence of zeroes and ones. This length is less or equal to 1000000000. In the second line, there is one positive integer which is the number of questions asked and answers to them. The number of questions and answers is less or equal to 5000. The remaining lines specify questions and answers. Each line contains one question and the answer to this question: two integers (the position of the first and last digit in the chosen subsequence) and one word which is either <code>even</code> or <code>odd</code> (the answer, i.e. the parity of the number of ones in the chosen subsequence, where <code>even</code> means an even number of ones and <code>odd</code> means an odd number).</p><p><strong>输出描述</strong></p><p>There is only one line in output containing one integer X. Number X says that there exists a sequence of zeroes and ones satisfying first X parity conditions, but there exists none satisfying X+1 conditions. If there exists a sequence of zeroes and ones satisfying all the given conditions, then number X should be the number of all the questions asked.</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5</span><br><span class="line">1 2 even</span><br><span class="line">3 4 odd</span><br><span class="line">5 6 even</span><br><span class="line">1 6 even</span><br><span class="line">7 10 odd</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>每次条件给出了一个区间 $[l,r]$ 的 $01$ 串中 $1$ 的个数是奇数还是偶数，区间很难处理，但我们可以转化为 $sum[r]-sum[l-1]$ ，即 $sum[i]$ 表示 $[1,i]$ 之间 $1$ 的个数。若 $[l,r]$ 是偶数，则 $sum[r]$ 和 $sum[l-1]$ 一定是同奇偶；否则就是异奇偶。</p><p>如此就转换成端点的种类的相对关系了，而且题目只需要我们检查条件矛盾个数，那就自然而然使用扩展域并查集。</p><p>时间复杂度 $O(q \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; fa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    n++;<span class="comment">///范围从0开始到n</span></span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>;cnt &lt; q;cnt++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (!fa.<span class="built_in">count</span>(x - <span class="number">1</span>)) fa[x - <span class="number">1</span>] = x - <span class="number">1</span>, fa[x - <span class="number">1</span> + n] = x - <span class="number">1</span> + n;</span><br><span class="line">        <span class="keyword">if</span> (!fa.<span class="built_in">count</span>(y)) fa[y] = y, fa[y + n] = y + n;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;even&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x - <span class="number">1</span>) == <span class="built_in">find</span>(y + n)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span>, y);</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span> + n, y + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;odd&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x - <span class="number">1</span>) == <span class="built_in">find</span>(y)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span>, y + n);</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span> + n, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/51097&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC16884 [NOI2001]食物链</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC16884%20[NOI2001]%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC16884%20[NOI2001]%E9%A3%9F%E7%89%A9%E9%93%BE/</id>
    <published>2022-07-10T13:31:16.000Z</published>
    <updated>2022-07-10T13:31:54.970Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16884">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。 </p><p>  现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 </p><p>  有人用两种说法对这N个动物所构成的食物链关系进行描述： </p><p>  第一种说法是“1 X Y”，表示X和Y是同类。 </p><p>  第二种说法是“2 X Y”，表示X吃Y。 </p><p>  此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 </p><p>  1） 当前的话与前面的某些真的话冲突，就是假话； </p><p>  2） 当前的话中X或Y比N大，就是假话； </p><p>  3） 当前的话表示X吃X，就是假话。 </p><p>  你的任务是根据给定的N（1≤N≤50,000）和K句话（0≤K≤100,000），输出假话的总数。 </p><p><strong>输入描述</strong></p><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D&#x3D;1，则表示X和Y是同类。<br>若D&#x3D;2，则表示X吃Y。</p><p><strong>输出描述</strong></p><p>只有一个整数，表示假话的数目。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1   </span><br><span class="line">2 1 2     </span><br><span class="line">2 2 3     </span><br><span class="line">2 3 3     </span><br><span class="line">1 1 3     </span><br><span class="line">2 3 1     </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p> <img src="https://uploadfiles.nowcoder.com/images/20180701/305473_1530452990874_8C754812CCEC7267CC44FF197D74283A" alt="img"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：并查集。</strong></p><p>用权值代表其关于根节点的种类，根节点设为 $0$ ，其他的同类为 $0$ ，根节点是猎物为 $1$ ，根节点是天敌为 $2$ 。</p><p>因为种类形成环状具有传递性关系，因此路径压缩可以利用自身权值加父节点路径压缩后的权值对 $3$ 取模即可，递归实现。</p><p>合并集合时，已知两个节点 $a$ 和 $b$ 路径压缩后的权值以及$a$ 关于 $b$ 的权值，要求出集合根节点 $A$ 认 $B$ 为父后的权值，因为具有环状传递性，所以可以利用向量的思想，$\vec{AB} &#x3D; -\vec{aA}+\vec{ab}+\vec{bB}$ ，随后对 $|\vec{AB}|$ 模 $3$ 即可，注意不要出现负数。</p><p>如果给出的关系的两个对象已经在同一个关系集合，那么检查他们关系是否和给出的条件吻合，即 $\vec{ab} &#x3D;&#x3D; \vec{aA} - \vec{bA}$ ，左边是条件右边是已有的关系，不吻合的答案加一。</p><p>时间复杂度 $O(k\log n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：并查集。</strong></p><p>实际上第一种解法较为繁琐，我们只关心条件之间是否矛盾，即给出的条件的两个对象已经建立了关系，检测已有关系和给出的关系是否矛盾。因此可以用扩展域并查集，其把元素的所有可能种类扩展各个独立元素，只对有具体种类的元素建立关系集合中的具体等价类（等价类的元素会同时出现），而不把相关的具体等价类并在一个集合产生完整的关系集合，利用权值进行相对分类（带权并查集是记录了一整个关系集合，并用权值做了相对根节点的关系划分），而这对于检测矛盾已经足够了。</p><p>具体地说，一个动物元素只有三种种类，我们记为 $A$，$B$，$C$，其中 $A$ 吃 $B$ ， $B$ 吃 $C$ ， $C$ 吃 $A$ 。扩展域并查集把每个动物元素扩展成这 $3$ 个有具体种类的动物元素，分别放在 $[1,n],[n+1,2n],[2n+1，3n] $ 中。</p><p>假设给出 $a$ 吃 $b$，则会合并三个等价类 $[a]$ 与 $[b+n]$ ， $[a+n]$ 与 $[b+2n]$ ， $[a+2n]$ 与 $[b]$ ，表示 $a$ 是 $A$ 时 $b$ 一定是 $B$， $a$ 是 $B$ 时 $b$ 一定是 $C$，$a$ 是 $C$ 时 $b$ 一定是 $A$ ，这样就根据条件合并了两个对象的三组具体种类的等价类。注意一个条件一定能合并三组等价类，因为这三个等价类是一个关系集合的三个具体种类表现，同样的一个等价类出现一定有其余两个等价类，且他们种类刚好补全所有情况。比如， $[a] &#x3D; [b]$ 出现则一定有 $[a+n] &#x3D; [b+n]$ 和 $[a+2n] &#x3D; [b +2n]$，因为他们是一个同一个相对关系（同类）的三个具体表现。</p><p>另一方面，对于 $a$ 吃 $b$ 的条件，如果它们已经在一个关系集合（已有相对关系），则它们之间一定产生了三个等价类，而如果这些等价类刚好是 $[a] &#x3D; [b]$ 或者 $[a] &#x3D; [b+2n]$ ，即表达 $a$ 与 $b$ 同类或者 $a$ 的天敌是 $b$ 就很容易判断出已知条件与给出的这个条件矛盾。</p><p>因此，扩展域并查集能够维护元素不同种类之间同时出现的集合，即等价类，容易直接判断出条件是否矛盾。但弊端也很明显，只适合检验某个条件相对关系是否满足现有关系，而不能直接列举出元素的相对关系，因为扩展域并查集只保存了元素具体种类的等价关系，而没有完整记录元素在关系集合中的相对关系，导致等价类之间是割裂的，没有直接相关性的。比如我想要知道动物 $a$ 和 动物 $b$ 的相对关系，就得先拿 $a$ 的某个种类所在的等价类集合作为一个基准集合，再枚举 $b$ 的所有种类($A,B,C$)是否处在这个基准集合，如果有关系则有且仅有一个具体种类处在基准集合进而判断其相对关系，而都没有处在基准集合说明 $a$ 和 $b$ 尚未建立关系。这个过程带权并查集能在合并和查询过程中直接实现，因此如果题目要求并不是检验条件矛盾这么简单的话，比如要求得知 $a$ 和 $b$ 的相对关系用以后续解题，那带权并查集会更加合适。</p><p>时间复杂度 $O(k\log n)$</p><p>空间复杂度 $O(n)$ ，实际上是三倍空间</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">50007</span>], dist[<span class="number">50007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x) &#123;</span><br><span class="line">        <span class="type">int</span> pre = fa[x];</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(pre);</span><br><span class="line">        dist[x] = (dist[x] + dist[pre]) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="type">int</span> delta = (dist[x] - dist[y] + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span> delta == op;</span><br><span class="line">    fa[rx] = ry;</span><br><span class="line">    dist[rx] = (op - delta + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        op--;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">merge</span>(x, y, op)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">150007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span> * n;i++) fa[i] = i;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n)ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + n) || <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + <span class="number">2</span> * n)) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">merge</span>(x, y), <span class="built_in">merge</span>(x + n, y + n), <span class="built_in">merge</span>(x + <span class="number">2</span> * n, y + <span class="number">2</span> * n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + <span class="number">2</span> * n) || <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">merge</span>(x, y + n), <span class="built_in">merge</span>(x + n, y + <span class="number">2</span> * n), <span class="built_in">merge</span>(x + <span class="number">2</span> * n, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16884&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC24608 [USACO 2011 Ope S]Learning Languages</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC24608%20[USACO%202011%20Ope%20S]Learning%20Languages/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC24608%20[USACO%202011%20Ope%20S]Learning%20Languages/</id>
    <published>2022-07-10T10:34:55.000Z</published>
    <updated>2022-07-10T10:35:34.415Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/24608">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Farmer John’s N (2 &lt;&#x3D; N &lt;&#x3D; 10,000) cows, conveniently numbered 1..N, are fluent in some M (1 &lt;&#x3D; M &lt;&#x3D; 30,000) languages, also conveniently numbered from 1..M. Cow i can speak in KiK_iKi (1 &lt;&#x3D; $K_i$ &lt;&#x3D; M) languages, namely $L_{i_1}, L_{i_2},…, L_{i_{K_i}}$ (1 &lt;&#x3D; $L_{i_j}$ &lt;&#x3D; M). FJ’s cows aren’t THAT smart, so the sum of $K_i$ over all cows i is at most 100,000.<br> Two cows can’t directly talk to each other unless both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows A and B can have a conversation if and only if there exists a sequence of cows $T_1, T_2, …, T_k$​ such that A and $T_1$​ share a language, $T_1$​ and $T_2$​ share a language, etc., and $T_k$​ and B share a language.<br> Farmer John wishes that his cows could be even more social, so he wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being a fairly frugal farmer, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:<br> * The minimum number of books he must purchase<br> * Any set of books assigned to cows in any order which will help him meet this goal; a program will grade your output.</p><p>  By way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone. </p><p> #1   #2   #3<br> Alberta           x    x<br> Bessie            x<br> Contessa     x</p><p> FJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.<br> Note that an alternate solution exists: instead, FJ could buy<br> Contessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.</p><p><strong>输入描述</strong></p><ul><li>Line 1: Two space-separated integers: N and M</li><li>Lines 2..N+1: Line i+1 describes the languages that cow i can speak with Ki+1K_i+1Ki+1 space-separated integers: $K_i$, $L_{i_1}, L_{i_2},…, L_{i_{K_i}}$.</li></ul><p><strong>输出描述</strong></p><ul><li>Line 1: A single integer that is the minimum number of books that FJ must purchase.</li><li>Lines 2..B+1: Line i+1 contains two space-separated integers: the language id # and the id # of the cow to receive book i. If multiple solutions exist, print any one.</li></ul><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 </span><br><span class="line">2 3 2 </span><br><span class="line">1 2 </span><br><span class="line">1 1 </span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>本题显然用并查集，但需要做扩展域。</p><p>牛与牛之间关系不是简单联系的，而是通过语言种类作为桥梁。因此将语言种类集合并入牛集合作为合并的桥梁集合，只要牛通过语言桥梁集合与另一只牛连通，即能够交流。</p><p>具体上，在牛的集合 $[1,n]$ 后加入语言集合 $[n+1,m]$ 即可，每次合并务必用牛作为根节点，是为了防止有些语言所有牛不会单独成为集合，干扰有效集合计数。只要把牛作为根节点，就只需要在 $[1,n]$ 计数，不会产生桥梁集合单独存在的问题。</p><p>最后牛区间中不同集合的数量减一，就是要连接的(牛-&gt;语言)边的数量。</p><p>时间复杂度 $O(nk\log (n+k))$</p><p>空间复杂度 $P(n+k)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">40007</span>];<span class="comment">///牛与书的扩展集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n + m;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="type">int</span> l;</span><br><span class="line">            cin &gt;&gt; l;</span><br><span class="line">            <span class="built_in">merge</span>(i, l + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;<span class="comment">///语言可能多出来</span></span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/24608&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC15976 小C的周末</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC15976%20%E5%B0%8FC%E7%9A%84%E5%91%A8%E6%9C%AB/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC15976%20%E5%B0%8FC%E7%9A%84%E5%91%A8%E6%9C%AB/</id>
    <published>2022-07-10T08:23:48.000Z</published>
    <updated>2022-07-10T08:24:14.514Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15976">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>愉快的周末到了，小C和他的N-1个朋友买了M个游戏，游戏编号从1~M。每个游戏都是多人游戏，他们打算周末一起打游戏。</p><p> 小C的每个朋友都决定好了要玩哪一款游戏（会有一组人打同一款游戏），并且每人手上都有一台游戏机，这种游戏机可以通过特定的游戏机连接线连接起来。</p><p> 但是，他们面临着一个问题：目前没有一个朋友的游戏机是互相连接的。所以它们必须用可用的游戏机连接线连接起来。小C决定依次使用第 i 条连接线把他的朋友 ui 和 vi 的游戏机连接起来。也就是说，假设有Q条连接线，小C只能先使用第一条，然后使用第二条，然后使用第三条。。。最后使用第Q条。</p><p> 一个游戏能开始的条件是所有玩这个游戏的朋友的游戏机都被连接起来（如果不是直接连接的话，那么就必须存在一条连接它们的路径）。他们希望尽快开始比赛。</p><p> 在每个游戏中，找出在添加了第几条连接线之后能开始游戏。如果在一个游戏中只有一个人玩，则输出0（因为他立马可以开始游戏）。如果不存在，则输出-1</p><p><strong>输入描述</strong></p><p>多组输入</p><p>第一行包含三个整数N，M，Q。</p><p>第二行给N个用空格分隔的整数，第 i 个整数代表第 i 个朋友想玩的游戏。</p><p>接下来的Q行，每行两个整数(u, v)，代表电线 i 连接的两个人的电脑</p><p>1 &lt;&#x3D; N, M &lt;&#x3D; 10^5<br>0 &lt;&#x3D; Q &lt;&#x3D; 10^5</p><p><strong>输出描述</strong></p><p>对于每个游戏，输出一个整数，表示添加了第几条连接线之后能开始游戏，每行以换行符结束</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 2 4</span><br><span class="line">1 2 2 2 1</span><br><span class="line">1 2 </span><br><span class="line">2 3</span><br><span class="line">1 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>第一个游戏有两个人参加（1，5），在添加了第三条电线之后他们电脑互相连接</p><p>第二个游戏三个人参加（2， 3， 4），在添加第四条电线之后他们电脑互相连接</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>这道题用单纯的并查集维护互联关系是不够的，需要权值去表达哪些有些连了那些人。由于每个人只可能玩一个游戏，那么只要计数相等那么就说明人齐了。</p><p>所以先用 $cnt[i]$ 记录第 $i$ 个游戏有多少人。权值用 $map$ 数组维护，$map[i]$ 代表第 $i$ 个人作为根节点时，其集合里游戏以及对应的人数。</p><p>合并时遍历被合并的权值 $map$ 加入父集合的权值 $map$ ，过程中用 $ans[i]$ 记录第 $i$ 个游戏在第几根线连接时能够开始游戏，因为要按游戏编号输出所以用游戏编号作为下标记下来。</p><p>最后按顺序输出 $ans$ 即可。</p><p>要注意有些游戏可能只有一个人，那么在输出时先判断是不是一个人，再输出 $0$ 即可；也有可能有些游戏没人玩，直接输出 $-1$ 。$ans$ 初始化为 $-1$ 因为某些游戏可能能玩的人到最后还不够所以没更改 $ans$ 就可以直接输出 $-1$。</p><p>注意是多组数据输入。</p><p>时间复杂度 $O(q\log n + (n+m)\log m)$</p><p>空间复杂度 $O(n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>], cnt[<span class="number">100007</span>], ans[<span class="number">100007</span>];<span class="comment">///fa表示连接起来的人，cnt记录每个游戏人数，ans记录答案因为最后按游戏排序</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp[<span class="number">100007</span>];<span class="comment">///mp[i][j] 第i个根节点的游戏种类及其对应数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i, mp[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            cin &gt;&gt; tmp;</span><br><span class="line">            cnt[tmp]++;</span><br><span class="line">            mp[i][tmp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>;t &lt;= q;t++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            u = <span class="built_in">find</span>(u);</span><br><span class="line">            v = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (mp[u].<span class="built_in">size</span>() &gt; mp[v].<span class="built_in">size</span>()) <span class="built_in">swap</span>(u, v);</span><br><span class="line">            fa[u] = v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp[u]) &#123;</span><br><span class="line">                mp[v][i] += j;</span><br><span class="line">                <span class="keyword">if</span> (mp[v][i] == cnt[i]) ans[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &lt;= <span class="number">1</span>) cout &lt;&lt; cnt[i] - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15976&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ1988 Cube Stacking</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1988%20Cube%20Stacking/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1988%20Cube%20Stacking/</id>
    <published>2022-07-10T08:05:22.000Z</published>
    <updated>2022-07-10T08:05:55.492Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1988">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>Farmer John and Betsy are playing a game with N (1 &lt;&#x3D; N &lt;&#x3D; 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;&#x3D; P &lt;&#x3D; 100,000) operation. There are two types of operations:<br>moves and counts.<br>* In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.<br>* In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.</p><p>Write a program that can verify the results of the game.</p><p>Input</p><p>* Line 1: A single integer, P</p><p>* Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.</p><p>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.</p><p>Output</p><p>Print the output from each of the count operations in the same order as the input file.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">M 1 6</span><br><span class="line">C 1</span><br><span class="line">M 2 4</span><br><span class="line">M 2 6</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=USACO+2004+U+S+Open">USACO 2004 U S Open</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>一道典型的带权并查集题。我们用栈底方块作为根节点，权值代表到栈底（根节点）有多少个方块。但还有个问题，两个栈合并时我们并不知道合并到底部的栈有多少个方块，该给被合并的栈的根节点多少权值，于是我们可以用另一个权值数组，或者直接用原来的根节点权值代表这个栈有多少方块，这样合并时候就能直到给根节点赋值多少了。</p><p>带权并查集的路径压缩和合并操作都能用向量理解。</p><p>首先是路径压缩，已知 $A$ 到父节点 $B$ 的权值，即 $A$ 下面到 $B$ 有多少方块，以及 $B$  到根节点的权值，那么 $A$ 到根节点的权值就是 $A$ 到父节点 $B$ 的权值加上 $B$  到根节点的权值，即 $\vec{AB} + \vec{BR} &#x3D; \vec{AR}$。这样递归实现即可，先解决 $B$ 到根节点的权值问题，再解决 $A$ 到根节点的权值问题。</p><p>其次是合并操作，我们要把栈 $A$ 放在栈 $B$ 之上，那么 $B$ 权就为 $A$ 方块数加上 $B$ 的方块数，$A$ 权就为 $B$ 的方块数，即 $\vec{AB} &#x3D; |B|$ ，$|B| &#x3D; |A|+|B|$ 。这里因为根节点的权值与其他节点意义不同，没有体现向量解释的妙qwq。</p><p>时间复杂度 $O(P\log N)$</p><p>空间复杂度 $O(N)$   </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">30007</span>], a[<span class="number">30007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x; <span class="comment">///返回根节点</span></span><br><span class="line">    <span class="type">int</span> pre = fa[x];<span class="comment">///保存原父节点</span></span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);<span class="comment">///更新原父节点到根节点的距离，更新父节点为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (pre != fa[pre]) a[x] += a[pre];<span class="comment">///原父节点不是根节点，则距离为原父节点到根节点距离加自身到原父节点距离</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];<span class="comment">///返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///根节点栈底元素，权值表示整个栈元素个数</span></span><br><span class="line"><span class="comment">///其他节点表示非栈底元素，权值表示到父节点的距离</span></span><br><span class="line"><span class="comment">///当然也可以把距离和栈大小分开成两个数组，而不是合并在一个权值里，会方便一点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">30000</span>;i++) a[i] = <span class="number">1</span>, fa[i] = i;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">            fa[rx] = ry;<span class="comment">///x根的父更新为y根</span></span><br><span class="line">            <span class="type">int</span> t = a[ry];<span class="comment">///y权 = 原x权+原y权，x权 = 原y权</span></span><br><span class="line">            a[ry] += a[rx];</span><br><span class="line">            a[rx] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; (<span class="built_in">find</span>(x) == x ? <span class="number">0</span> : a[x]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">///距离在查之前要更新的，因为不知道这条路径是否查询过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1988&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>CF1132D Stressful Training</title>
    <link href="https://blankyang233.github.io/2022/07/10/CF1132D%20Stressful%20Training/"/>
    <id>https://blankyang233.github.io/2022/07/10/CF1132D%20Stressful%20Training/</id>
    <published>2022-07-10T07:26:54.000Z</published>
    <updated>2022-07-10T07:27:36.489Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1132/D">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：贪心，优先队列，二分。</strong></p><p>显然，这道题可以用二分答案做。<code>check</code> 函数可以用小根堆，让维持时间最小的先充电。</p><p>但是不优化这道题会炸。有两个关键优化：一个是快读快写能省不少时间，还有一个是把维持天数当一个变量存起来以免重复运算浪费时间。其他一些小优化：用 <code>pop</code> 把元素弹出代替析构函数自己初始化能省一点时间，只让天数小于 $k$ 的电脑入队，每次充完电检测维持天数小于 $k$ 的才重新入队。优化前是超 $3$ 秒限制的，优化后是 $1.5$ 秒还算可以。</p><p>时间复杂度 $O((n+k)\log n)$ ，常数应该在 $(100,1000)$ </p><p>空间复杂度 $O(n)$ </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：贪心，二分。</strong></p><p>方法一的检验并非正解，其实有一个更妙的方法去验证电脑是否会在 $k$ 天之前关机。</p><p>我们用一个数组 $cnt[i]$ 表示有多少电脑最晚第 $i$ 天前要充一次电。比如一台电脑是初始电量是 $20$ 每天耗电 $15$ 要维持到 $8$ 天，每次充电 $40$ ，那么它最晚在第 $2$ 、$5$、$7$ 天要充一次电，于是 $cnt[{2,5,7}]$ 都要加一。</p><p>我们不关心电脑在哪天充电，我们只关心电脑最晚要在什么时候前充电，所以 $cnt[i]$ 在某些天超过 $1$ 是可行的。因为既然我们知道在这天之后有三台电脑会关机，只要在这天之前什么时候充电都行，不过要满足之前有空闲的天数。</p><p>于是，现在我们把它从 $1$ 到 $i$ 累和，得到一个结果 $sum$ ，表示到 $i$ 天要至少要充几次电，显然每天只能充一次，那么如果 $sum &gt; i$ ，则存在电脑没在最晚时间前充上电，关机了，是这个答案是不可行的。如果 $sum \leq i$ ，说明到第 $i$ 天充电次数完全够用，可以继续。</p><p>时间复杂度 $O(n+k)$ ，常数在 $(50,200)$</p><p>空间复杂度 $O(n+k)$  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;<span class="comment">///关键优化，快读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll a, b, v;<span class="comment">///关键优化，存储天数</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;<span class="comment">///大根堆重载小于，小根堆重载大于,true代表优先级小,必须是常函数或者友元函数</span></span><br><span class="line">        <span class="keyword">return</span> v &gt; x.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">200007</span>];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct cmp &#123;</span></span><br><span class="line"><span class="comment">//     bool operator()(const node &amp;a, const node &amp;b) &#123;</span></span><br><span class="line"><span class="comment">//         return a.a / a.b &gt; b.a / b.b;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;  ///也可以写个比较类</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; pq;</span><br><span class="line"><span class="comment">//priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; pq;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) pq.<span class="built_in">pop</span>();<span class="comment">///优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="keyword">if</span> (a[i].v &lt; k)pq.<span class="built_in">push</span>(a[i]); <span class="comment">///优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        node x = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (x.v &lt; i) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">///加之前判断是否能撑到这个时候</span></span><br><span class="line">        x.a += mid;</span><br><span class="line">        x.v = x.a / x.b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x.v &lt; k) pq.<span class="built_in">push</span>(x);<span class="comment">///优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) a[i].a = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) a[i].b = <span class="built_in">read</span>(), a[i].v = a[i].a / a[i].b + <span class="number">1</span>;<span class="comment">///因为一天结束才扣电，而到了这天就算，所以取下整能过几天，加一是往后一天也算到了。</span></span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">2e12</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (l &gt; <span class="number">2e12</span> ? <span class="number">-1</span> : l) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">ll a[<span class="number">200007</span>], b[<span class="number">200007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        ll tmp = a[i];</span><br><span class="line">        <span class="keyword">while</span> (tmp / b[i] + <span class="number">1</span> &lt; k &amp;&amp; r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum[tmp / b[i] + <span class="number">1</span>]++;</span><br><span class="line">            tmp += mid;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; k;i++) &#123;</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt; i) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">///充电次数超过天数，不可能实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; b[i];</span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">2e12</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (l &gt; <span class="number">2e12</span> ? <span class="number">-1</span> : l) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1132/D&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="二分" scheme="https://blankyang233.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>NC16417 [NOIP2017]奶酪</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC16417%20[NOIP2017]%E5%A5%B6%E9%85%AA/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC16417%20[NOIP2017]%E5%A5%B6%E9%85%AA/</id>
    <published>2022-07-09T18:21:02.000Z</published>
    <updated>2022-07-09T18:21:31.877Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16417">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>现有一块大奶酪，它的高度为 h，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多<strong>半径相同</strong>的球形空洞。我们可以在这块奶酪中建立空间坐标系， 在坐标系中，奶酪的下表面为 z &#x3D; 0，奶酪的上表面为 z &#x3D; h。<br> 现在， 奶酪的下表面有一只小老鼠 Jerry， 它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交， Jerry 则可以从奶酪下表面跑进空洞； 如果一个空洞与上表面相切或是相交， Jerry 则可以从空洞跑到奶酪上表面。<br> 位于奶酪下表面的 Jerry 想知道， 在<strong>不破坏奶酪</strong>的情况下，能否利用已有的空洞跑到奶酪的上表面去?<br> 空间内两点 P1(x1,y1,z1) 、P2(x2,y2,z2) 的距离公式如下：<br> $dist(P_1,P_2)&#x3D;\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$</p><p><strong>输入描述</strong></p><p>每个输入文件包含多组数据。<br>输入文件的第一行，包含一个正整数 T，代表该输入文件中所含的数据组数。<br>接下来是 T 组数据，每组数据的格式如下：<br>第一行包含三个正整数 n， h 和 r， 两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。<br>接下来的 n 行，每行包含三个整数 x, y, z， 两个数之间以一个空格分开， 表示空洞球心坐标为 (x,y,z)。</p><p><strong>输出描述</strong></p><p>输出文件包含 T 行，分别对应 T 组数据的答案，如果在第 i 组数据中， Jerry 能从下表面跑到上表面，则输出“Yes”，如果不能，则输出“No”（均不包含引号）。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 4 1</span><br><span class="line">0 0 1</span><br><span class="line">0 0 3</span><br><span class="line">2 5 1</span><br><span class="line">0 0 1</span><br><span class="line">0 0 4</span><br><span class="line">2 5 2</span><br><span class="line">0 0 2</span><br><span class="line">2 0 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20180531/304952_1527734385285_E90A87D6E2F9E148285DFB89F9CFF06F" alt="img"></p><p><strong>备注</strong></p><p>对于 20%的数据， n &#x3D; 1， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 40%的数据， 1 ≤ n ≤ 8， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 80%的数据，1 ≤ n ≤ 1,000， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 100%的数据， 1 ≤ n ≤ 1,000， 1 ≤ h , r ≤ 1,000,000,000， T ≤ 20，坐标的绝对值不超过 1,000,000,000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：计算几何，并查集。</strong></p><p>这道题可以用带权并查集维护空球体之间的连通性，以及集合的 $z$ 坐标上下限。每次读入一个球心坐标，其自身作为一个集合的 $z$ 上限是 半径加球心 $z$ 坐标，下限就是球心 $z$ 坐标减去半径。随后暴力搜索所有已有球体是否与其连通，球心距离小于等于两倍半径即相交或者相切，则合并集合，并且更新集合权值。</p><p>注意的是多组输入数据不能中途跳出，会导致不完全输入影响下一次输入。</p><p>还要注意浮点数精度问题，一般能用整数运算尽量用整数，这里要注意超长整型的问题，在计算球心距离时先判断 $x$ 和 $y$ 平面距离，再判断空间距离。不过，这道题数据没有卡浮点。</p><p>时间复杂度 $O(n^2 \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">1007</span>];</span><br><span class="line"><span class="type">double</span> hmn[<span class="number">1007</span>], hmx[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">&#125;p[<span class="number">1007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));</span><br><span class="line">&#125;<span class="comment">///double有可能有精度问题，能用整数就用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> h, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; h &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i, cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].z;<span class="comment">///多组数据一定要保证输入完，不然后面数据会到下一组然后炸掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        hmn[i] = p[i].z - r;</span><br><span class="line">        hmx[i] = p[i].z + r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dist</span>(p[i], p[j]) &lt;= <span class="number">2</span> * r) &#123;</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">find</span>(i);</span><br><span class="line">                <span class="type">int</span> b = <span class="built_in">find</span>(j);</span><br><span class="line">                fa[a] = b;</span><br><span class="line">                hmx[b] = <span class="built_in">max</span>(hmx[b], hmx[a]);</span><br><span class="line">                hmn[b] = <span class="built_in">min</span>(hmn[b], hmn[a]);</span><br><span class="line">                <span class="keyword">if</span> (hmx[b] &gt;= h &amp;&amp; hmn[b] &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">///不能跳出，也许有很多集合相连</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16417&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="计算几何" scheme="https://blankyang233.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>NC14685 加边的无向图</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC14685%20%E5%8A%A0%E8%BE%B9%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC14685%20%E5%8A%A0%E8%BE%B9%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE/</id>
    <published>2022-07-09T17:30:48.000Z</published>
    <updated>2022-07-09T17:31:21.808Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14685">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  给你一个 n 个点，m 条边的无向图，求至少要在这个的基础上加多少条无向边使得任意两个点可达~  </p><p><strong>输入描述</strong></p><p>第一行两个正整数 n 和 m 。<br>接下来的m行中，每行两个正整数 i 、 j ，表示点i与点j之间有一条无向道路。</p><p><strong>输出描述</strong></p><p>输出一个整数，表示答案</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>对于100%的数据，有n,m&lt;&#x3D;100000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>用并查集维护点和点之间是否连通，在一个集合就是连通的。只要求出集合数量，那么减一就是要连的边。</p><p>时间复杂度 $O(m\log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">merge</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) ans++;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14685&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC14545 经商</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC14545%20%E7%BB%8F%E5%95%86/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC14545%20%E7%BB%8F%E5%95%86/</id>
    <published>2022-07-09T17:09:25.000Z</published>
    <updated>2022-07-09T17:10:33.716Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14348">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>小d是一个搞房地产的土豪。每个人经商都有每个人经商的手段，当然人际关系是需要放在首位的。<br> 小d每一个月都需要列出来一个人际关系表，表示他们搞房地产的人的一个人际关系网，但是他的精力有限，对应他只能和能够接触到的人交际。比如1认识2,2认识3，那么1就可以接触3进行交际，当然1和2也可以交际。<br> 小d还很精明，他知道他和谁交际的深获得的利益大，接下来他根据自己的想法又列出来一个利益表，表示他和这些人交际需要耗用多少精力，能够获得的利益值为多少。<br> 小d想知道，他在精力范围内，能够获得的利益值到底是多少。<br> 设定小d自己的编号为1.并且对应一个人的交际次数限定为1.</p><p><strong>输入描述</strong></p><p>本题包含多组输入，第一行输入一个数t，表示测试数据的组数<br>每组数据的第一行输入三个数，N,M，C，表示这个人际关系网一共有多少个人，关系网的关系数，以及小d的精力值<br>接下来N-1行，每行两个数ai，bi。这里第i行表示和编号为i+1的人认识需要花费ai的精力，能够获得的利益值为bi。<br>再接下来M行，每行两个数x，y，表示编号为x的人能够和编号为y的人接触<br>t&lt;&#x3D;50<br>2&lt;&#x3D;N&lt;&#x3D;10000<br>1&lt;&#x3D;M&lt;&#x3D;10*N<br>1&lt;&#x3D;ai，bi&lt;&#x3D;10<br>1&lt;&#x3D;C&lt;&#x3D;500<br>1&lt;&#x3D;x,y&lt;&#x3D;N</p><p><strong>输出描述</strong></p><p>输出包含一行，表示小d能够获得的最大利益值</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 3 7</span><br><span class="line">5 10</span><br><span class="line">3 2</span><br><span class="line">4 3</span><br><span class="line">1 100</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>小明能够接触到的人的编号有：2 3 4，那么对应接触编号为2的人花费5精力能够获得10的利益值是最优方案。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：背包dp，并查集。</strong></p><p>用并查集维护关系集合，最后遍历所有元素，与 $1$ 同根的就是小d能接触到的人。接下来是背包dp，只要考虑与 $1$ 有关系的即可。</p><p>时间复杂度 $O(m \log n + cn)$</p><p>空间复杂度 $O(n+c)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10007</span>], b[<span class="number">10007</span>], fa[<span class="number">10007</span>], dp[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">    fa[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++) cin &gt;&gt; a[i] &gt;&gt; b[i], fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///后悔贪心不能用于背包问题</span></span><br><span class="line">    <span class="comment">///因为后悔贪心变量是限制和花费或收益，花费和收益中有一个是每个点相同的，后悔另一个</span></span><br><span class="line">    <span class="comment">///而背包问题限制固定，变量是花费和收益</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == <span class="built_in">find</span>(<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = c;j &gt;= a[i];j--)</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + b[i]);</span><br><span class="line">    cout &lt;&lt; dp[c] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14348&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="背包dp" scheme="https://blankyang233.github.io/tags/%E8%83%8C%E5%8C%85dp/"/>
    
  </entry>
  
  <entry>
    <title>NC23803 DongDong认亲戚</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC23803%20DongDong%E8%AE%A4%E4%BA%B2%E6%88%9A/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC23803%20DongDong%E8%AE%A4%E4%BA%B2%E6%88%9A/</id>
    <published>2022-07-09T14:45:45.000Z</published>
    <updated>2022-07-09T14:46:14.826Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/23803">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  DongDong每年过春节都要回到老家探亲，然而DongDong记性并不好，没法想起谁是谁的亲戚（定义:若A和B是亲戚，B和C是亲戚，那么A和C也是亲戚），她只好求助于会编程的你了。 </p><p><strong>输入描述</strong></p><p>第一行给定n,m表示有n个人，m次操作</p><p>第二行给出n个字符串，表示n个人的名字分别是什么(如果出现多个人名字相同，则视为同一个人)（保证姓名是小写字符串）</p><p>接下来m行，每行输入一个数opt,两个字符串x,y</p><p>当opt&#x3D;1时，表示x,y是亲戚</p><p>当opt&#x3D;2时，表示询问x,y是否是亲戚，若是输出1，不是输出0</p><p>数据范围:1&lt;&#x3D;n,m&lt;&#x3D;20000，名字字符长度小等于10</p><p><strong>输出描述</strong></p><p>对于每个2操作给予回答</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">chen lin yi cheng</span><br><span class="line">2 chen lin</span><br><span class="line">1 chen lin</span><br><span class="line">1 yi lin</span><br><span class="line">2 yi lin</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>并查集模板题。并查集把有关系的一类放进一个集合，用其中一个节点作为根节点代表这个集合，于是建立关系就相当于把两个集合的根节点相连合并成一个集合（因此要满足传递性），查询时就看根节点是不是同一个就知道是不是在一个集合。</p><p>并查集查询时间在路径压缩后是常数的，合并时间是对数的。启发式合并（按秩合并）查询时间是对数的，合并时间是常数的。如果并查集同时使用启发式合并和路径压缩，那么合并时间和查询时间都是近似于常数的，准确的说是 $O(\alpha(n))$ ，其中 $\alpha$ 函数在 $10^{80}$ 内不超过 $4$ ，所以可以认为是常数的。通常我们只使用路径压缩即可。</p><p>时间复杂度 $O(m \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">20007</span>];</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        mp[s] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        string x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) fa[<span class="built_in">find</span>(mp[x])] = <span class="built_in">find</span>(mp[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) cout &lt;&lt; (<span class="built_in">find</span>(mp[x]) == <span class="built_in">find</span>(mp[y])) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/23803&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC216012 Let&#39;sPlayCurling</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC216012%20Let&#39;sPlayCurling/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC216012%20Let&#39;sPlayCurling/</id>
    <published>2022-07-09T14:14:58.000Z</published>
    <updated>2022-07-09T14:15:28.376Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/216012">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Curling is a sport in which players slide stones on a sheet of ice toward a target area. The team with the nearest stone to the center of the target area wins the game.</p><p> Two teams, Red and Blue, are competing on the number axis. After the game there are $(n+m)$ stones remaining on the axis, $n$ of them for the Red team and the other $m$ of them for the Blue. The iii-th stone of the Red team is positioned at $a_i$ and the $i$-th stone of the Blue team is positioned at $b_i$.</p><p> Let $c$ be the position of the center of the target area. From the description above we know that if there exists some $i$ such that $1 \le i \le n$ and for all $1 \le j \le m$ we have$|c - a_i| &lt; |c - b_j|$ then Red wins the game. What’s more, Red is declared to win $p$ points if the number of $i$ satisfying the constraint is exactly $p$.</p><p> Given the positions of the stones for team Red and Blue, your task is to determine the position $c$ of the center of the target area so that Red wins the game and scores as much as possible. Note that $c$ can be any real number, not necessarily an integer.</p><p><strong>输入描述</strong></p><p>There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:</p><p>The first line contains two integers nnn and mmm ($1 \le n, m \le 10^5$) indicating the number of stones for Red and the number of stones for Blue.</p><p>The second line contains nnn integers $a_1, a_2, \cdots, a_n$ ($1 \le a_i \le 10^9$) indicating the positions of the stones for Red.</p><p>The third line contains mmm integers $b_1, b_2, \cdots, b_m$ ($1 \le b_i \le 10^9$) indicating the positions of the stones for Blue.</p><p>It’s guaranteed that neither the sum of nnn nor the sum of $m$ will exceed $5 \times 10^5$ .</p><p><strong>输出描述</strong></p><p>For each test case output one line. If there exists some $c$ so that Red wins and scores as much as possible, output one integer indicating the maximum possible score of Red (NOT $c$). Otherwise output “Impossible” (without quotes) instead.</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">6 5</span><br><span class="line">2 5 3 7 1 7</span><br><span class="line">3 4 3 1 10</span><br><span class="line">1 1</span><br><span class="line">7</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">Impossible</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>For the first sample test case we can assign $c &#x3D; 2.5$ so that the stones at position 2 and 3 for Red will score.</p><p>For the second sample test case we can assign $c &#x3D; 7$ so that the stones at position 5 and 7 for Red will score.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL，模拟。</strong></p><p>选择一个点作为目标，如果存在红色石头比所有蓝色石头都严格接近目标，则红方胜利。进一步，满足比所有蓝色石头都严格接近目标的红色石头的数量是红方最后得分。</p><p>显然，红色石头会连成一段区间，中间不能有蓝色石头（包括端点），目标可以选在他们中间，使得这段红色石头都包括其中，并不含蓝色石头，最终得分就是连续红色石头的个数。地图上有很多蓝色石头分割了许多红色石头的区间，所以首先用一个 $map$ 将坐标映射到红色石头数量，再将蓝色石头坐标的红色石头数量设为 $0$ ，这样就有了所有石头的坐标，不为 $0$ 的就是红色石头数量。遍历一遍，计算每个区间的红色石头个数，取其中最大值即可。</p><p>时间复杂度 $O((n+m) \log (n+m))$ </p><p>空间复杂度 $O(n+m)$  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        mp[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; m;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        mp[tmp] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j) sum += j;</span><br><span class="line">        <span class="keyword">else</span> sum = <span class="number">0</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans) cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/216012&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="模拟" scheme="https://blankyang233.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>UVALive7146 Defeat the Enemy</title>
    <link href="https://blankyang233.github.io/2022/07/09/UVALive7146%20Defeat%20the%20Enemy/"/>
    <id>https://blankyang233.github.io/2022/07/09/UVALive7146%20Defeat%20the%20Enemy/</id>
    <published>2022-07-09T10:28:00.000Z</published>
    <updated>2022-07-09T10:28:32.935Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/124063">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，STL。</strong></p><p>首先要保证我方军队能消灭对方军队才行，因此只要我们按攻击力从大到小排，对方按防御力从大到小排，从大到小遍历，用我方所有攻击力大于敌方目前防御力军队中的一个打，就能保证对方小的防御力不会先把我方大的攻击力用掉，导致对方大的防御力没有办法消灭，即能消灭就一定消灭，不能就一定不能返回 $-1$。</p><p>现在考虑保证我方被消灭最少，发现如果在我方攻击力大于对方防御力的军队里面选，一定优先选择防御力刚好大于对方攻击力的军队，这样就可以保证大的防御力能保留，小的防御力不会被消灭；但如果最大的防御力都小于等于对方攻击力，那一定选择防御力最小的军队打，因为既然都会同归于尽，那么就让大的防御力保留，把最小的防御力同归于尽，保证后面有足够的防御力。因此我们这时候需要一个容器能够排序，查询，删除，插入，可以有相同元素，那么就要选择 $multiset$ 存储我方军队防御力。</p><p>于是，每次先把大于等于的军队放入多重集，如果没有则返回 $-1$ 。然后查找一个刚好防御力大于其攻击力的军队打，否则就用防御力最小的打，然后军队存活数量减一。</p><p>时间复杂度 $O((n+m) \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> atk, def;</span><br><span class="line">&#125;a[<span class="number">100007</span>], b[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin &gt;&gt; a[i].atk &gt;&gt; a[i].def;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)cin &gt;&gt; b[i].def &gt;&gt; b[i].atk;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.atk &gt; b.atk;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(b, b + m, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.def &gt; b.def;&#125;);</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i].atk &gt;= b[j].def) ms.<span class="built_in">insert</span>(a[i++].def);</span><br><span class="line">        <span class="keyword">if</span> (ms.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">upper_bound</span>(b[j].atk);</span><br><span class="line">        <span class="keyword">if</span> (it == ms.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ms.<span class="built_in">erase</span>(ms.<span class="built_in">begin</span>());</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ms.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/124063&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>UVA11020 Efficient Solutions</title>
    <link href="https://blankyang233.github.io/2022/07/09/UVA11020%20Efficient%20Solutions/"/>
    <id>https://blankyang233.github.io/2022/07/09/UVA11020%20Efficient%20Solutions/</id>
    <published>2022-07-09T09:28:07.000Z</published>
    <updated>2022-07-09T15:18:54.740Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/116634">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL，思维。</strong></p><p>首先不考虑新加入的操作，先考虑一个固定的局面，给定了所有人的两个属性值 $L$ 和 $C$，找出有竞争力的人。</p><p>这类双变量的条件一般可以画在坐标系 $L-C$ 查看，发现如果一个点坐标到原点构成的矩形内部（包括边，但不包括这个点本身）有其他点，则这个点就没有竞争力。于是发现有竞争力人群规律，其中 $L$ 小的人相对于其他人 $C$ 会较大，而 $L$ 大的人相对于其他人 $C$ 会较小。因为对于一个 $L$ 小的人，那么后面 $L$ 大的人 $C$ 要比 $L$ 小的人的 $C$ 小，不然就没竞争力，所以整体会呈现一个反比例函数的形式。因此对已有的人按 $L$ 为第一关键字从小到大排， $C$ 为第二关键字从小到大排。</p><p>现在考虑插入一个人，先找到 <code>lower_bound</code>到 $L$ 大或 $L$ 等于但 $C$ 大于等于的第一个点，那么上一个点就是 $L$ 小于他的最后一个点，则 $C$ 要比上一个点的 $C$ 严格小，才有资格插入。</p><p>随后开始排除后面那些 $L$ 大于等于他的人，但 $C$ 大于他的人。先 <code>upper_bound</code> 找到 $L$ 大 或 $L$ 等于且 $C$ 大的第一个点，从这里往后所有 $C$ 小于等于他的  $C$ 的人全都没有竞争力了（因为 <code>upper_bound</code> ，所以如果 $L$ 相等只可能 $C$ 比他大）。</p><p>每次插入后容器大小是有竞争力的人的人数。注意到容器要满足排序，插入，删除，查找，且元素可能重复，因此用 <code>multiset</code> 。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node a, node b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    multiset&lt;node&gt; ms;<span class="comment">///画x-y图分析得出，有效点若按x从小到大，则y一定从大到小，且一个x点处，不可能有y不同的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        node a = &#123; x,y &#125;;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">lower_bound</span>(a);<span class="comment">///找到x大或x等于但y大于等于的第一个点，则上一个点一定是x小于的点</span></span><br><span class="line">        <span class="keyword">if</span> (it == ms.<span class="built_in">begin</span>() || (--it)-&gt;y &gt; y) &#123;<span class="comment">///这个点的y要比上一个点的y严格小,则有资格，开始踢后面的人</span></span><br><span class="line">            ms.<span class="built_in">insert</span>(a);</span><br><span class="line">            it = ms.<span class="built_in">upper_bound</span>(a);<span class="comment">///找到x大 或 x等于且y大的第一个点</span></span><br><span class="line">            <span class="keyword">while</span> (it != ms.<span class="built_in">end</span>() &amp;&amp; it-&gt;y &gt;= y) it = ms.<span class="built_in">erase</span>(it);<span class="comment">///往后这些点的x大于等于a的x，若y比a的y大于等于，就扔掉（x等于只有y大的情况）</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ms.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; (t ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/116634&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="思维" scheme="https://blankyang233.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>NC207569 牛牛爱奇数</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC207569%20%E7%89%9B%E7%89%9B%E7%88%B1%E5%A5%87%E6%95%B0/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC207569%20%E7%89%9B%E7%89%9B%E7%88%B1%E5%A5%87%E6%95%B0/</id>
    <published>2022-07-09T08:54:37.000Z</published>
    <updated>2022-07-09T08:55:22.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/207569">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  在牛牛面前放着 $n$ 个数，这些数字既有奇数也有偶数，只不过牛牛对奇数情有独钟，他特别想让这些数都变成奇数。 </p><p>  现在牛牛获得了一种能力，他可以执行一种操作：每次选中一个偶数，然后把这些数中与该数相等的数都除以 $2$ ，例如现在有一个数组为$[2,2,3]$ ，那么牛牛可以执行一次操作，使得这个数组变为 $[1,1,3]$ 。 </p><p>  牛牛现在想知道，对于任意的 $n$ 个数，他最少需要操作多少次，使得这些数都变成奇数？ </p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,[2,2,3]</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>只需做一次操作，会将其中的偶数 $2$ 都变成 $1$ ，满足了所有的数都是奇数的要求。</p><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,[1,3,7]</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>不需要做任何操作，因为所有的数原本就是奇数。</p><p><strong>备注</strong></p><p>$1 \leq n \leq 10^{6}$ ，代表一个有多少数字</p><p>$a_{1},a_{2},a_{3}…a_{n}(1 \leq a_{i} \leq 10^{9})$ 代表数字的大小</p><p>对于 $25%$ 的数据, $1 \leq n \leq 10^{2},1 \leq a_{i} \leq 10^{3}$</p><p>对于 $75%$ 的数据, $1 \leq n \leq 10^{4},1 \leq a_{i} \leq 10^{6}$</p><p>对于 $100%$ 的数据, $1 \leq n \leq 10^{6},1 \leq a_{i} \leq 10^{9}$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，STL，优先队列。</strong></p><p>先把偶数放进优先队列从大到小排，因为大的偶数可能变成已有的小偶数，用小偶数除一次即可，因此从大的偶数开始除。并且因为同一个数字只要除一次，所以把一个除完的数字放回队列即可，剩下的同种数字全部弹出。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (!(tmp &amp; <span class="number">1</span>)) pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() == x) pq.<span class="built_in">pop</span>();</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(x &amp; <span class="number">1</span>)) pq.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/207569&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>NC17889 新建 Microsoft Office Word 文档</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC17889%20%E6%96%B0%E5%BB%BA%20Microsoft%20Office%20Word%20%E6%96%87%E6%A1%A3/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC17889%20%E6%96%B0%E5%BB%BA%20Microsoft%20Office%20Word%20%E6%96%87%E6%A1%A3/</id>
    <published>2022-07-09T08:39:43.000Z</published>
    <updated>2022-07-09T08:40:23.505Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/17889">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>CSL正在学习《计算机办公自动化》文件的建立与删除。</p><p> CSL发现，当他新建一个word文档时，会得到一个名为”新建 Microsoft Office Word 文档.doc”的文件，再新建一个，则名为”新建 Microsoft Office Word 文档(2).doc”，再新建，便是”新建 Microsoft Office Word 文档(3).doc”。不断新建，编号不断递增。倘若他已经新建了三个文档，然后删除了”新建 Microsoft Office Word 文档(2).doc”，再新建一个就又会得到一个”新建 Microsoft Office Word 文档(2).doc”。</p><p> 严格来说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。</p><p> 现在，请你编程模拟以上过程，支持以下两种操作：</p><p> New：新建一个word文档，反馈新建的文档的编号；</p><p> Delete id：删除一个编号为id的word文档，反馈删除是否成功。</p><p> 初始时一个文件都没有，”新建 Microsoft Office Word 文档.doc”的编号算作1。</p><p><strong>输入描述</strong></p><p>第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为:Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。操作次数不超过100000，删除编号的数值不超过100000。</p><p><strong>输出描述</strong></p><p>对于输入的每一个操作，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">Delete 2</span><br><span class="line">New</span><br><span class="line">Delete 4</span><br><span class="line">Delete 3</span><br><span class="line">Delete 1</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">Delete 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Successful</span><br><span class="line">2</span><br><span class="line">Failed</span><br><span class="line">Successful</span><br><span class="line">Successful</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Successful</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL，模拟，优先队列。</strong></p><p>简单但不是完全简单的模拟。</p><p>用一个优先队列记录当前空缺编号的从小到大排列，方便新建时候找到最小的空缺编号。</p><p>用一个变量记录当前最大文件编号，方便 <code>failed</code> 的判断。</p><p>用一个布尔数组记录当前编号的空缺状态，方便 <code>failed</code> 的判断。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;New&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">empty</span>())  cout &lt;&lt; ++pos &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> vis[pq.<span class="built_in">top</span>()] = <span class="number">0</span>, cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;Delete&quot;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (vis[x] || x &gt; pos) cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                vis[x] = <span class="number">1</span>;</span><br><span class="line">                pq.<span class="built_in">push</span>(x);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Successful&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17889&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="模拟" scheme="https://blankyang233.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>NC22596 Rinne Loves Data Structure</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC22596%20Rinne%20Loves%20Data%20Structure/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC22596%20Rinne%20Loves%20Data%20Structure/</id>
    <published>2022-07-09T08:22:06.000Z</published>
    <updated>2022-07-09T08:23:40.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/22596">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  Rinne 喜欢 OI。在 9102 年的 PION 中，她在初赛遇到了这样一道题目： </p><p> 阅读下列代码，然后回答问题。<br><img src="https://uploadfiles.nowcoder.com/images/20190127/310583_1548557182210_007691A41DEBE9190B70C58D79BEA139" alt="img"></p><p>  补充：建树过程中会更新lc和rc，这实质上是一个二叉查找树的插入过程。 </p><p>  定义一个玄学节点叫做 R，每次操作读入 val ，执行 Insert(R,val)。 </p><p> 问题：每次 Insert 操作结束之后，输出当前节点的深度和。<br> 这里我们定义 R 节点的深度为 0。</p><p><strong>输入描述</strong></p><p>第一行一个整数 N，表示操作次数。</p><p>接下来 N 行，第 i 行有一个值 $val_i$，表示第 i 次操作的 $val_i$。</p><p><strong>输出描述</strong></p><p>N 行，每行输出该次操作完后的答案。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">11</span><br><span class="line">13</span><br><span class="line">15</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>$N \leq 3 \times 10^5$。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：树，STL。</strong></p><p>画图易知二叉排序树插入的节点有 $4$ 种情况：插入节点比所有节点都小，那会存放在最小节点的左孩子；插入节点比所有节点都大，那会存放在最大节点的右孩子；插入节点比某子树根小，但比其左子树根大，那会存放在左子树的右孩子；插入节点比某子树根大，但比其右子树根小，那会存放在右子树的左孩子。</p><p>因为二叉排序树不能出现相同键值的节点，用 $set$ 存储比较好，特判一下插入相同元素的情况。再用一个 $map$ 存储相应节点的深度。</p><p>随后用 $set$ 成员函数 $lower_bound$ (比STL泛用函数要快)查找第一个大于等于插入元素的节点位置，然后如果是 $begin()$ 或者 $end()$ ，则取相应的头&#x2F;尾节点的深度加一；如果是中间某个元素，则取前后两个元素的深度最大值加一。最后别忘记插入回去。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dep;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        cin &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(val);</span><br><span class="line">            dep[val] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> pos = s.<span class="built_in">lower_bound</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (*pos == val) &#123;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == s.<span class="built_in">begin</span>()) dep[val] = dep[*pos] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == s.<span class="built_in">end</span>()) pos--, dep[val] = dep[*pos] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dep[val] = dep[*pos];</span><br><span class="line">            pos--;</span><br><span class="line">            dep[val] = <span class="built_in">max</span>(dep[*pos], dep[val]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += dep[val];</span><br><span class="line">        s.<span class="built_in">insert</span>(val);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/22596&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="树" scheme="https://blankyang233.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>NC17508 指纹锁</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC17508%20%E6%8C%87%E7%BA%B9%E9%94%81/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC17508%20%E6%8C%87%E7%BA%B9%E9%94%81/</id>
    <published>2022-07-09T08:06:45.000Z</published>
    <updated>2022-07-09T08:07:26.202Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/17508">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>​    HA实验有一套非常严密的安全保障体系，在HA实验基地的大门，有一个指纹锁。 </p><p>​    该指纹锁的加密算法会把一个指纹转化为一个不超过1e7的数字，两个指纹数值之差越小，就说明两个指纹越相似，当两个指纹的数值差≤k时，这两个指纹的持有者会被系统判定为同一个人。<br>   现在有3种操作，共m个，<br> 操作1：add x，表示为指纹锁录入一个指纹，该指纹对应的数字为x，如果系统内有一个与x相差≤k的指纹，则系统会忽略这次添加操作<br> 操作2：del x，表示删除指纹锁中的指纹x，若指纹锁中多个与x相差≤k的指纹，则全部删除，若指纹锁中没有指纹x，则可以忽略该操作，<br> 操作3：query x，表示有一个持有指纹x的人试图打开指纹锁，你需要设计一个判断程序，返回该人是否可以打开指纹锁（只要x与存入的任何一个指纹相差≤k即可打开锁）。<br>   初始状态，指纹锁中没有任何指纹。</p><p><strong>输入描述</strong></p><p>第一行有2个正整数m，k。<br>接下来m行，每行描述一种操作：add x，del x或query x。</p><p><strong>输出描述</strong></p><p>对于每个query操作，输出一行，包含一个单词“Yes”或“No”，表示该人是否可以打开指纹锁。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">add 1</span><br><span class="line">add 10</span><br><span class="line">query 5</span><br><span class="line">query 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">add 1</span><br><span class="line">query 4</span><br><span class="line">del 1</span><br><span class="line">query 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">add 10</span><br><span class="line">query 10</span><br><span class="line">add 5 </span><br><span class="line">query 5</span><br><span class="line">del 7//系统将指纹10和指纹5全部删除</span><br><span class="line">query 8</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：模拟，STL。</strong></p><p>这道题运用了 $set$ 的自定义比较规则。我们把相差绝对值在 $k$ 之内的数定义为相等，即 $&lt;$ 和 $&gt;$ 都是 $false$ 因为 $&gt;$ 是用 $&lt;$ 实现的，我们只要重载 $&lt;$ 并把这一情况直接 <code>return false</code> 即可被判定为等于。随后只要按操作模拟。</p><p>时间复杂度 $O(m \log m)$</p><p>空间复杂度 $O(m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(a - b) &lt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;<span class="comment">///更改比较规则，使得绝对值差小于等于k的数是等价的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    set&lt;<span class="type">int</span>, cmp&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;add&quot;</span>) s.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;del&quot;</span>) s.<span class="built_in">erase</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;query&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(x) != s.<span class="built_in">end</span>())</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17508&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="模拟" scheme="https://blankyang233.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>NC15128 老子的全排列呢</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC15128%20%E8%80%81%E5%AD%90%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E5%91%A2/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC15128%20%E8%80%81%E5%AD%90%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E5%91%A2/</id>
    <published>2022-07-09T07:46:59.000Z</published>
    <updated>2022-07-09T07:47:32.496Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15128">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>老李见和尚赢了自己的酒，但是自己还舍不得，所以就耍起了赖皮，对和尚说，光武不行，再来点文的，你给我说出来1-8的全排序，我就让你喝，这次绝不耍你，你能帮帮和尚么？</p><p><strong>输入描述</strong></p><p>无</p><p><strong>输出描述</strong></p><p>1~8的全排列，按照全排列的顺序输出，每行结尾无空格。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No_Input</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Full arrangement of 1~8</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1~3的全排列  ：</span><br><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL。</strong></p><p>这题用STL中的 $next_permutation$ 函数，可以获得当前序列的下一个字典序较大的排列，$prev_permutation$ 函数与其相反。</p><p>于是用 $next_permutation$ 函数遍历到没有下一个更大的字典序排列为止。</p><p>时间复杂度 $O(1)$</p><p>空间复杂度 $O(1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++) cout &lt;&lt; s[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15128&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>NC14661 简单的数据结构</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC14661%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC14661%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-07-09T07:35:49.000Z</published>
    <updated>2022-07-09T07:37:18.346Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14661">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  栗酱有一天在网上冲浪的时候发现了一道很有意思的数据结构题。  </p><p>  该数据结构形如长条形。  </p><p>  一开始该容器为空，有以下七种操作。  </p><p>  1 a从前面插入元素a  </p><p>  2 从前面删除一个元素  </p><p>  3 a从后面插入一个元素  </p><p>  4 从后面删除一个元素  </p><p>  5 将整个容器头尾翻转  </p><p>  6 输出个数和所有元素  </p><p>  7 对所有元素进行从小到大排序  </p><p><strong>输入描述</strong></p><p>只有一组数据，第一行 $n≤50000,m≤200000, a≤100000$ 代表最大数据数目和操作次数。<br>接下来每一行一个操作如上描述。保证所有操作合法（不会在容器为空时删除元素）。<br>6、7操作共计不会超过10次。</p><p><strong>输出描述</strong></p><p>当执行6操作时，第一行先输出当前的个数，然后从头到尾按顺序输出，每两个元素之间用一个空格隔开，末尾不能有空格。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 1</span><br><span class="line">3 5</span><br><span class="line">3 4</span><br><span class="line">6</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 5 4</span><br><span class="line">2</span><br><span class="line">5 1</span><br><span class="line">2</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：队列，STL。</strong></p><p>一道双端队列的模板题，用 stl 的 $deque$ 能完美解决。</p><p>注意的是反转操作并非真反转，只要标记是否是反转状态，然后队头弹出&#x2F;压入和队尾弹出&#x2F;压入互相交换，排序用正向迭代器和反向迭代器交换就行。</p><p>stl 的双端队列存储的内存并非连续内存，是分段连续内存，在跨段时用通常会慢一些，因此时间复杂度常数比 $vector$ 大。通常 $queue$ 以及 $stack$ 是继承 $deque$ 的因此速度也是比较慢的。</p><p>时间复杂度 压入&#x2F;弹出&#x2F;反转 $O(1)$ ，随机存取 $O(1)$ ，排序 $O(n \log n)$ </p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    <span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span> (rev) d.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">else</span> d.<span class="built_in">push_front</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev) d.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span> d.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span> (rev) d.<span class="built_in">push_front</span>(t);</span><br><span class="line">            <span class="keyword">else</span> d.<span class="built_in">push_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev) d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">else</span> d.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) rev ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) &#123;</span><br><span class="line">            cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev) <span class="keyword">for</span> (<span class="type">int</span> j = d.<span class="built_in">size</span>() - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--) cout &lt;&lt; d[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; d.<span class="built_in">size</span>();j++) cout &lt;&lt; d[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev) <span class="built_in">sort</span>(d.<span class="built_in">rbegin</span>(), d.<span class="built_in">rend</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14661&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="队列" scheme="https://blankyang233.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
</feed>
