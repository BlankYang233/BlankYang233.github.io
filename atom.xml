<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空白のBlog</title>
  
  <subtitle>For the future</subtitle>
  <link href="https://blankyang233.github.io/atom.xml" rel="self"/>
  
  <link href="https://blankyang233.github.io/"/>
  <updated>2022-07-24T14:15:29.450Z</updated>
  <id>https://blankyang233.github.io/</id>
  
  <author>
    <name>空白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022.7.24 多校周报</title>
    <link href="https://blankyang233.github.io/2022/07/24/2022.7.24%20%E5%A4%9A%E6%A0%A1%E5%91%A8%E6%8A%A5/"/>
    <id>https://blankyang233.github.io/2022/07/24/2022.7.24%20%E5%A4%9A%E6%A0%A1%E5%91%A8%E6%8A%A5/</id>
    <published>2022-07-24T14:15:01.000Z</published>
    <updated>2022-07-24T14:15:29.450Z</updated>
    
    <content type="html"><![CDATA[<p>总结</p><span id="more"></span><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>刚打完两场多校赛，体会了什么是区域赛的难度，总的来说就是崩的很厉害。</p><p>第一场签了到，简单题都没打完，就A了两道。主要是策略问题，开始时想快速分工开题，但这种方法并不适合我们，因为我们太菜了，个人实力并不能完整解决一道题，需要讨论，因此第二场决定三个人同时攻打一道题。</p><p>第二场签了到就开始罚坐，就A了一题。虽说策略上没什么问题，但综合实力还是太弱，不足以攻克其他题目，结果还是惨败。有的题目属于是知道要写什么，但就是写不对；更多的题目是压根不知道在说什么，甚至签到题都不知道怎么入手，还是练的太少了。</p><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>再好策略也救不了实力上的差距，区域赛难度对现在的我来说还是有点大。</p><p>不过可以预见的是距离铜牌线只差一点做题经验积累，因为铜牌线并不涉及高深的知识，基本的贪心，动态规划，二分或三分等等就够了，主要就是运用的方法和技巧并不熟练，这方面可以在cf上训练思维。</p><p>再者，对我来说，我是大学零基础学习，需要补上许多东西，距离能顺利打好区域赛的简单题还是需要一点理论上的训练，这方面暑假一直在进行，效果还算可以。</p><p>未来打算先把入门的东西学会，再去cf上练内功，同时深入学习专题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结&lt;/p&gt;</summary>
    
    
    
    <category term="摸鱼日记" scheme="https://blankyang233.github.io/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2022.5.22 周报</title>
    <link href="https://blankyang233.github.io/2022/07/24/2022.5.22%20%E5%91%A8%E6%8A%A5/"/>
    <id>https://blankyang233.github.io/2022/07/24/2022.5.22%20%E5%91%A8%E6%8A%A5/</id>
    <published>2022-07-24T13:58:20.000Z</published>
    <updated>2022-07-24T13:58:45.739Z</updated>
    
    <content type="html"><![CDATA[<p>总结</p><span id="more"></span><h1 id="AC记录"><a href="#AC记录" class="headerlink" title="AC记录"></a>AC记录</h1><p><img src="https://s3.bmp.ovh/imgs/2022/05/22/b05f3c5a8fff3729.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/05/22/15871f83e81537e2.png"></p><h1 id="牛客比赛"><a href="#牛客比赛" class="headerlink" title="牛客比赛"></a>牛客比赛</h1><p><img src="https://s3.bmp.ovh/imgs/2022/05/22/6def25fadd0fa463.png"></p><h1 id="cf"><a href="#cf" class="headerlink" title="cf"></a>cf</h1><p><img src="https://s3.bmp.ovh/imgs/2022/05/22/7bdbcb88a0d226dc.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/05/22/918f5562b3faffe0.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/05/22/ee8c6262de1885de.png"></p><p><a href="https://www.cnblogs.com/BlankYang/p/16296795.html">Codeforces Round #792 (Div. 1 + Div. 2) A-E</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结&lt;/p&gt;</summary>
    
    
    
    <category term="摸鱼日记" scheme="https://blankyang233.github.io/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2022.5.15 周报</title>
    <link href="https://blankyang233.github.io/2022/07/24/2022.5.15%20%E5%91%A8%E6%8A%A5/"/>
    <id>https://blankyang233.github.io/2022/07/24/2022.5.15%20%E5%91%A8%E6%8A%A5/</id>
    <published>2022-07-24T13:57:33.000Z</published>
    <updated>2022-07-24T13:57:59.172Z</updated>
    
    <content type="html"><![CDATA[<p>总结</p><span id="more"></span><h1 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h1><p><img src="https://s3.bmp.ovh/imgs/2022/05/16/c152fd29b3158866.png"> </p><p><a href="https://www.cnblogs.com/BlankYang/p/16253539.html">Codeforces Round #789 (Div. 2) A-C</a></p><p><a href="https://www.cnblogs.com/BlankYang/p/16265219.html">Codeforces Round #790 (Div. 4) A-H</a></p><p><a href="https://www.cnblogs.com/BlankYang/p/16272170.html">Educational Codeforces Round 128 (Rated for Div. 2) A-C+E</a></p><p><a href="https://www.cnblogs.com/BlankYang/p/16275512.html">Codeforces Round #791 (Div. 2) A-C</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结&lt;/p&gt;</summary>
    
    
    
    <category term="摸鱼日记" scheme="https://blankyang233.github.io/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2022.5.8 周报</title>
    <link href="https://blankyang233.github.io/2022/07/24/2022.5.8%20%E5%91%A8%E6%8A%A5/"/>
    <id>https://blankyang233.github.io/2022/07/24/2022.5.8%20%E5%91%A8%E6%8A%A5/</id>
    <published>2022-07-24T13:56:08.000Z</published>
    <updated>2022-07-24T13:56:29.902Z</updated>
    
    <content type="html"><![CDATA[<p>总结</p><span id="more"></span><h1 id="AC记录"><a href="#AC记录" class="headerlink" title="AC记录"></a>AC记录</h1><p><img src="https://s3.bmp.ovh/imgs/2022/05/09/7fe373a8a8656be2.png"></p><h1 id="cf"><a href="#cf" class="headerlink" title="cf"></a>cf</h1><p><img src="https://s3.bmp.ovh/imgs/2022/05/09/46ef811033cf7da1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结&lt;/p&gt;</summary>
    
    
    
    <category term="摸鱼日记" scheme="https://blankyang233.github.io/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2022.5.1 周报</title>
    <link href="https://blankyang233.github.io/2022/07/24/2022.5.1%20%E5%91%A8%E6%8A%A5/"/>
    <id>https://blankyang233.github.io/2022/07/24/2022.5.1%20%E5%91%A8%E6%8A%A5/</id>
    <published>2022-07-24T13:54:42.000Z</published>
    <updated>2022-07-24T13:55:03.460Z</updated>
    
    <content type="html"><![CDATA[<p>总结</p><span id="more"></span><h1 id="AC记录"><a href="#AC记录" class="headerlink" title="AC记录"></a>AC记录</h1><p><img src="https://s3.bmp.ovh/imgs/2022/05/09/3ad12a344d3f3aff.png"></p><h1 id="cf"><a href="#cf" class="headerlink" title="cf"></a>cf</h1><p><img src="https://s3.bmp.ovh/imgs/2022/05/09/9e0f82a9b4ea9727.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结&lt;/p&gt;</summary>
    
    
    
    <category term="摸鱼日记" scheme="https://blankyang233.github.io/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2022.4.23 天梯赛总结</title>
    <link href="https://blankyang233.github.io/2022/07/24/2022.4.23%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://blankyang233.github.io/2022/07/24/2022.4.23%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-24T13:52:10.000Z</published>
    <updated>2022-07-24T13:53:03.951Z</updated>
    
    <content type="html"><![CDATA[<p>总结</p><span id="more"></span><h1 id="L1-94-x2F-100分"><a href="#L1-94-x2F-100分" class="headerlink" title="L1(94&#x2F;100分)"></a>L1(94&#x2F;100分)</h1><p>L1-1~7没啥意外直接过了<br>L1-8想太复杂了，实际上只要排好序把pat及格的人数和天梯赛175但pat不及格的人数做个简单处理就行。这题上面浪费了很多时间。</p><p><strong>总的来看L1用了50分钟还算可以。</strong></p><h1 id="L2-43-x2F-100分"><a href="#L2-43-x2F-100分" class="headerlink" title="L2(43&#x2F;100分)"></a>L2(43&#x2F;100分)</h1><p>L2-1一个模拟做了20分钟，幸好做对了。<br>L2-2用了个数组模拟时间的刻度，很显然特别麻烦，而且端点处理上出了问题，以至于只拿17分。正解应该是对时间直接排序就行。<br>L2-3骗了1分<br>L2-4完全不会</p><p><strong>这次L2属实到我的弱点上了，后面两题完全没思路。</strong></p><h1 id="L3-0-x2F-100分"><a href="#L3-0-x2F-100分" class="headerlink" title="L3(0&#x2F;100分)"></a>L3(0&#x2F;100分)</h1><p><strong>L3没啥悬念，完全不会，知识点缺太多了。。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结&lt;/p&gt;</summary>
    
    
    
    <category term="摸鱼日记" scheme="https://blankyang233.github.io/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>VS Code 调教日记</title>
    <link href="https://blankyang233.github.io/2022/07/24/VS%20Code%20%E8%B0%83%E6%95%99%E6%97%A5%E8%AE%B0/"/>
    <id>https://blankyang233.github.io/2022/07/24/VS%20Code%20%E8%B0%83%E6%95%99%E6%97%A5%E8%AE%B0/</id>
    <published>2022-07-24T13:49:05.000Z</published>
    <updated>2022-07-24T13:51:00.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有关VS-Code的各种配置"><a href="#有关VS-Code的各种配置" class="headerlink" title="有关VS Code的各种配置"></a>有关VS Code的各种配置</h1><span id="more"></span><h2 id="基于msys2的MinGW-w64-GCC的环境配置"><a href="#基于msys2的MinGW-w64-GCC的环境配置" class="headerlink" title="基于msys2的MinGW-w64 GCC的环境配置"></a>基于msys2的MinGW-w64 GCC的环境配置</h2><ol><li>下载并安装msys2</li><li>到路径**…msys2安装路径…\msys64\etc\pacman.d<strong>下找到三个</strong>mirrorlist**文件将国内两个大学镜像源提至最前</li><li>执行<strong>pacman -Syu</strong>更新pacman的基本软件仓库</li><li>执行<strong>pacman -Su</strong>更新的剩余程序</li><li>执行<strong>pacman -S –needed base-devel mingw-w64-x86_64-toolchain</strong>安装Mingw-w64 GCC编译工具链</li><li>系统-&gt;高级系统设置-&gt;环境变量-&gt;找到上面框里的<strong>PATH</strong>编辑-&gt;添加**……msys2安装路径……\msys64\mingw64\bin**（如果有别的mingw的路径请删除）</li><li>打开cmd，输入<strong>g++ –version</strong>，如果出现版本号则说明环境搭建完毕</li></ol><p><a href="https://blog.csdn.net/ScienceRui/article/details/117392080">参考这篇博客</a></p><h2 id="关于-vscode的c-编程环境配置"><a href="#关于-vscode的c-编程环境配置" class="headerlink" title="关于.vscode的c++编程环境配置"></a>关于.vscode的c++编程环境配置</h2><ol><li>下载并安装vscode</li><li>下载并配置c&#x2F;cpp插件</li><li>写个代码按F5，进入配置编译器tasks.json和launch.json</li><li>再按F5开始调试</li><li>开始玩别的插件qwq</li></ol><p><a href="https://zhuanlan.zhihu.com/p/87864677">参考这篇博客</a></p><h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><p>c_cpp插件配置（一般通过Ctrl+Shift+P，搜索插件名字进入图形化配置界面）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;\\**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.19041.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:/MYPROGRAM/ENV/MSYS2/msys64/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;default&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><p>前者编译+运行，后者编译+调试</p><p>F5启动(启动最近启动的模式)，也可以到Run界面手动开启</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(Windows) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppvsdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/C&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;&amp;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;pause&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;console&quot;</span><span class="punctuation">:</span> <span class="string">&quot;externalTerminal&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) 启动&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置类型，这里只能为cppdbg  </span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">// 将要进行调试的程序的路径  </span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 程序调试时传递给程序的命令行参数，一般设为空即可  </span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> <span class="comment">// 设为true时程序将暂停在程序入口处，一般设置为false</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">// 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:\\MYPROGRAM\\ENV\\MSYS2\\msys64\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// miDebugger的路径，注意这里要与MinGw的路径对应</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span><span class="punctuation">,</span> <span class="comment">// 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc  </span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span> <span class="comment">// 调试时是否显示控制台窗口，一般设置为true显示控制台  </span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h3><p>编译配置</p><p>Ctrl+Shift+B编译</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="comment">//&quot;-fexec-charset=GBK&quot;,</span></span><br><span class="line">                <span class="comment">//&quot;-finput-charset=UTF-8&quot;,</span></span><br><span class="line">                <span class="comment">//&quot;-finput-charset=GB2312&quot;,</span></span><br><span class="line">                <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;echo&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;silent&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;panel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shared&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;showReuseMessage&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;clear&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="setting-json"><a href="#setting-json" class="headerlink" title="setting.json"></a>setting.json</h3><p><em>files.associations</em> 用于文件关联的高亮格式化。</p><p>其他所有工作区配置都会出现在这里，有可能某些插件不工作就是这个文件里面多了些不该有的配置。</p><h2 id="关于C-CPP插件自带的代码格式化用法"><a href="#关于C-CPP插件自带的代码格式化用法" class="headerlink" title="关于C_CPP插件自带的代码格式化用法"></a>关于C_CPP插件自带的代码格式化用法</h2><p>首先要把设置-&gt;文本编辑器中的Format On Save打开</p><p>再将C&#x2F;CPP插件中的Formatting调成vcFormat</p><p>最后在C&#x2F;CPP插件里面关于格式化的配置自定义即可</p><h2 id="关于代码模板的用法"><a href="#关于代码模板的用法" class="headerlink" title="关于代码模板的用法"></a>关于代码模板的用法</h2><p>在设置-&gt;用户代码片段-&gt;选择Cpp文件-&gt;进行如下类似自定义</p><p>prefix用于输入前缀匹配，之后只要在文本中输入这个就可以将文本替换</p><p>$符号用于聚焦光标</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;ACM-MODLE&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;acm&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;#include &lt;bits/stdc++.h&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;using namespace std;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;int main() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;\tstd::ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;\t$3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;\treturn 0;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Init an acm model.&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="关于vscode乱码"><a href="#关于vscode乱码" class="headerlink" title="关于vscode乱码"></a>关于vscode乱码</h2><p>注意编程环境默认是utf-8编码，而中国计算机使用的是gbk编码，这样会导致在环境里的中文到计算机终端会乱码，而计算机自身保存的中文到环境也会乱码。</p><p>网上有说，在task配置里面加入-finput-charset用来指定输入文件的的字符编码，-fexec-charset指定了字符串所使用的格式文件编译。这样确实可以解决，但会产生弊端：在future.h中，因为这样的编码会导致编译失败；在平时字符串中打中文会编译失败。这些都是指定编码编译文件产生的问题。</p><p>但实际上我们希望的是终端能输出中文不会乱码，即字符串里的中文能被显示，这只要保证保存时的编码和终端使用的编码相同，即GBK编码。因此，<strong>我们只需要把打开和保存文件的编码改成GBK即可</strong>，不需要更改编译时候使用的代码徒增麻烦。</p><p>具体来说，我们使用GBK编码写了一个代码，再用默认的utf-8编码编译是没有任何问题的，因为字母和数字的编码GBK和utf-8是一样的，而字符串虽然utf-8显示不出，但编译过程我们又不管，只要字符串原封不动还给我就行了，最后的可执行文件字符串还是GBK编码下的二进制，于是我们就能看到了。</p><p><strong>具体流程：</strong></p><ol><li>左下角齿轮</li><li>设置</li><li>用户下在上面搜索框搜索encoding</li><li>找到File: Encoding</li><li>选择GBK即可</li></ol><h2 id="关于vscode的插件"><a href="#关于vscode的插件" class="headerlink" title="关于vscode的插件"></a>关于vscode的插件</h2><p><strong>打红框的是我目前C++编程用到的。</strong></p><p><strong>一些问题：</strong></p><ul><li><p>Error lens</p><p>C_CPP:Error Squiggles 必须是Enable状态，否则无法实时报错。</p><p>长一点代码有可能报不了qwq</p></li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/5b30c3595d86f42c.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;有关VS-Code的各种配置&quot;&gt;&lt;a href=&quot;#有关VS-Code的各种配置&quot; class=&quot;headerlink&quot; title=&quot;有关VS Code的各种配置&quot;&gt;&lt;/a&gt;有关VS Code的各种配置&lt;/h1&gt;</summary>
    
    
    
    <category term="摸鱼日记" scheme="https://blankyang233.github.io/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>某数据结构惨案</title>
    <link href="https://blankyang233.github.io/2022/07/24/%E6%9F%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%83%A8%E6%A1%88/"/>
    <id>https://blankyang233.github.io/2022/07/24/%E6%9F%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%83%A8%E6%A1%88/</id>
    <published>2022-07-24T13:46:00.000Z</published>
    <updated>2022-07-24T13:48:46.566Z</updated>
    
    <content type="html"><![CDATA[<p><strong>恐怖如斯</strong></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt; *Left, *Right;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T &amp;val, Node&lt;T&gt; *Lptr = <span class="literal">nullptr</span>, Node&lt;T&gt; *Rptr = <span class="literal">nullptr</span>) :<span class="built_in">data</span>(val), <span class="built_in">Left</span>(Lptr), <span class="built_in">Right</span>(Rptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiTree</span> &#123;</span><br><span class="line">    Node&lt;T&gt; *root;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BiTree</span>() :<span class="built_in">root</span>(<span class="literal">nullptr</span>), <span class="built_in">len</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">BiTree</span>(<span class="type">const</span> T &amp;val) :<span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(val)), <span class="built_in">len</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">BiTree</span>() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_dfs</span><span class="params">(Node&lt;T&gt; *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span>;<span class="comment">//注意跳出</span></span><br><span class="line">        <span class="built_in">clear_dfs</span>(p-&gt;Left);</span><br><span class="line">        <span class="built_in">clear_dfs</span>(p-&gt;Right);</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">clear_dfs</span>(root);</span><br><span class="line">        root = <span class="literal">nullptr</span>;<span class="comment">//不能忘</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Revolute_dfs</span><span class="params">(Node&lt;T&gt; *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Revolute_dfs</span>(p-&gt;Left);</span><br><span class="line">        <span class="built_in">Revolute_dfs</span>(p-&gt;Right);</span><br><span class="line">        Node&lt;T&gt; *tmp = p-&gt;Left;</span><br><span class="line">        p-&gt;Left = p-&gt;Right;</span><br><span class="line">        p-&gt;Right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Revolute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Revolute_dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Leefsize_dfs</span><span class="params">(Node&lt;T&gt; *p, <span class="type">int</span> &amp;cnt)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Leefsize_dfs</span>(p-&gt;Left, cnt);</span><br><span class="line">        <span class="built_in">Leefsize_dfs</span>(p-&gt;Right, cnt);</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;Left &amp;&amp; !p-&gt;Right) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Leefsize</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Leefsize_dfs</span>(root, cnt);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt; *<span class="title">find_dfs</span><span class="params">(Node&lt;T&gt; *p, <span class="type">const</span> T &amp;val)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == val) <span class="keyword">return</span> p;</span><br><span class="line">        Node&lt;T&gt; *tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp = <span class="built_in">find_dfs</span>(p-&gt;Left, val)) <span class="keyword">return</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (tmp = <span class="built_in">find_dfs</span>(p-&gt;Right, val)) <span class="keyword">return</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node&lt;T&gt; *<span class="title">find</span><span class="params">(<span class="type">const</span> T &amp;val)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_dfs</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Depth_dfs</span><span class="params">(Node&lt;T&gt; *p, <span class="type">int</span> &amp;dmax, <span class="type">int</span> d = <span class="number">1</span>)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">        dmax = <span class="built_in">max</span>(dmax, d);</span><br><span class="line">        <span class="built_in">Depth_dfs</span>(p-&gt;Left, dmax, d + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Depth_dfs</span>(p-&gt;Right, dmax, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dmax = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Depth_dfs</span>(root, dmax);</span><br><span class="line">        <span class="keyword">return</span> dmax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(<span class="type">const</span> T &amp;val)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dmax = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Depth_dfs</span>(<span class="built_in">find</span>(val), dmax);</span><br><span class="line">        <span class="keyword">return</span> dmax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt; *<span class="title">Create_dfs</span><span class="params">(vector&lt;T&gt; &amp;v, T &amp;fin, <span class="type">int</span> &amp;n)</span> </span>&#123;<span class="comment">//必须引用不然没法累加</span></span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        T val = v[n++];</span><br><span class="line">        <span class="keyword">if</span> (val == fin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;T&gt; *left = <span class="built_in">Create_dfs</span>(v, fin, n);</span><br><span class="line">            Node&lt;T&gt; *right = <span class="built_in">Create_dfs</span>(v, fin, n);</span><br><span class="line">            Node&lt;T&gt; *p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(val, left, right);</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">return</span> p;<span class="comment">//记得返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(vector&lt;T&gt; &amp;v, T &amp;fin, <span class="type">int</span> n = <span class="number">0</span>)</span> </span>&#123;<span class="comment">//设另外个函数把root接上</span></span><br><span class="line">        root = <span class="built_in">Create_dfs</span>(v, fin, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Create_bfs</span><span class="params">(vector&lt;T&gt; &amp;v, T &amp;fin)</span><span class="comment">//n为节点数目，root必须加引用，否则函数内的一切操作白搭</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//a用作输入节点数据，i记录已经加入树中的节点个数（可以不用i，但有时候需要补很多0）</span></span><br><span class="line">        queue&lt;Node&lt;T&gt; *&gt; q;<span class="comment">//用于按层输入数据，库函数，随便搜一搜就知道queue怎么用了</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(v[i++]);<span class="comment">//申请根节点</span></span><br><span class="line">        q.<span class="built_in">push</span>(root);<span class="comment">//入队</span></span><br><span class="line">        <span class="keyword">if</span> (i == v.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node&lt;T&gt; *tmp = q.<span class="built_in">front</span>();<span class="comment">//一轮循环为root，以后的循环为temp-&gt;R或temp-&gt;L；</span></span><br><span class="line">            q.<span class="built_in">pop</span>();<span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v[i] == fin) &#123;</span><br><span class="line">                tmp-&gt;Left = <span class="literal">NULL</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp-&gt;Left = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(v[i]);<span class="comment">//一轮循环为将root指针的左孩子指向一个新节点，向新节点赋值刚输入的数据，并将新节点的左右孩子置NULL</span></span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;Left);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == v.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v[i] == fin) &#123;</span><br><span class="line">                tmp-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp-&gt;Right = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(v[i]);</span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;Right);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == v.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse_dfs</span><span class="params">(Node&lt;T&gt; *p, vector&lt;T&gt; &amp;v, <span class="type">int</span> mode = <span class="number">0</span>)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span>;<span class="comment">//递归注意跳出</span></span><br><span class="line">        <span class="keyword">if</span> (mode == <span class="number">0</span>) v.<span class="built_in">push_back</span>(p-&gt;data);</span><br><span class="line">        <span class="built_in">Traverse_dfs</span>(p-&gt;Left, v, mode);</span><br><span class="line">        <span class="keyword">if</span> (mode == <span class="number">1</span>) v.<span class="built_in">push_back</span>(p-&gt;data);</span><br><span class="line">        <span class="built_in">Traverse_dfs</span>(p-&gt;Right, v, mode);</span><br><span class="line">        <span class="keyword">if</span> (mode == <span class="number">2</span>) v.<span class="built_in">push_back</span>(p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse_fo_uc</span><span class="params">(Node&lt;T&gt; *p, vector&lt;T&gt; &amp;v)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        stack&lt;Node&lt;T&gt; *&gt; s;</span><br><span class="line">        Node&lt;T&gt; *ptr = p;<span class="comment">///先判断节点，在入栈，可以在出栈把根节点pop，防止死循环，如果先入栈就会麻烦</span></span><br><span class="line">        <span class="keyword">while</span> (ptr || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr) &#123;<span class="comment">//遍历左树节点</span></span><br><span class="line">                s.<span class="built_in">push</span>(ptr);</span><br><span class="line">                v.<span class="built_in">push_back</span>(ptr-&gt;data);</span><br><span class="line">                ptr = ptr-&gt;Left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//转移到右树</span></span><br><span class="line">                Node&lt;T&gt; *q = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();<span class="comment">//踢掉根节点</span></span><br><span class="line">                ptr = q-&gt;Right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse_io_uc</span><span class="params">(Node&lt;T&gt; *p, vector&lt;T&gt; &amp;v)</span><span class="type">const</span> </span>&#123;<span class="comment">///基本和上面一样</span></span><br><span class="line">        stack&lt;Node&lt;T&gt; *&gt; s;</span><br><span class="line">        Node&lt;T&gt; *ptr = p;</span><br><span class="line">        <span class="keyword">while</span> (ptr || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr) &#123;<span class="comment">//遍历左树节点</span></span><br><span class="line">                s.<span class="built_in">push</span>(ptr);</span><br><span class="line">                ptr = ptr-&gt;Left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//转移到右树</span></span><br><span class="line">                Node&lt;T&gt; *q = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();<span class="comment">//踢掉根节点</span></span><br><span class="line">                v.<span class="built_in">push_back</span>(q-&gt;data);</span><br><span class="line">                ptr = q-&gt;Right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse_po_uc</span><span class="params">(Node&lt;T&gt; *p, vector&lt;T&gt; &amp;v)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        stack&lt;Node&lt;T&gt; *&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (p) s.<span class="built_in">push</span>(p);</span><br><span class="line">        Node&lt;T&gt; *last = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node&lt;T&gt; *ptr = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!ptr-&gt;Left &amp;&amp; !ptr-&gt;Right || last &amp;&amp; last == ptr-&gt;Left &amp;&amp; !ptr-&gt;Right || last &amp;&amp; last == ptr-&gt;Right) &#123;<span class="comment">///叶节点||有左孩子&amp;&amp;上次访问左孩子&amp;&amp;无右孩子||有右孩子&amp;&amp;访问了右孩子</span></span><br><span class="line">                v.<span class="built_in">push_back</span>(ptr-&gt;data);</span><br><span class="line">                last = ptr;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;Right) s.<span class="built_in">push</span>(ptr-&gt;Right);</span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;Left) s.<span class="built_in">push</span>(ptr-&gt;Left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse_bfs</span><span class="params">(Node&lt;T&gt; *p, vector&lt;T&gt; &amp;v)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        queue&lt;Node&lt;T&gt; *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>()-&gt;data);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">front</span>()-&gt;Left) q.<span class="built_in">push</span>(q.<span class="built_in">front</span>()-&gt;Left);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">front</span>()-&gt;Right) q.<span class="built_in">push</span>(q.<span class="built_in">front</span>()-&gt;Right);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse</span><span class="params">(vector&lt;T&gt; &amp;v, <span class="type">int</span> mode = <span class="number">0</span>)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mode &lt;= <span class="number">2</span>) <span class="built_in">Traverse_dfs</span>(root, v, mode);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">3</span>) <span class="built_in">Traverse_fo_uc</span>(root, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">4</span>) <span class="built_in">Traverse_io_uc</span>(root, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">5</span>) <span class="built_in">Traverse_po_uc</span>(root, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">6</span>) <span class="built_in">Traverse_bfs</span>(root, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> mode = <span class="number">0</span>)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        vector&lt;T&gt; v;</span><br><span class="line">        <span class="built_in">Traverse</span>(v, mode);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            cout &lt;&lt; v[i] &lt;&lt; (i == v.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST_dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST_dfs</span><span class="params">(Node&lt;T&gt; *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;Left &amp;&amp; p-&gt;data &lt; p-&gt;Left-&gt;data) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;Right &amp;&amp; p-&gt;data &gt; p-&gt;Right-&gt;data) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST_dfs</span>(p-&gt;Left) &amp;&amp; <span class="built_in">isValidBST_dfs</span>(p-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    ss.<span class="built_in">str</span>(str);</span><br><span class="line">    string fin;</span><br><span class="line">    ss &gt;&gt; fin;</span><br><span class="line">    ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ss.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    ss.<span class="built_in">str</span>(str);</span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; tmp, v.<span class="built_in">push_back</span>(tmp), tmp = fin, ss.<span class="built_in">get</span>() == <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ss.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    BiTree&lt;string&gt; tree;</span><br><span class="line">    tree.<span class="built_in">Create_bfs</span>(v, fin);</span><br><span class="line">    tree.<span class="built_in">write</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (tree.<span class="built_in">isValidBST</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">！！递归部分没法内置初值，所以要引用外壳函数的变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">节点</span></span><br><span class="line"><span class="comment">数据</span></span><br><span class="line"><span class="comment">左指针，右指针</span></span><br><span class="line"><span class="comment">构造（值，左指针，右指针）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二叉树</span></span><br><span class="line"><span class="comment">根节点指针</span></span><br><span class="line"><span class="comment">长度</span></span><br><span class="line"><span class="comment">构造：无根节点</span></span><br><span class="line"><span class="comment">构造（值）：有根节点</span></span><br><span class="line"><span class="comment">析构：销毁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">clear_dfs（节点指针）:clear的内置递归</span></span><br><span class="line"><span class="comment">clear:清空树，外壳</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Revolute_dfs（节点指针）：Revolute的内置递归</span></span><br><span class="line"><span class="comment">Revolute：置换所有左右子树，外壳</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">size：返回节点总数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Leefsize_dfs（节点指针，计数器）：Leefsize的内置递归</span></span><br><span class="line"><span class="comment">Leefsize：返回叶节点总数，外壳</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">empty：返回是否为空</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">find_dfs（节点指针，值）：find的内置递归</span></span><br><span class="line"><span class="comment">find(值)：查找此值的节点地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Depth_dfs（节点指针，最大值容器，计数器）：Depth的内置递归</span></span><br><span class="line"><span class="comment">Depth：返回树深度</span></span><br><span class="line"><span class="comment">Depth（值）：返回指定值作为根节点的树深度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Create_dfs（vector序列，结束符，计数器）：返回父节点，Create的内置递归</span></span><br><span class="line"><span class="comment">Create（vector序列，结束符，计数器）：创建树，外壳</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Traverse_dfs（节点指针，vector容器，模式）：Traverse的内置递归</span></span><br><span class="line"><span class="comment">Traverse_fo_uc（节点指针，vector容器）：Traverse的内置非递归前序</span></span><br><span class="line"><span class="comment">Traverse_io_uc（节点指针，vector容器）：Traverse的内置非递归中序</span></span><br><span class="line"><span class="comment">Traverse_po_uc（节点指针，vector容器）：Traverse的内置非递归后序</span></span><br><span class="line"><span class="comment">Traverse_bfs（节点指针，vector容器）：Traverse的内置广搜</span></span><br><span class="line"><span class="comment">Traverse（vector容器，模式）：以（0先序，1中序，2后序）遍历树，保存到容器，外壳</span></span><br><span class="line"><span class="comment">write（模式）：将以（0~2递归前中后序，3~5非递归前中后序，6层序）遍历树的结果输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;恐怖如斯&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="摸鱼日记" scheme="https://blankyang233.github.io/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>CF590C Three States</title>
    <link href="https://blankyang233.github.io/2022/07/16/CF590C%20Three%20States/"/>
    <id>https://blankyang233.github.io/2022/07/16/CF590C%20Three%20States/</id>
    <published>2022-07-16T12:33:37.000Z</published>
    <updated>2022-07-16T12:33:57.491Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/590/C">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>这道题求连接三个国家的最短路径长度。如果枚举每个点进行bfs，显然不可行，换种思路，从三个国家开始分别进行bfs是可以的。</p><p>注意一开始初始化两个距离数组要无穷大 （0x7f&#x2F;3 ，除三是因为防止加起来炸了）。</p><p>国家是个连通块，而连通块内部是不算路径长度的，那么一开始预处理把连通块内所有格子的步数全设为 $0$，并直接入队，否则会<strong>超时</strong>。</p><p>用 $vis$ 数组记录状态是否访问过，因为步数都是恒定 $1$ 的增量不需要考虑维护bfs扩展顺序，也不必考虑扩展的步数是否小于访问过的点的步数，因为时间线是有序的，这样可以直接用 $vis$ 可以省一点时间。</p><p>当起点国家遇到国家的格子时，就不需要继续搜索了，因为国家内部是不算长度的，只需要用另外一个数组记录国家和国家之间的最短路径即可，当作直线连接国家的最短路径长度，不然会<strong>超时</strong>。</p><p>其他情况都是国家之外的点到三个国家的距离，正常记录即可。</p><p>最后取三个国家每个与其他两个国家直线距离和（有国家和国家连通的特殊情况，这种情况直线最短）与场上不是国家的点到三个国家的距离和减2（因为国家之外的点，三个国家会多算两次这个点的距离，所以减二；而直线距离中间隔着国家，不会多算点）的最小值。</p><p>取直线距离最小值时候要注意，一定每个国家为起点的都看一下。因为比如三个国家在一直线上，顺序为 $1,2,3$ ，显然 $1$ 遇到 $2$ 以后就停了，$3$ 也一样，那么 $1$ 到 $3$ 的距离就是无穷大。但考虑 $2$ ，则有通路 $21$ 和 $23$ 。因此每个国家都要作为起点都看一下直线距离。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1007</span>][<span class="number">1007</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">1007</span>][<span class="number">1007</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> D[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == id + <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                d[i][j][id] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; i,j &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || dt[xx][yy] == <span class="string">&#x27;#&#x27;</span> || vis[xx][yy][id]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[xx][yy][id] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dt[xx][yy] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                d[xx][yy][id] = d[cur.x][cur.y][id] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; xx, yy &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[id][dt[xx][yy] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1e6</span>)</span><br><span class="line">                    D[id][dt[xx][yy] - <span class="string">&#x27;1&#x27;</span>] = d[cur.x][cur.y][id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x7f</span> / <span class="number">3</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(D, <span class="number">0x7f</span> / <span class="number">3</span>, <span class="built_in">sizeof</span>(D));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) <span class="built_in">bfs</span>(i);</span><br><span class="line">    <span class="type">int</span> ans = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">            <span class="keyword">if</span> (i != j) sum += <span class="built_in">min</span>(D[i][j], D[j][i]);</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;.&#x27;</span>) ans = <span class="built_in">min</span>(ans, d[i][j][<span class="number">0</span>] + d[i][j][<span class="number">1</span>] + d[i][j][<span class="number">2</span>] - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans &gt; <span class="number">1e6</span> ? <span class="number">-1</span> : ans) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/590/C&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC235247 Sramoc问题</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC235247%20Sramoc%E9%97%AE%E9%A2%98/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC235247%20Sramoc%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-16T11:58:05.000Z</published>
    <updated>2022-07-16T11:58:34.373Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/235247">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  $Sramoc(K ,M)$ 表示用数字 $0,1,2,3,4,…,k-1$ 组成的自然数中能被M整除的最小数。给定 $K,M$ $2\leq K\leq 10,1\leq M\leq 1000$ ，求 $Sramoc(K ,M)$ 。例如 $K&#x3D;2,M&#x3D;7$ 的时候, $Sramoc(2 ,7) &#x3D;1001$ 。 </p><p><strong>输入描述</strong></p><p>第一行为两个整数 $K,M$ 。</p><p><strong>输出描述</strong></p><p>输出 $Sramoc(K ,M)$</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，数学。</strong></p><p>由于数字可能很大，所以用 <code>string</code> 存储。注意到整除和余数相关，而且要求最小整数，因此同一个余数显然是较早经历过的更优，因此扩展时如果余数已经存在，则不扩展。</p><p>扩展时可以用余数直接做余数运算，利用了同余的性质。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(M)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k, m;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    string num;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span> + i)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123; s,i % m &#125;);</span><br><span class="line">        vis[i % m] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!cur.r) <span class="keyword">return</span> cur.num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            <span class="function">string <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span> + i)</span></span>;</span><br><span class="line">            string nnum = cur.num + s;</span><br><span class="line">            <span class="type">int</span> rr = (cur.r * <span class="number">10</span> + i) % m;</span><br><span class="line">            <span class="keyword">if</span> (vis[rr]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[rr] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; nnum,rr &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/235247&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="数学" scheme="https://blankyang233.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NC24605 [USACO 2011 Ope S]Corn Maze</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC24605%20[USACO%202011%20Ope%20S]Corn%20Maze/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC24605%20[USACO%202011%20Ope%20S]Corn%20Maze/</id>
    <published>2022-07-16T11:51:03.000Z</published>
    <updated>2022-07-16T11:51:29.448Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/24605">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  This past fall, Farmer John took the cows to visit a corn maze. But this wasn’t just any corn maze: it featured several gravity-powered teleporter slides, which cause cows to teleport instantly from one point in the maze to another. The slides work in both directions: a cow can slide from the slide’s start to the end instantly, or from the end to the start. If a cow steps on a space that hosts either end of a slide, she must use the slide.<br> The outside of the corn maze is entirely corn except for a single exit.<br> The maze can be represented by an N x M (2 &lt;&#x3D; N &lt;&#x3D; 300; 2 &lt;&#x3D; M &lt;&#x3D; 300) grid. Each grid element contains one of these items:<br> * Corn (corn grid elements are impassable)<br> * Grass (easy to pass through!)<br> * A slide endpoint (which will transport a cow to the other endpoint)<br> * The exit<br> A cow can only move from one space to the next if they are adjacent and neither contains corn. Each grassy space has four potential neighbors to which a cow can travel. It takes 1 unit of time to move from a grassy space to an adjacent space; it takes 0 units of time to move from one slide endpoint to the other.<br> Corn-filled spaces are denoted with an octothorpe (#). Grassy spaces are denoted with a period (.). Pairs of slide endpoints are denoted with the same uppercase letter (A-Z), and no two different slides have endpoints denoted with the same letter. The exit is denoted with the equals sign (&#x3D;).<br> Bessie got lost. She knows where she is on the grid, and marked her current grassy space with the ‘at’ symbol (@). What is the minimum time she needs to move to the exit space? </p><p><strong>输入描述</strong></p><ul><li>Line 1: N M</li><li>Lines 2..N+1: Line i+1 describes the Line i of the maze</li></ul><p><strong>输出描述</strong></p><ul><li>Line 1: A single integer, the minimum time she needs to move to the exit space.</li></ul><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">###=##</span><br><span class="line">#.W.##</span><br><span class="line">#.####</span><br><span class="line">#.@W##</span><br><span class="line">######</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>又是一道传送门的题，显然用bfs搜索最短路。但传送是立刻的，可以理解为走上去立刻传送，整个过程步数为 $1$ ，因此不需要维护时间线，只要每次扩展特判传送门就行。</p><p>传送门标记有点烦，用字母作为下标，存储传送的两个点坐标，如果踩到字母，那就传送的不是当前坐标的坐标即可。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; tsm[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.x][st.y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;=&#x27;</span>) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || dt[xx][yy] == <span class="string">&#x27;#&#x27;</span> || vis[xx][yy]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dt[xx][yy] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; dt[xx][yy] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it : tsm[dt[xx][yy] - <span class="string">&#x27;A&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (it.x != xx || it.y != yy) &#123;</span><br><span class="line">                        xx = it.x;</span><br><span class="line">                        yy = it.y;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; xx,yy,cur.step + <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    node st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;@&#x27;</span>) st = &#123; i,j,<span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; dt[i][j] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                tsm[dt[i][j] - <span class="string">&#x27;A&#x27;</span>].<span class="built_in">push_back</span>(&#123; i,j,<span class="number">0</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/24605&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC19975 [HAOI2008]移动玩具</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC19975%20[HAOI2008]%E7%A7%BB%E5%8A%A8%E7%8E%A9%E5%85%B7/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC19975%20[HAOI2008]%E7%A7%BB%E5%8A%A8%E7%8E%A9%E5%85%B7/</id>
    <published>2022-07-16T11:42:37.000Z</published>
    <updated>2022-07-16T11:43:06.819Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/19975">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>在一个4*4的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态，规定移动时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具，请你用最少的移动次数将初始的玩具状态移动到某人心中的目标状态。</p><p><strong>输入描述</strong></p><p>前4行表示玩具的初始状态，每行4个数字1或0，1表示方格中放置了玩具，0表示没有放置玩具。<br>接着是一个空行。接下来4行表示玩具的目标状态，每行4个数字1或0，意义同上。</p><p><strong>输出描述</strong></p><p>一个整数，所需要的最少移动次数。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1111</span><br><span class="line">0000</span><br><span class="line">1110</span><br><span class="line">0010</span><br><span class="line"></span><br><span class="line">1010</span><br><span class="line">0101</span><br><span class="line">1010</span><br><span class="line">0101</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，状压。</strong></p><p>显然用bfs，将局面压缩进 $16$ 位的二进制，搜索起始状态到目标状态的最短路径。每次扩展所有棋子上下左右四个方向，不要忘记更改局面状态。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> fin;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> state, step;</span><br><span class="line">&#125;st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.state] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur.state == fin) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((cur.state &gt;&gt; (i * <span class="number">4</span> + j)) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++) &#123;</span><br><span class="line">                    <span class="type">int</span> xx = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> yy = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> sstate = (cur.state &amp; ~(<span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j))) | (<span class="number">1</span> &lt;&lt; (xx * <span class="number">4</span> + yy));</span><br><span class="line">                    <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= <span class="number">4</span> || yy &lt; <span class="number">0</span> || yy &gt;= <span class="number">4</span> || ((cur.state &gt;&gt; (xx * <span class="number">4</span> + yy)) &amp; <span class="number">1</span>) || vis[sstate]) <span class="keyword">continue</span>;</span><br><span class="line">                    vis[sstate] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; sstate,cur.step + <span class="number">1</span> &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) st.state |= <span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) fin |= <span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st.step = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/19975&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="状压" scheme="https://blankyang233.github.io/tags/%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>NC17872 CSL的校园卡</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC17872%20CSL%E7%9A%84%E6%A0%A1%E5%9B%AD%E5%8D%A1/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC17872%20CSL%E7%9A%84%E6%A0%A1%E5%9B%AD%E5%8D%A1/</id>
    <published>2022-07-16T11:28:39.000Z</published>
    <updated>2022-07-16T11:42:04.098Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/17872">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>今天是阳光明媚，晴空万里的一天，CSL早早就高兴地起床走出寝室到校园里转悠。</p><p> 但是，等到他回来的时候，发现他的校园卡不见了，于是他需要走遍校园寻找它的校园卡。CSL想要尽快地找回他掉的校园卡，于是便求助于OneDay帮他一起找。</p><p> OneDay和CSL在同一已知的地点出发，并以相同的速度（1格&#x2F;秒）搜索校园，试求两人走遍校园的最短时间。</p><p><strong>输入描述</strong></p><p>第一行为两个整数n,m(1 ≤ n, m ≤ 4)，表示地图的大小。接下来是n行m列的地图：X表示障碍物，S表示起点，O表示空地。障碍物不能直接经过，数据保证所有空地是可达的，起点有且只有一个。</p><p><strong>输出描述</strong></p><p>输出一个整数表示两人共同走遍校园所需的最少时间。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">XSOO</span><br><span class="line">OOXO</span><br><span class="line">OOOO</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><img src="https://uploadfiles.nowcoder.com/files/20180817/305682_1534476344334_681b8fdb04c924cd0e34b011885adf2290014895.png" alt="img"></p><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">XSX</span><br><span class="line">OOO</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">SOOO</span><br><span class="line">OOOO</span><br><span class="line">OOOO</span><br><span class="line">OOOO</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，状压。</strong></p><p>和通常走迷宫状态是坐标不同，这次是具体的两人坐标加上抽象的局面状态一共五维，每维都是互相独立的。</p><p>将局面状态压缩成一个整数，先将二维坐标压缩成一维 $i<em>n+j$ ，再将这个坐标压缩进状态  $1&lt;&lt;(i</em>n+j)$ ，于是实现了状态压缩。</p><p>每次扩展都是把两人 $16$ 种方向组合都枚举一遍。</p><p>直到当前局面和目标局面相等则输出步数。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(m^2n^22^{mn})$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> fin;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2, state, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.x1][st.y1][st.x2][st.y2][st.state] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur.state == fin) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">                <span class="type">int</span> xx1 = cur.x1 + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> yy1 = cur.y1 + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> xx2 = cur.x2 + dir[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> yy2 = cur.y2 + dir[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> sstate = cur.state | (<span class="number">1</span> &lt;&lt; (xx1 * <span class="number">4</span> + yy1)) | (<span class="number">1</span> &lt;&lt; (xx2 * <span class="number">4</span> + yy2));</span><br><span class="line">                <span class="keyword">if</span> (xx1 &lt; <span class="number">0</span> || xx1 &gt;= n || yy1 &lt; <span class="number">0</span> || yy1 &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (xx2 &lt; <span class="number">0</span> || xx2 &gt;= n || yy2 &lt; <span class="number">0</span> || yy2 &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (dt[xx1][yy1] == <span class="string">&#x27;X&#x27;</span> || dt[xx2][yy2] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (vis[xx1][yy1][xx2][yy2][sstate]) <span class="keyword">continue</span>;</span><br><span class="line">                vis[xx1][yy1][xx2][yy2][sstate] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; xx1,yy1,xx2,yy2,sstate,cur.step + <span class="number">1</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    node st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) st = &#123; i,j,i,j,<span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j),<span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] != <span class="string">&#x27;X&#x27;</span>) fin |= <span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17872&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="状压" scheme="https://blankyang233.github.io/tags/%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>NC15445 wyh的吃鸡</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC15445%20wyh%E7%9A%84%E5%90%83%E9%B8%A1/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC15445%20wyh%E7%9A%84%E5%90%83%E9%B8%A1/</id>
    <published>2022-07-16T11:11:47.000Z</published>
    <updated>2022-07-16T11:12:16.037Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15445">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  最近吃鸡游戏非常火，你们wyh学长也在玩这款游戏，这款游戏有一个非常重要的过程，就是要跑到安全区内，否则就会中毒持续消耗血量，我们这个问题简化如下  </p><p>  假设地图为n*n的一个图，图中有且仅有一块X的联通快代表安全区域，有一个起点S代表缩圈的时候的起点，图中C代表的是车（保证车的数量小于等于100），标记为.的代表空地，可以任意通过，O代表障碍物不能通过。每次没有车的时候2s可以走一个格（只能走自己的上下左右4个方向），有车的话时间为1s走一个格  </p><p>  现在告诉你最多能坚持的时间为t秒，问你在t秒内（含t秒）能否从s点到达安全区域，能的话输出YES，并且输出最短时间，不能的话输出NO  </p><p><strong>输入描述</strong></p><p>输入第一行一个整数T(1&lt;&#x3D;T&lt;&#x3D;10)<br>接下来有T组测试数据，每组测试数据输入2个数n和k(1&lt;&#x3D;n&lt;&#x3D;100,1&lt;&#x3D;k&lt;&#x3D;10^9)<br>接下来n行，每行n个字符，代表对应的n*n的地图，每个字符都是上面的一种，并且保证只有一个起点，只有一块安全区域。</p><p><strong>输出描述</strong></p><p>对于每组测试数据，先输出能否到达，能的话输出YES，然后换行输出最短时间，如果不能的话直接输出NO</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">.X</span><br><span class="line">S.</span><br><span class="line">2 3</span><br><span class="line">.X</span><br><span class="line">SC</span><br><span class="line">2 4</span><br><span class="line">.X</span><br><span class="line">S.</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">3</span><br><span class="line">YES</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：BFS，优先队列。</strong></p><p>因为车的花费和走路花费不一致，会导致时间线混乱，因此可以考虑用优先队列维护时间线扩展，使得每次都是扩展最短时间的点，维持有序性。</p><p>同时，因为车的状态是持续的，非一次性的，因此状态需要多一维记录是否有车。</p><p>细节上，因为车的状态带来的花费影响是下一步才开始，不像传送门是即刻的，因此可以在扩展后直接锁点。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：BFS。</strong></p><p>高维状态和方法一一样，但不使用优先队列维护时间线有序，因此锁点操作通过步数实现。如果当前扩展的步数小于扩展到点的历史步数，那就用本次步数覆盖这个状态的步数。注意要遍历完全才能得出答案。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">107</span>][<span class="number">107</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123; <span class="number">0</span>,<span class="number">-1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">bool</span> c;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.step &gt; b.step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.x][st.y][st.c] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">bool</span> cc = cur.c || dt[xx][yy] == <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> sstep = cur.step + (cur.c ? <span class="number">1</span> : <span class="number">2</span>);<span class="comment">///和之前一次有关</span></span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= n || vis[xx][yy][cc] || dt[xx][yy] == <span class="string">&#x27;O&#x27;</span> || sstep &gt; t)<span class="keyword">continue</span>;</span><br><span class="line">            vis[xx][yy][cc] = <span class="number">1</span>;<span class="comment">///因为不是在这次就改变时间线，所以依旧可以在扩展时直接锁定点</span></span><br><span class="line">            pq.<span class="built_in">push</span>(&#123; xx,yy,cc,sstep &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    node st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) st.x = i, st.y = j, st.c = <span class="number">0</span>, st.step = <span class="number">0</span>;</span><br><span class="line">            vis[i][j][<span class="number">0</span>] = vis[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">bfs</span>(st);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="type">int</span> step[<span class="number">107</span>][<span class="number">107</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123; <span class="number">0</span>,<span class="number">-1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st, vector&lt;node&gt; &amp;ed)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    step[st.x][st.y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> delta = cur.c ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= n || dt[xx][yy] == <span class="string">&#x27;O&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">bool</span> cc = cur.c || dt[xx][yy] == <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (step[xx][yy][cc] &lt;= step[cur.x][cur.y][cur.c] + delta) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">///不能用vis锁定点，因为扩展时间线混乱，不按照时间顺序扩展</span></span><br><span class="line">            <span class="comment">///有可能时间晚的车先占了格子，早的车没扩展过来就无法覆盖了，因此只能用距离覆盖</span></span><br><span class="line">            step[xx][yy][cc] = step[cur.x][cur.y][cur.c] + delta;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; xx,yy,cc &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : ed) ans = <span class="built_in">min</span>(&#123; ans, step[e.x][e.y][<span class="number">0</span>],step[e.x][e.y][<span class="number">1</span>] &#125;);<span class="comment">///目的地是个连通块</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    node st;</span><br><span class="line">    vector&lt;node&gt; ed;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) st.x = i, st.y = j, st.c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;X&#x27;</span>) ed.<span class="built_in">push_back</span>(&#123; i,j,<span class="number">0</span> &#125;);</span><br><span class="line">            step[i][j][<span class="number">0</span>] = step[i][j][<span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">bfs</span>(st, ed);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15445&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC15136 迷宫</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC15136%20%E8%BF%B7%E5%AE%AB/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC15136%20%E8%BF%B7%E5%AE%AB/</id>
    <published>2022-07-16T10:21:25.000Z</published>
    <updated>2022-07-16T10:21:46.597Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15136">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  这是一个关于二维迷宫的题目。我们要从迷宫的起点 ‘S’ 走到终点 ‘E’，每一步我们只能选择上下左右四个方向中的一个前进一格。 ‘W’ 代表墙壁，是不能进入的位置，除了墙壁以外的地方都可以走。迷宫内的 ‘D’ 代表一道上锁的门，只有在持有钥匙的时候才能进入。而 ‘K’ 则代表了钥匙，只要进入这一格，就会自动地拿到钥匙。最后 ‘.’ 则是代表空无一物的地方，欢迎自在的游荡。 </p><p>  本题的迷宫中，起点、终点、门跟钥匙这四个特殊物件，每一个恰好会出现一次。而且，此迷宫的四周 (最上面的一行、最下面的一行、最左边的一列以及最右边的一列) 都会是墙壁。 </p><p>  请问，从起点到终点，最少要走几步呢？ </p><p><strong>输入描述</strong></p><p>输入的第一行有两个正整数H, W，分别代表迷宫的长跟宽。<br>接下来的H行代表迷宫，每行有一个长度恰为W的字串，此字串只包含<code>&#39;S&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;W&#39;</code>, <code>&#39;D &#39;</code>, <code>&#39;K&#39;</code>, <code>&#39;.&#39;</code>这几种字元。</p><p><strong>输出描述</strong></p><p>请在一行中输出一个整数代表答案，如果无法从起点走到终点，请输出-1。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 12</span><br><span class="line">WWWWWWWWWWWW</span><br><span class="line">WE.W.S..W.KW</span><br><span class="line">W..D..W....W</span><br><span class="line">WWWWWWWWWWWW</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 6</span><br><span class="line">WWWWWW</span><br><span class="line">WEWS.W</span><br><span class="line">W.WK.W</span><br><span class="line">W.WD.W</span><br><span class="line">W.W..W</span><br><span class="line">WWWWWW</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>4 ≤ H, W≤ 500<br>‘S’, ‘E’, ‘K’, ‘D’各出现恰好一次<br>迷宫的四周(最上面的一行、最下面的一行、最左边的一列以及最右边的一列) 都会是 ‘W’</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>显然用bfs，不过状态是高维的，包括 <code>(x坐标，y坐标，是否有钥匙)</code> 三个独立状态，互相不能排除。</p><p>细节上注意有钥匙能开门。</p><p>关于步数也可以放进 <code>node</code> 里没关系的。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> dt[<span class="number">507</span>][<span class="number">507</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">507</span>][<span class="number">507</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> step[<span class="number">507</span>][<span class="number">507</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.x][st.y][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    step[st.x][st.y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> step[cur.x][cur.y][cur.k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dt[xx][yy] == <span class="string">&#x27;W&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">bool</span> kk = cur.k || dt[xx][yy] == <span class="string">&#x27;K&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[xx][yy][kk] || dt[xx][yy] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; !kk) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; xx,yy,kk &#125;);</span><br><span class="line">            vis[xx][yy][kk] = <span class="number">1</span>;</span><br><span class="line">            step[xx][yy][kk] = step[cur.x][cur.y][cur.k] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> h, w;</span><br><span class="line">    cin &gt;&gt; h &gt;&gt; w;</span><br><span class="line">    node st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) st.x = i, st.y = j, st.k = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15136&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>UVA11573 Ocean Currents</title>
    <link href="https://blankyang233.github.io/2022/07/16/UVA11573%20Ocean%20Currents/"/>
    <id>https://blankyang233.github.io/2022/07/16/UVA11573%20Ocean%20Currents/</id>
    <published>2022-07-16T10:13:24.000Z</published>
    <updated>2022-07-16T10:13:51.394Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/117187">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>这道题显然用BFS，但发现洋流方向会破坏时间的有序性，但注意到洋流时间花费是 $0$ ，因此只需要用双端队列即可，洋流方向扩展直接放队头，其他方向放队尾。</p><p>同样要注意时间线在本次就改变，因此锁点要在之后锁。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">57</span>][<span class="number">57</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">57</span>][<span class="number">57</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st, node ed)</span> </span>&#123;</span><br><span class="line">    deque&lt;node&gt; dq;</span><br><span class="line">    dq.<span class="built_in">emplace_back</span>(st);</span><br><span class="line">    <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = dq.<span class="built_in">front</span>();</span><br><span class="line">        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[cur.x][cur.y]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur.x][cur.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.x == ed.x &amp;&amp; cur.y == ed.y) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt;= <span class="number">0</span> || xx &gt; n || yy &lt;= <span class="number">0</span> || yy &gt; m || vis[xx][yy]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == dt[cur.x][cur.y] - <span class="string">&#x27;0&#x27;</span>) dq.<span class="built_in">push_front</span>(&#123; xx,yy,cur.step &#125;);</span><br><span class="line">            <span class="keyword">else</span> dq.<span class="built_in">push_back</span>(&#123; xx,yy,cur.step + <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="type">int</span> sx, sy, ex, ey;</span><br><span class="line">        cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">bfs</span>(&#123; sx,sy,<span class="number">0</span> &#125;, &#123; ex,ey,<span class="number">0</span> &#125;) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/117187&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="队列" scheme="https://blankyang233.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC15665 maze</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC15665%20maze/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC15665%20maze/</id>
    <published>2022-07-16T10:04:10.000Z</published>
    <updated>2022-07-16T10:04:40.452Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15665">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  小明来到一个由n x m个格子组成的迷宫，有些格子是陷阱，用’#’表示，小明进入陷阱就会死亡，’.’表示没有陷阱。小明所在的位置用’S’表示，目的地用’T’表示。 </p><p>  小明只能向上下左右相邻的格子移动，每移动一次花费1秒。 </p><p>  有q个单向传送阵，每个传送阵各有一个入口和一个出口，入口和出口都在迷宫的格子里，当走到或被传送到一个有传送阵入口的格子时，小明可以选择是否开启传送阵。如果开启传送阵,小明就会被传送到出口对应的格子里，这个过程会花费3秒；如果不开启传送阵，将不会发生任何事情，小明可以继续向上下左右四个方向移动。 </p><p> 一个格子可能既有多个入口，又有多个出口，小明可以选择任意一个入口开启传送阵。使用传送阵是非常危险的，因为有的传送阵的出口在陷阱里，如果小明使用这样的传送阵，那他就会死亡。也有一些传送阵的入口在陷阱里，这样的传送阵是没有用的，因为小明不能活着进入。请告诉小明活着到达目的地的最短时间。</p><p><strong>输入描述</strong></p><p>有多组数据。对于每组数据：<br>第一行有三个整数n,m,q(2≤ n,m≤300,0≤ q ≤ 1000)。<br>接下来是一个n行m列的矩阵，表示迷宫。<br>最后q行，每行四个整数x1,y1,x2,y2(0≤ x1,x2&lt; n,0≤ y1,y2&lt; m)，表示一个传送阵的入口在x1行y1列，出口在x2行y2列。</p><p><strong>输出描述</strong></p><p>如果小明能够活着到达目的地，则输出最短时间，否则输出-1。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">5 5 1</span><br><span class="line">..S..</span><br><span class="line">.....</span><br><span class="line">.###.</span><br><span class="line">.....</span><br><span class="line">..T..</span><br><span class="line">1 2 3 3</span><br><span class="line">5 5 1</span><br><span class="line">..S..</span><br><span class="line">.....</span><br><span class="line">.###.</span><br><span class="line">.....</span><br><span class="line">..T..</span><br><span class="line">3 3 1 2</span><br><span class="line">5 5 1</span><br><span class="line">S.#..</span><br><span class="line">..#..</span><br><span class="line">###..</span><br><span class="line">.....</span><br><span class="line">....T</span><br><span class="line">0 1 0 2</span><br><span class="line">4 4 2</span><br><span class="line">S#.T</span><br><span class="line">.#.#</span><br><span class="line">.#.#</span><br><span class="line">.#.#</span><br><span class="line">0 0 0 3</span><br><span class="line">2 0 2 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">8</span><br><span class="line">-1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>坐标从0开始</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：BFS，优先队列。</strong></p><p>显然用bfs，但要做修正的是把队列更换为优先队列，因为传送门的存在使得步数时间线被破坏，先到的点不一定步数比后到的点少，因此优先队列维护步数从小到大扩展。但就不能每次扩展直接锁点了，要在每个点真正经过的时候才考虑是否锁点，如果被之前的经过了，则跳过。</p><p>细节上注意传送门的存取，用入口作为下标，多个出口用 <code>vector</code> 存储，形成一个 <code>vector</code> 的二维数组，可以方便扩展。</p><p>遇到出口直接跳出即可，因为优先队列维护了时间。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：BFS。</strong></p><p>如果不用优先队列也可以做，每次扩展如果扩展的点时间更小不扩展，否则覆盖时间。与优先队列的区别在于，这种做法要遍历地图才可以得到结果。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; tsm[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.step &gt; b.step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node init)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(init);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[cur.x][cur.y]) <span class="keyword">continue</span>;<span class="comment">///但一定是最短的时候经过</span></span><br><span class="line">        vis[cur.x][cur.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;T&#x27;</span>) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || vis[xx][yy] || dt[xx][yy] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123; xx,yy,cur.step + <span class="number">1</span> &#125;);<span class="comment">///扩展出来的点不一定是最短的，不能在这里vis</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tr : tsm[cur.x][cur.y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[tr.first][tr.second] || dt[tr.first][tr.second] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123; tr.first,tr.second,cur.step + <span class="number">3</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        node init;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">                cin &gt;&gt; dt[i][j];</span><br><span class="line">                <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) init.x = i, init.y = j, init.step = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">            <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            tsm[x1][y1].<span class="built_in">push_back</span>(&#123; x2,y2 &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">bfs</span>(init) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">                tsm[i][j].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">307</span>][<span class="number">307</span>];<span class="comment">///记录步数，用小的替换大的</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; tsm[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(node init)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(init);</span><br><span class="line">    vis[init.x][init.y] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || vis[xx][yy] &lt;= vis[cur.x][cur.y] + <span class="number">1</span> || dt[xx][yy] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; xx,yy &#125;);</span><br><span class="line">            vis[xx][yy] = vis[cur.x][cur.y] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tr : tsm[cur.x][cur.y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[tr.first][tr.second] &lt;= vis[cur.x][cur.y] + <span class="number">3</span> || dt[tr.first][tr.second] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; tr.first,tr.second &#125;);</span><br><span class="line">            vis[tr.first][tr.second] = vis[cur.x][cur.y] + <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        node init, ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">                cin &gt;&gt; dt[i][j];</span><br><span class="line">                <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) init.x = i, init.y = j;</span><br><span class="line">                <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;T&#x27;</span>) ans.x = i, ans.y = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">            <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            tsm[x1][y1].<span class="built_in">push_back</span>(&#123; x2,y2 &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(init);</span><br><span class="line">        cout &lt;&lt; (vis[ans.x][ans.y] &gt; <span class="number">3e5</span> ? <span class="number">-1</span> : vis[ans.x][ans.y]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">                tsm[i][j].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15665&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC15291 幸运数字Ⅱ</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC15291%20%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC15291%20%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/</id>
    <published>2022-07-16T09:50:23.000Z</published>
    <updated>2022-07-16T09:50:54.451Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15291">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。<br> 比如说，47、744、4都是幸运数字而5、17、467都不是。<br> 定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r - 1) + next(r)。</p><p><strong>输入描述</strong></p><p>两个整数l和r (1 &lt;&#x3D; l &lt;&#x3D; r &lt;&#x3D; 1000,000,000)。</p><p><strong>输出描述</strong></p><p>一个数字表示答案。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，枚举。</strong></p><p>显然对每个数进行枚举是不可行的。而因为一大块数对应一个幸运数字，所以考虑枚举幸运数字，再遍历快速遍历目标区间。</p><p>考虑用bfs打表，因为bfs生成的数字天然排好序了。</p><p>时间复杂度 $O(r-l)$</p><p>空间复杂度 $O(?)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ll x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (x / (<span class="number">1e9</span>) &gt;= <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x * <span class="number">10</span> + <span class="number">4</span>);</span><br><span class="line">        a.<span class="built_in">push_back</span>(x * <span class="number">10</span> + <span class="number">7</span>);</span><br><span class="line">        q.<span class="built_in">push</span>(x * <span class="number">10</span> + <span class="number">4</span>);</span><br><span class="line">        q.<span class="built_in">push</span>(x * <span class="number">10</span> + <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, pos = l;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &lt; pos) i++;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &lt;= r) &#123;</span><br><span class="line">        ans += (a[i] - pos + <span class="number">1</span>) * a[i];</span><br><span class="line">        pos = a[i] + <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (r - pos + <span class="number">1</span>) * a[i];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15291&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="枚举" scheme="https://blankyang233.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>NC16742 [NOIP2002]字串变换</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC16742%20[NOIP2002]%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC16742%20[NOIP2002]%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2/</id>
    <published>2022-07-16T09:29:23.000Z</published>
    <updated>2022-07-16T09:29:53.874Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16742">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>已知有两个字串 A, B及一组字串变换的规则（至多6个规则）:<br> A1 -&gt; B1<br> A2 -&gt; B2<br> 规则的含义为：在A中的子串 A1可以变换为 B1、A2可以变换为 B2 …。<br> 例如：A＝’abcd’　B＝’xyz’<br> 变换规则为：<br> ‘abc’-&gt;‘xu’　‘ud’-&gt;‘y’　‘y’-&gt;‘yz’<br> 则此时，A 可以经过一系列的变换变为 B，其变换的过程为：<br> ‘abcd’-&gt;‘xud’-&gt;‘xy’-&gt;‘xyz’<br> 共进行了三次变换，使得A变换为B。</p><p><strong>输入描述</strong></p><p>输入格式如下：<br>A B</p><p>A1 B1 \</p><p>A2 B2  |-&gt; 变换规则</p><p>… … &#x2F; </p><p>所有字符串长度的上限为 20。</p><p><strong>输出描述</strong></p><p>输出格式如下：<br>若在10步（包含 10步）以内能将A变换为B，则输出最少的变换步数；否则输出”NO ANSWER!”</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abcd xyz</span><br><span class="line">abc xu</span><br><span class="line">ud y</span><br><span class="line">y yz</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，字符串。</strong></p><p>这道题普通bfs也能过，不过可以用来练练dbfs。从结果和起点同时扩展，如果步数相加超过 $10$ 说明十步只能无解，否则只要在对方状态里找到自己当前状态再将步数相加返回即可。要注意正向扩展和反向扩展规则是相反的。</p><p>要注意的是每步变换不一定只有一次，同一条规则可能用在不同的位置要注意不要漏了。</p><p>字符串替换用 <code>string</code> 的成员函数 <code>replace</code> 是真的香2333。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(?)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;string, string&gt;&gt; dir;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string init, string ans)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; vis1, vis2;</span><br><span class="line">    vis1[init] = <span class="number">0</span>;</span><br><span class="line">    vis2[ans] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;string&gt; q1, q2;</span><br><span class="line">    q1.<span class="built_in">push</span>(init);</span><br><span class="line">    q2.<span class="built_in">push</span>(ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        string a = q1.<span class="built_in">front</span>();</span><br><span class="line">        string b = q2.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis1[a] + vis2[b] &gt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">///层数都只增不减，两者之和大于10，就算之后找到了也是no answer</span></span><br><span class="line">        <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(a)) <span class="keyword">return</span> vis1[a] + vis2[a];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(b)) <span class="keyword">return</span> vis1[b] + vis2[b];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; dir.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (~(pos = a.<span class="built_in">find</span>(dir[i].first, pos))) &#123;</span><br><span class="line">                string aa = a;</span><br><span class="line">                aa.<span class="built_in">replace</span>(pos, dir[i].first.<span class="built_in">size</span>(), dir[i].second);</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(aa)) <span class="keyword">continue</span>;</span><br><span class="line">                vis1[aa] = vis1[a] + <span class="number">1</span>;</span><br><span class="line">                q1.<span class="built_in">push</span>(aa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; dir.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (~(pos = b.<span class="built_in">find</span>(dir[i].second, pos))) &#123;</span><br><span class="line">                string bb = b;</span><br><span class="line">                bb.<span class="built_in">replace</span>(pos, dir[i].second.<span class="built_in">size</span>(), dir[i].first);</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(bb)) <span class="keyword">continue</span>;</span><br><span class="line">                vis2[bb] = vis2[b] + <span class="number">1</span>;</span><br><span class="line">                q2.<span class="built_in">push</span>(bb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string init, ans;</span><br><span class="line">    cin &gt;&gt; init &gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    string a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) dir.<span class="built_in">push_back</span>(&#123; a,b &#125;);</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bfs</span>(init, ans);</span><br><span class="line">    <span class="keyword">if</span> (~t) cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO ANSWER!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16742&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="字符串" scheme="https://blankyang233.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>NC51032 八数码</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC51032%20%E5%85%AB%E6%95%B0%E7%A0%81/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC51032%20%E5%85%AB%E6%95%B0%E7%A0%81/</id>
    <published>2022-07-16T09:16:12.000Z</published>
    <updated>2022-07-16T09:16:39.008Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/51032">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 1  2  3  4 </span><br><span class="line"></span><br><span class="line"> 5  6  7  8 </span><br><span class="line"></span><br><span class="line"> 9 10 11 12 </span><br><span class="line"></span><br><span class="line">13 14 15  x </span><br></pre></td></tr></table></figure><p>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 1  2  3  4    1  2  3  4    1  2  3  4    1  2  3  4 </span><br><span class="line"></span><br><span class="line"> 5  6  7  8    5  6  7  8    5  6  7  8    5  6  7  8 </span><br><span class="line"></span><br><span class="line"> 9  x 10 12    9 10  x 12    9 10 11 12    9 10 11 12 </span><br><span class="line"></span><br><span class="line">13 14 11 15   13 14 11 15   13 14  x 15   13 14 15  x </span><br><span class="line"></span><br><span class="line">           r-&gt;           d-&gt;           r-&gt; </span><br></pre></td></tr></table></figure><p>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively.<br>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course).<br>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement. </p><p><strong>输入描述</strong></p><p>You will receive a description of a configuration of the 8 puzzle. The description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  2  3</span><br><span class="line"></span><br><span class="line">x  4  6</span><br><span class="line"></span><br><span class="line">7  5  8</span><br></pre></td></tr></table></figure><p>is described by this list:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 x 4 6 7 5 8</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><p>You will print to standard output either the word &#96;&#96;unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line.</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2  3  4  1  5  x  7  6  8 </span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ullddrurdllurdruldr</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>很显然用bfs搜索，但状态保存是个问题，可以用c++自带的map进行状态保存，也可以用康托展开对局面字符串转化为整型保存（我居然还不会qwq）。</p><p>要注意的是，数据再复杂点可以卡普通的bfs，这时候需要优化搜索，可以用双向bfs或者A*，可以节省大量时间。这里我用了双向bfs（因为不会A*2333）。</p><p>最后注意无解情况可能超时，建议计数跳出（也有逆序对的方法）。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="type">char</span> dirs[<span class="number">4</span>] = &#123; <span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;d&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">(node init, node ans)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    map&lt;string, string&gt; vis1, vis2;</span><br><span class="line">    vis1[init.s] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    vis2[ans.s] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;node&gt; q1, q2;</span><br><span class="line">    q1.<span class="built_in">push</span>(init);</span><br><span class="line">    q2.<span class="built_in">push</span>(ans);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        node a = q1.<span class="built_in">front</span>();</span><br><span class="line">        node b = q2.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        q2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(a.s)) <span class="keyword">return</span> vis1[a.s] + vis2[a.s];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(b.s)) <span class="keyword">return</span> vis1[b.s] + vis2[b.s];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            node aa;</span><br><span class="line">            aa.x = a.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            aa.y = a.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (aa.x &gt;= <span class="number">0</span> &amp;&amp; aa.x &lt; <span class="number">3</span> &amp;&amp; aa.y &gt;= <span class="number">0</span> &amp;&amp; aa.y &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                aa.s = a.s;</span><br><span class="line">                <span class="built_in">swap</span>(aa.s[a.x * <span class="number">3</span> + a.y], aa.s[aa.x * <span class="number">3</span> + aa.y]);</span><br><span class="line">                <span class="keyword">if</span> (!vis1.<span class="built_in">count</span>(aa.s)) vis1[aa.s] = vis1[a.s] + dirs[i], q1.<span class="built_in">push</span>(aa);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node bb;</span><br><span class="line">            bb.x = b.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            bb.y = b.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (bb.x &gt;= <span class="number">0</span> &amp;&amp; bb.x &lt; <span class="number">3</span> &amp;&amp; bb.y &gt;= <span class="number">0</span> &amp;&amp; bb.y &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                bb.s = b.s;</span><br><span class="line">                <span class="built_in">swap</span>(bb.s[b.x * <span class="number">3</span> + b.y], bb.s[bb.x * <span class="number">3</span> + bb.y]);</span><br><span class="line">                <span class="keyword">if</span> (!vis2.<span class="built_in">count</span>(bb.s)) vis2[bb.s] = dirs[<span class="number">3</span> - i] + vis2[b.s], q2.<span class="built_in">push</span>(bb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unsolvable&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    node init, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">        <span class="type">char</span> tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        init.s += tmp;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">            init.x = i / <span class="number">3</span>;</span><br><span class="line">            init.y = i % <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.s = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    ans.x = <span class="number">2</span>;</span><br><span class="line">    ans.y = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(init, ans) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/51032&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
</feed>
