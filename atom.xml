<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空白のBlog</title>
  
  <subtitle>For the future</subtitle>
  <link href="https://blankyang233.github.io/atom.xml" rel="self"/>
  
  <link href="https://blankyang233.github.io/"/>
  <updated>2022-07-16T12:33:57.491Z</updated>
  <id>https://blankyang233.github.io/</id>
  
  <author>
    <name>空白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF590C Three States</title>
    <link href="https://blankyang233.github.io/2022/07/16/CF590C%20Three%20States/"/>
    <id>https://blankyang233.github.io/2022/07/16/CF590C%20Three%20States/</id>
    <published>2022-07-16T12:33:37.000Z</published>
    <updated>2022-07-16T12:33:57.491Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/590/C">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>这道题求连接三个国家的最短路径长度。如果枚举每个点进行bfs，显然不可行，换种思路，从三个国家开始分别进行bfs是可以的。</p><p>注意一开始初始化两个距离数组要无穷大 （0x7f&#x2F;3 ，除三是因为防止加起来炸了）。</p><p>国家是个连通块，而连通块内部是不算路径长度的，那么一开始预处理把连通块内所有格子的步数全设为 $0$，并直接入队，否则会<strong>超时</strong>。</p><p>用 $vis$ 数组记录状态是否访问过，因为步数都是恒定 $1$ 的增量不需要考虑维护bfs扩展顺序，也不必考虑扩展的步数是否小于访问过的点的步数，因为时间线是有序的，这样可以直接用 $vis$ 可以省一点时间。</p><p>当起点国家遇到国家的格子时，就不需要继续搜索了，因为国家内部是不算长度的，只需要用另外一个数组记录国家和国家之间的最短路径即可，当作直线连接国家的最短路径长度，不然会<strong>超时</strong>。</p><p>其他情况都是国家之外的点到三个国家的距离，正常记录即可。</p><p>最后取三个国家每个与其他两个国家直线距离和（有国家和国家连通的特殊情况，这种情况直线最短）与场上不是国家的点到三个国家的距离和减2（因为国家之外的点，三个国家会多算两次这个点的距离，所以减二；而直线距离中间隔着国家，不会多算点）的最小值。</p><p>取直线距离最小值时候要注意，一定每个国家为起点的都看一下。因为比如三个国家在一直线上，顺序为 $1,2,3$ ，显然 $1$ 遇到 $2$ 以后就停了，$3$ 也一样，那么 $1$ 到 $3$ 的距离就是无穷大。但考虑 $2$ ，则有通路 $21$ 和 $23$ 。因此每个国家都要作为起点都看一下直线距离。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1007</span>][<span class="number">1007</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">1007</span>][<span class="number">1007</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> D[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == id + <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                d[i][j][id] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; i,j &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || dt[xx][yy] == <span class="string">&#x27;#&#x27;</span> || vis[xx][yy][id]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[xx][yy][id] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dt[xx][yy] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                d[xx][yy][id] = d[cur.x][cur.y][id] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; xx, yy &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[id][dt[xx][yy] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1e6</span>)</span><br><span class="line">                    D[id][dt[xx][yy] - <span class="string">&#x27;1&#x27;</span>] = d[cur.x][cur.y][id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x7f</span> / <span class="number">3</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(D, <span class="number">0x7f</span> / <span class="number">3</span>, <span class="built_in">sizeof</span>(D));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) <span class="built_in">bfs</span>(i);</span><br><span class="line">    <span class="type">int</span> ans = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">            <span class="keyword">if</span> (i != j) sum += <span class="built_in">min</span>(D[i][j], D[j][i]);</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;.&#x27;</span>) ans = <span class="built_in">min</span>(ans, d[i][j][<span class="number">0</span>] + d[i][j][<span class="number">1</span>] + d[i][j][<span class="number">2</span>] - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans &gt; <span class="number">1e6</span> ? <span class="number">-1</span> : ans) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/590/C&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC235247 Sramoc问题</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC235247%20Sramoc%E9%97%AE%E9%A2%98/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC235247%20Sramoc%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-16T11:58:05.000Z</published>
    <updated>2022-07-16T11:58:34.373Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/235247">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  $Sramoc(K ,M)$ 表示用数字 $0,1,2,3,4,…,k-1$ 组成的自然数中能被M整除的最小数。给定 $K,M$ $2\leq K\leq 10,1\leq M\leq 1000$ ，求 $Sramoc(K ,M)$ 。例如 $K&#x3D;2,M&#x3D;7$ 的时候, $Sramoc(2 ,7) &#x3D;1001$ 。 </p><p><strong>输入描述</strong></p><p>第一行为两个整数 $K,M$ 。</p><p><strong>输出描述</strong></p><p>输出 $Sramoc(K ,M)$</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，数学。</strong></p><p>由于数字可能很大，所以用 <code>string</code> 存储。注意到整除和余数相关，而且要求最小整数，因此同一个余数显然是较早经历过的更优，因此扩展时如果余数已经存在，则不扩展。</p><p>扩展时可以用余数直接做余数运算，利用了同余的性质。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(M)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k, m;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    string num;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span> + i)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123; s,i % m &#125;);</span><br><span class="line">        vis[i % m] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!cur.r) <span class="keyword">return</span> cur.num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            <span class="function">string <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span> + i)</span></span>;</span><br><span class="line">            string nnum = cur.num + s;</span><br><span class="line">            <span class="type">int</span> rr = (cur.r * <span class="number">10</span> + i) % m;</span><br><span class="line">            <span class="keyword">if</span> (vis[rr]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[rr] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; nnum,rr &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/235247&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="数学" scheme="https://blankyang233.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NC24605 [USACO 2011 Ope S]Corn Maze</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC24605%20[USACO%202011%20Ope%20S]Corn%20Maze/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC24605%20[USACO%202011%20Ope%20S]Corn%20Maze/</id>
    <published>2022-07-16T11:51:03.000Z</published>
    <updated>2022-07-16T11:51:29.448Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/24605">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  This past fall, Farmer John took the cows to visit a corn maze. But this wasn’t just any corn maze: it featured several gravity-powered teleporter slides, which cause cows to teleport instantly from one point in the maze to another. The slides work in both directions: a cow can slide from the slide’s start to the end instantly, or from the end to the start. If a cow steps on a space that hosts either end of a slide, she must use the slide.<br> The outside of the corn maze is entirely corn except for a single exit.<br> The maze can be represented by an N x M (2 &lt;&#x3D; N &lt;&#x3D; 300; 2 &lt;&#x3D; M &lt;&#x3D; 300) grid. Each grid element contains one of these items:<br> * Corn (corn grid elements are impassable)<br> * Grass (easy to pass through!)<br> * A slide endpoint (which will transport a cow to the other endpoint)<br> * The exit<br> A cow can only move from one space to the next if they are adjacent and neither contains corn. Each grassy space has four potential neighbors to which a cow can travel. It takes 1 unit of time to move from a grassy space to an adjacent space; it takes 0 units of time to move from one slide endpoint to the other.<br> Corn-filled spaces are denoted with an octothorpe (#). Grassy spaces are denoted with a period (.). Pairs of slide endpoints are denoted with the same uppercase letter (A-Z), and no two different slides have endpoints denoted with the same letter. The exit is denoted with the equals sign (&#x3D;).<br> Bessie got lost. She knows where she is on the grid, and marked her current grassy space with the ‘at’ symbol (@). What is the minimum time she needs to move to the exit space? </p><p><strong>输入描述</strong></p><ul><li>Line 1: N M</li><li>Lines 2..N+1: Line i+1 describes the Line i of the maze</li></ul><p><strong>输出描述</strong></p><ul><li>Line 1: A single integer, the minimum time she needs to move to the exit space.</li></ul><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">###=##</span><br><span class="line">#.W.##</span><br><span class="line">#.####</span><br><span class="line">#.@W##</span><br><span class="line">######</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>又是一道传送门的题，显然用bfs搜索最短路。但传送是立刻的，可以理解为走上去立刻传送，整个过程步数为 $1$ ，因此不需要维护时间线，只要每次扩展特判传送门就行。</p><p>传送门标记有点烦，用字母作为下标，存储传送的两个点坐标，如果踩到字母，那就传送的不是当前坐标的坐标即可。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; tsm[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.x][st.y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;=&#x27;</span>) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || dt[xx][yy] == <span class="string">&#x27;#&#x27;</span> || vis[xx][yy]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dt[xx][yy] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; dt[xx][yy] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it : tsm[dt[xx][yy] - <span class="string">&#x27;A&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (it.x != xx || it.y != yy) &#123;</span><br><span class="line">                        xx = it.x;</span><br><span class="line">                        yy = it.y;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; xx,yy,cur.step + <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    node st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;@&#x27;</span>) st = &#123; i,j,<span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; dt[i][j] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                tsm[dt[i][j] - <span class="string">&#x27;A&#x27;</span>].<span class="built_in">push_back</span>(&#123; i,j,<span class="number">0</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/24605&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC19975 [HAOI2008]移动玩具</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC19975%20[HAOI2008]%E7%A7%BB%E5%8A%A8%E7%8E%A9%E5%85%B7/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC19975%20[HAOI2008]%E7%A7%BB%E5%8A%A8%E7%8E%A9%E5%85%B7/</id>
    <published>2022-07-16T11:42:37.000Z</published>
    <updated>2022-07-16T11:43:06.819Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/19975">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>在一个4*4的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态，规定移动时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具，请你用最少的移动次数将初始的玩具状态移动到某人心中的目标状态。</p><p><strong>输入描述</strong></p><p>前4行表示玩具的初始状态，每行4个数字1或0，1表示方格中放置了玩具，0表示没有放置玩具。<br>接着是一个空行。接下来4行表示玩具的目标状态，每行4个数字1或0，意义同上。</p><p><strong>输出描述</strong></p><p>一个整数，所需要的最少移动次数。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1111</span><br><span class="line">0000</span><br><span class="line">1110</span><br><span class="line">0010</span><br><span class="line"></span><br><span class="line">1010</span><br><span class="line">0101</span><br><span class="line">1010</span><br><span class="line">0101</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，状压。</strong></p><p>显然用bfs，将局面压缩进 $16$ 位的二进制，搜索起始状态到目标状态的最短路径。每次扩展所有棋子上下左右四个方向，不要忘记更改局面状态。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> fin;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> state, step;</span><br><span class="line">&#125;st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.state] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur.state == fin) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((cur.state &gt;&gt; (i * <span class="number">4</span> + j)) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++) &#123;</span><br><span class="line">                    <span class="type">int</span> xx = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> yy = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> sstate = (cur.state &amp; ~(<span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j))) | (<span class="number">1</span> &lt;&lt; (xx * <span class="number">4</span> + yy));</span><br><span class="line">                    <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= <span class="number">4</span> || yy &lt; <span class="number">0</span> || yy &gt;= <span class="number">4</span> || ((cur.state &gt;&gt; (xx * <span class="number">4</span> + yy)) &amp; <span class="number">1</span>) || vis[sstate]) <span class="keyword">continue</span>;</span><br><span class="line">                    vis[sstate] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; sstate,cur.step + <span class="number">1</span> &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) st.state |= <span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) fin |= <span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st.step = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/19975&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="状压" scheme="https://blankyang233.github.io/tags/%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>NC17872 CSL的校园卡</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC17872%20CSL%E7%9A%84%E6%A0%A1%E5%9B%AD%E5%8D%A1/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC17872%20CSL%E7%9A%84%E6%A0%A1%E5%9B%AD%E5%8D%A1/</id>
    <published>2022-07-16T11:28:39.000Z</published>
    <updated>2022-07-16T11:42:04.098Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/17872">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>今天是阳光明媚，晴空万里的一天，CSL早早就高兴地起床走出寝室到校园里转悠。</p><p> 但是，等到他回来的时候，发现他的校园卡不见了，于是他需要走遍校园寻找它的校园卡。CSL想要尽快地找回他掉的校园卡，于是便求助于OneDay帮他一起找。</p><p> OneDay和CSL在同一已知的地点出发，并以相同的速度（1格&#x2F;秒）搜索校园，试求两人走遍校园的最短时间。</p><p><strong>输入描述</strong></p><p>第一行为两个整数n,m(1 ≤ n, m ≤ 4)，表示地图的大小。接下来是n行m列的地图：X表示障碍物，S表示起点，O表示空地。障碍物不能直接经过，数据保证所有空地是可达的，起点有且只有一个。</p><p><strong>输出描述</strong></p><p>输出一个整数表示两人共同走遍校园所需的最少时间。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">XSOO</span><br><span class="line">OOXO</span><br><span class="line">OOOO</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><img src="https://uploadfiles.nowcoder.com/files/20180817/305682_1534476344334_681b8fdb04c924cd0e34b011885adf2290014895.png" alt="img"></p><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">XSX</span><br><span class="line">OOO</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">SOOO</span><br><span class="line">OOOO</span><br><span class="line">OOOO</span><br><span class="line">OOOO</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，状压。</strong></p><p>和通常走迷宫状态是坐标不同，这次是具体的两人坐标加上抽象的局面状态一共五维，每维都是互相独立的。</p><p>将局面状态压缩成一个整数，先将二维坐标压缩成一维 $i<em>n+j$ ，再将这个坐标压缩进状态  $1&lt;&lt;(i</em>n+j)$ ，于是实现了状态压缩。</p><p>每次扩展都是把两人 $16$ 种方向组合都枚举一遍。</p><p>直到当前局面和目标局面相等则输出步数。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(m^2n^22^{mn})$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> fin;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2, state, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.x1][st.y1][st.x2][st.y2][st.state] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur.state == fin) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">                <span class="type">int</span> xx1 = cur.x1 + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> yy1 = cur.y1 + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> xx2 = cur.x2 + dir[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> yy2 = cur.y2 + dir[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> sstate = cur.state | (<span class="number">1</span> &lt;&lt; (xx1 * <span class="number">4</span> + yy1)) | (<span class="number">1</span> &lt;&lt; (xx2 * <span class="number">4</span> + yy2));</span><br><span class="line">                <span class="keyword">if</span> (xx1 &lt; <span class="number">0</span> || xx1 &gt;= n || yy1 &lt; <span class="number">0</span> || yy1 &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (xx2 &lt; <span class="number">0</span> || xx2 &gt;= n || yy2 &lt; <span class="number">0</span> || yy2 &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (dt[xx1][yy1] == <span class="string">&#x27;X&#x27;</span> || dt[xx2][yy2] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (vis[xx1][yy1][xx2][yy2][sstate]) <span class="keyword">continue</span>;</span><br><span class="line">                vis[xx1][yy1][xx2][yy2][sstate] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; xx1,yy1,xx2,yy2,sstate,cur.step + <span class="number">1</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    node st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) st = &#123; i,j,i,j,<span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j),<span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] != <span class="string">&#x27;X&#x27;</span>) fin |= <span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17872&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="状压" scheme="https://blankyang233.github.io/tags/%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>NC15445 wyh的吃鸡</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC15445%20wyh%E7%9A%84%E5%90%83%E9%B8%A1/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC15445%20wyh%E7%9A%84%E5%90%83%E9%B8%A1/</id>
    <published>2022-07-16T11:11:47.000Z</published>
    <updated>2022-07-16T11:12:16.037Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15445">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  最近吃鸡游戏非常火，你们wyh学长也在玩这款游戏，这款游戏有一个非常重要的过程，就是要跑到安全区内，否则就会中毒持续消耗血量，我们这个问题简化如下  </p><p>  假设地图为n*n的一个图，图中有且仅有一块X的联通快代表安全区域，有一个起点S代表缩圈的时候的起点，图中C代表的是车（保证车的数量小于等于100），标记为.的代表空地，可以任意通过，O代表障碍物不能通过。每次没有车的时候2s可以走一个格（只能走自己的上下左右4个方向），有车的话时间为1s走一个格  </p><p>  现在告诉你最多能坚持的时间为t秒，问你在t秒内（含t秒）能否从s点到达安全区域，能的话输出YES，并且输出最短时间，不能的话输出NO  </p><p><strong>输入描述</strong></p><p>输入第一行一个整数T(1&lt;&#x3D;T&lt;&#x3D;10)<br>接下来有T组测试数据，每组测试数据输入2个数n和k(1&lt;&#x3D;n&lt;&#x3D;100,1&lt;&#x3D;k&lt;&#x3D;10^9)<br>接下来n行，每行n个字符，代表对应的n*n的地图，每个字符都是上面的一种，并且保证只有一个起点，只有一块安全区域。</p><p><strong>输出描述</strong></p><p>对于每组测试数据，先输出能否到达，能的话输出YES，然后换行输出最短时间，如果不能的话直接输出NO</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">.X</span><br><span class="line">S.</span><br><span class="line">2 3</span><br><span class="line">.X</span><br><span class="line">SC</span><br><span class="line">2 4</span><br><span class="line">.X</span><br><span class="line">S.</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">3</span><br><span class="line">YES</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：BFS，优先队列。</strong></p><p>因为车的花费和走路花费不一致，会导致时间线混乱，因此可以考虑用优先队列维护时间线扩展，使得每次都是扩展最短时间的点，维持有序性。</p><p>同时，因为车的状态是持续的，非一次性的，因此状态需要多一维记录是否有车。</p><p>细节上，因为车的状态带来的花费影响是下一步才开始，不像传送门是即刻的，因此可以在扩展后直接锁点。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：BFS。</strong></p><p>高维状态和方法一一样，但不使用优先队列维护时间线有序，因此锁点操作通过步数实现。如果当前扩展的步数小于扩展到点的历史步数，那就用本次步数覆盖这个状态的步数。注意要遍历完全才能得出答案。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(nm)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">107</span>][<span class="number">107</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123; <span class="number">0</span>,<span class="number">-1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">bool</span> c;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.step &gt; b.step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.x][st.y][st.c] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">bool</span> cc = cur.c || dt[xx][yy] == <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> sstep = cur.step + (cur.c ? <span class="number">1</span> : <span class="number">2</span>);<span class="comment">///和之前一次有关</span></span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= n || vis[xx][yy][cc] || dt[xx][yy] == <span class="string">&#x27;O&#x27;</span> || sstep &gt; t)<span class="keyword">continue</span>;</span><br><span class="line">            vis[xx][yy][cc] = <span class="number">1</span>;<span class="comment">///因为不是在这次就改变时间线，所以依旧可以在扩展时直接锁定点</span></span><br><span class="line">            pq.<span class="built_in">push</span>(&#123; xx,yy,cc,sstep &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    node st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) st.x = i, st.y = j, st.c = <span class="number">0</span>, st.step = <span class="number">0</span>;</span><br><span class="line">            vis[i][j][<span class="number">0</span>] = vis[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">bfs</span>(st);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="type">int</span> step[<span class="number">107</span>][<span class="number">107</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123; <span class="number">0</span>,<span class="number">-1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st, vector&lt;node&gt; &amp;ed)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    step[st.x][st.y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> delta = cur.c ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= n || dt[xx][yy] == <span class="string">&#x27;O&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">bool</span> cc = cur.c || dt[xx][yy] == <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (step[xx][yy][cc] &lt;= step[cur.x][cur.y][cur.c] + delta) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">///不能用vis锁定点，因为扩展时间线混乱，不按照时间顺序扩展</span></span><br><span class="line">            <span class="comment">///有可能时间晚的车先占了格子，早的车没扩展过来就无法覆盖了，因此只能用距离覆盖</span></span><br><span class="line">            step[xx][yy][cc] = step[cur.x][cur.y][cur.c] + delta;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; xx,yy,cc &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : ed) ans = <span class="built_in">min</span>(&#123; ans, step[e.x][e.y][<span class="number">0</span>],step[e.x][e.y][<span class="number">1</span>] &#125;);<span class="comment">///目的地是个连通块</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    node st;</span><br><span class="line">    vector&lt;node&gt; ed;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) st.x = i, st.y = j, st.c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;X&#x27;</span>) ed.<span class="built_in">push_back</span>(&#123; i,j,<span class="number">0</span> &#125;);</span><br><span class="line">            step[i][j][<span class="number">0</span>] = step[i][j][<span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">bfs</span>(st, ed);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15445&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC15136 迷宫</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC15136%20%E8%BF%B7%E5%AE%AB/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC15136%20%E8%BF%B7%E5%AE%AB/</id>
    <published>2022-07-16T10:21:25.000Z</published>
    <updated>2022-07-16T10:21:46.597Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15136">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  这是一个关于二维迷宫的题目。我们要从迷宫的起点 ‘S’ 走到终点 ‘E’，每一步我们只能选择上下左右四个方向中的一个前进一格。 ‘W’ 代表墙壁，是不能进入的位置，除了墙壁以外的地方都可以走。迷宫内的 ‘D’ 代表一道上锁的门，只有在持有钥匙的时候才能进入。而 ‘K’ 则代表了钥匙，只要进入这一格，就会自动地拿到钥匙。最后 ‘.’ 则是代表空无一物的地方，欢迎自在的游荡。 </p><p>  本题的迷宫中，起点、终点、门跟钥匙这四个特殊物件，每一个恰好会出现一次。而且，此迷宫的四周 (最上面的一行、最下面的一行、最左边的一列以及最右边的一列) 都会是墙壁。 </p><p>  请问，从起点到终点，最少要走几步呢？ </p><p><strong>输入描述</strong></p><p>输入的第一行有两个正整数H, W，分别代表迷宫的长跟宽。<br>接下来的H行代表迷宫，每行有一个长度恰为W的字串，此字串只包含<code>&#39;S&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;W&#39;</code>, <code>&#39;D &#39;</code>, <code>&#39;K&#39;</code>, <code>&#39;.&#39;</code>这几种字元。</p><p><strong>输出描述</strong></p><p>请在一行中输出一个整数代表答案，如果无法从起点走到终点，请输出-1。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 12</span><br><span class="line">WWWWWWWWWWWW</span><br><span class="line">WE.W.S..W.KW</span><br><span class="line">W..D..W....W</span><br><span class="line">WWWWWWWWWWWW</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 6</span><br><span class="line">WWWWWW</span><br><span class="line">WEWS.W</span><br><span class="line">W.WK.W</span><br><span class="line">W.WD.W</span><br><span class="line">W.W..W</span><br><span class="line">WWWWWW</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>4 ≤ H, W≤ 500<br>‘S’, ‘E’, ‘K’, ‘D’各出现恰好一次<br>迷宫的四周(最上面的一行、最下面的一行、最左边的一列以及最右边的一列) 都会是 ‘W’</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>显然用bfs，不过状态是高维的，包括 <code>(x坐标，y坐标，是否有钥匙)</code> 三个独立状态，互相不能排除。</p><p>细节上注意有钥匙能开门。</p><p>关于步数也可以放进 <code>node</code> 里没关系的。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> dt[<span class="number">507</span>][<span class="number">507</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">507</span>][<span class="number">507</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> step[<span class="number">507</span>][<span class="number">507</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[st.x][st.y][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    step[st.x][st.y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> step[cur.x][cur.y][cur.k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dt[xx][yy] == <span class="string">&#x27;W&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">bool</span> kk = cur.k || dt[xx][yy] == <span class="string">&#x27;K&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[xx][yy][kk] || dt[xx][yy] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; !kk) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; xx,yy,kk &#125;);</span><br><span class="line">            vis[xx][yy][kk] = <span class="number">1</span>;</span><br><span class="line">            step[xx][yy][kk] = step[cur.x][cur.y][cur.k] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> h, w;</span><br><span class="line">    cin &gt;&gt; h &gt;&gt; w;</span><br><span class="line">    node st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++) &#123;</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) st.x = i, st.y = j, st.k = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15136&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>UVA11573 Ocean Currents</title>
    <link href="https://blankyang233.github.io/2022/07/16/UVA11573%20Ocean%20Currents/"/>
    <id>https://blankyang233.github.io/2022/07/16/UVA11573%20Ocean%20Currents/</id>
    <published>2022-07-16T10:13:24.000Z</published>
    <updated>2022-07-16T10:13:51.394Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/117187">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>这道题显然用BFS，但发现洋流方向会破坏时间的有序性，但注意到洋流时间花费是 $0$ ，因此只需要用双端队列即可，洋流方向扩展直接放队头，其他方向放队尾。</p><p>同样要注意时间线在本次就改变，因此锁点要在之后锁。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">57</span>][<span class="number">57</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">57</span>][<span class="number">57</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node st, node ed)</span> </span>&#123;</span><br><span class="line">    deque&lt;node&gt; dq;</span><br><span class="line">    dq.<span class="built_in">emplace_back</span>(st);</span><br><span class="line">    <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = dq.<span class="built_in">front</span>();</span><br><span class="line">        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[cur.x][cur.y]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur.x][cur.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.x == ed.x &amp;&amp; cur.y == ed.y) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt;= <span class="number">0</span> || xx &gt; n || yy &lt;= <span class="number">0</span> || yy &gt; m || vis[xx][yy]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == dt[cur.x][cur.y] - <span class="string">&#x27;0&#x27;</span>) dq.<span class="built_in">push_front</span>(&#123; xx,yy,cur.step &#125;);</span><br><span class="line">            <span class="keyword">else</span> dq.<span class="built_in">push_back</span>(&#123; xx,yy,cur.step + <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="type">int</span> sx, sy, ex, ey;</span><br><span class="line">        cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">bfs</span>(&#123; sx,sy,<span class="number">0</span> &#125;, &#123; ex,ey,<span class="number">0</span> &#125;) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/117187&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="队列" scheme="https://blankyang233.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC15665 maze</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC15665%20maze/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC15665%20maze/</id>
    <published>2022-07-16T10:04:10.000Z</published>
    <updated>2022-07-16T10:04:40.452Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15665">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  小明来到一个由n x m个格子组成的迷宫，有些格子是陷阱，用’#’表示，小明进入陷阱就会死亡，’.’表示没有陷阱。小明所在的位置用’S’表示，目的地用’T’表示。 </p><p>  小明只能向上下左右相邻的格子移动，每移动一次花费1秒。 </p><p>  有q个单向传送阵，每个传送阵各有一个入口和一个出口，入口和出口都在迷宫的格子里，当走到或被传送到一个有传送阵入口的格子时，小明可以选择是否开启传送阵。如果开启传送阵,小明就会被传送到出口对应的格子里，这个过程会花费3秒；如果不开启传送阵，将不会发生任何事情，小明可以继续向上下左右四个方向移动。 </p><p> 一个格子可能既有多个入口，又有多个出口，小明可以选择任意一个入口开启传送阵。使用传送阵是非常危险的，因为有的传送阵的出口在陷阱里，如果小明使用这样的传送阵，那他就会死亡。也有一些传送阵的入口在陷阱里，这样的传送阵是没有用的，因为小明不能活着进入。请告诉小明活着到达目的地的最短时间。</p><p><strong>输入描述</strong></p><p>有多组数据。对于每组数据：<br>第一行有三个整数n,m,q(2≤ n,m≤300,0≤ q ≤ 1000)。<br>接下来是一个n行m列的矩阵，表示迷宫。<br>最后q行，每行四个整数x1,y1,x2,y2(0≤ x1,x2&lt; n,0≤ y1,y2&lt; m)，表示一个传送阵的入口在x1行y1列，出口在x2行y2列。</p><p><strong>输出描述</strong></p><p>如果小明能够活着到达目的地，则输出最短时间，否则输出-1。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">5 5 1</span><br><span class="line">..S..</span><br><span class="line">.....</span><br><span class="line">.###.</span><br><span class="line">.....</span><br><span class="line">..T..</span><br><span class="line">1 2 3 3</span><br><span class="line">5 5 1</span><br><span class="line">..S..</span><br><span class="line">.....</span><br><span class="line">.###.</span><br><span class="line">.....</span><br><span class="line">..T..</span><br><span class="line">3 3 1 2</span><br><span class="line">5 5 1</span><br><span class="line">S.#..</span><br><span class="line">..#..</span><br><span class="line">###..</span><br><span class="line">.....</span><br><span class="line">....T</span><br><span class="line">0 1 0 2</span><br><span class="line">4 4 2</span><br><span class="line">S#.T</span><br><span class="line">.#.#</span><br><span class="line">.#.#</span><br><span class="line">.#.#</span><br><span class="line">0 0 0 3</span><br><span class="line">2 0 2 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">8</span><br><span class="line">-1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>坐标从0开始</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：BFS，优先队列。</strong></p><p>显然用bfs，但要做修正的是把队列更换为优先队列，因为传送门的存在使得步数时间线被破坏，先到的点不一定步数比后到的点少，因此优先队列维护步数从小到大扩展。但就不能每次扩展直接锁点了，要在每个点真正经过的时候才考虑是否锁点，如果被之前的经过了，则跳过。</p><p>细节上注意传送门的存取，用入口作为下标，多个出口用 <code>vector</code> 存储，形成一个 <code>vector</code> 的二维数组，可以方便扩展。</p><p>遇到出口直接跳出即可，因为优先队列维护了时间。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：BFS。</strong></p><p>如果不用优先队列也可以做，每次扩展如果扩展的点时间更小不扩展，否则覆盖时间。与优先队列的区别在于，这种做法要遍历地图才可以得到结果。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(mn)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; tsm[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.step &gt; b.step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(node init)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(init);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[cur.x][cur.y]) <span class="keyword">continue</span>;<span class="comment">///但一定是最短的时候经过</span></span><br><span class="line">        vis[cur.x][cur.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dt[cur.x][cur.y] == <span class="string">&#x27;T&#x27;</span>) <span class="keyword">return</span> cur.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || vis[xx][yy] || dt[xx][yy] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123; xx,yy,cur.step + <span class="number">1</span> &#125;);<span class="comment">///扩展出来的点不一定是最短的，不能在这里vis</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tr : tsm[cur.x][cur.y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[tr.first][tr.second] || dt[tr.first][tr.second] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123; tr.first,tr.second,cur.step + <span class="number">3</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        node init;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">                cin &gt;&gt; dt[i][j];</span><br><span class="line">                <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) init.x = i, init.y = j, init.step = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">            <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            tsm[x1][y1].<span class="built_in">push_back</span>(&#123; x2,y2 &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">bfs</span>(init) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">                tsm[i][j].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">307</span>][<span class="number">307</span>];<span class="comment">///记录步数，用小的替换大的</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; tsm[<span class="number">307</span>][<span class="number">307</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(node init)</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(init);</span><br><span class="line">    vis[init.x][init.y] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || vis[xx][yy] &lt;= vis[cur.x][cur.y] + <span class="number">1</span> || dt[xx][yy] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; xx,yy &#125;);</span><br><span class="line">            vis[xx][yy] = vis[cur.x][cur.y] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tr : tsm[cur.x][cur.y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[tr.first][tr.second] &lt;= vis[cur.x][cur.y] + <span class="number">3</span> || dt[tr.first][tr.second] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; tr.first,tr.second &#125;);</span><br><span class="line">            vis[tr.first][tr.second] = vis[cur.x][cur.y] + <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        node init, ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">                cin &gt;&gt; dt[i][j];</span><br><span class="line">                <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;S&#x27;</span>) init.x = i, init.y = j;</span><br><span class="line">                <span class="keyword">if</span> (dt[i][j] == <span class="string">&#x27;T&#x27;</span>) ans.x = i, ans.y = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">            <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            tsm[x1][y1].<span class="built_in">push_back</span>(&#123; x2,y2 &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(init);</span><br><span class="line">        cout &lt;&lt; (vis[ans.x][ans.y] &gt; <span class="number">3e5</span> ? <span class="number">-1</span> : vis[ans.x][ans.y]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">                tsm[i][j].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15665&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC15291 幸运数字Ⅱ</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC15291%20%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC15291%20%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/</id>
    <published>2022-07-16T09:50:23.000Z</published>
    <updated>2022-07-16T09:50:54.451Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15291">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。<br> 比如说，47、744、4都是幸运数字而5、17、467都不是。<br> 定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r - 1) + next(r)。</p><p><strong>输入描述</strong></p><p>两个整数l和r (1 &lt;&#x3D; l &lt;&#x3D; r &lt;&#x3D; 1000,000,000)。</p><p><strong>输出描述</strong></p><p>一个数字表示答案。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，枚举。</strong></p><p>显然对每个数进行枚举是不可行的。而因为一大块数对应一个幸运数字，所以考虑枚举幸运数字，再遍历快速遍历目标区间。</p><p>考虑用bfs打表，因为bfs生成的数字天然排好序了。</p><p>时间复杂度 $O(r-l)$</p><p>空间复杂度 $O(?)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ll x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (x / (<span class="number">1e9</span>) &gt;= <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x * <span class="number">10</span> + <span class="number">4</span>);</span><br><span class="line">        a.<span class="built_in">push_back</span>(x * <span class="number">10</span> + <span class="number">7</span>);</span><br><span class="line">        q.<span class="built_in">push</span>(x * <span class="number">10</span> + <span class="number">4</span>);</span><br><span class="line">        q.<span class="built_in">push</span>(x * <span class="number">10</span> + <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, pos = l;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &lt; pos) i++;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &lt;= r) &#123;</span><br><span class="line">        ans += (a[i] - pos + <span class="number">1</span>) * a[i];</span><br><span class="line">        pos = a[i] + <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (r - pos + <span class="number">1</span>) * a[i];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15291&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="枚举" scheme="https://blankyang233.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>NC16742 [NOIP2002]字串变换</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC16742%20[NOIP2002]%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC16742%20[NOIP2002]%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2/</id>
    <published>2022-07-16T09:29:23.000Z</published>
    <updated>2022-07-16T09:29:53.874Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16742">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>已知有两个字串 A, B及一组字串变换的规则（至多6个规则）:<br> A1 -&gt; B1<br> A2 -&gt; B2<br> 规则的含义为：在A中的子串 A1可以变换为 B1、A2可以变换为 B2 …。<br> 例如：A＝’abcd’　B＝’xyz’<br> 变换规则为：<br> ‘abc’-&gt;‘xu’　‘ud’-&gt;‘y’　‘y’-&gt;‘yz’<br> 则此时，A 可以经过一系列的变换变为 B，其变换的过程为：<br> ‘abcd’-&gt;‘xud’-&gt;‘xy’-&gt;‘xyz’<br> 共进行了三次变换，使得A变换为B。</p><p><strong>输入描述</strong></p><p>输入格式如下：<br>A B</p><p>A1 B1 \</p><p>A2 B2  |-&gt; 变换规则</p><p>… … &#x2F; </p><p>所有字符串长度的上限为 20。</p><p><strong>输出描述</strong></p><p>输出格式如下：<br>若在10步（包含 10步）以内能将A变换为B，则输出最少的变换步数；否则输出”NO ANSWER!”</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abcd xyz</span><br><span class="line">abc xu</span><br><span class="line">ud y</span><br><span class="line">y yz</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，字符串。</strong></p><p>这道题普通bfs也能过，不过可以用来练练dbfs。从结果和起点同时扩展，如果步数相加超过 $10$ 说明十步只能无解，否则只要在对方状态里找到自己当前状态再将步数相加返回即可。要注意正向扩展和反向扩展规则是相反的。</p><p>要注意的是每步变换不一定只有一次，同一条规则可能用在不同的位置要注意不要漏了。</p><p>字符串替换用 <code>string</code> 的成员函数 <code>replace</code> 是真的香2333。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(?)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;string, string&gt;&gt; dir;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string init, string ans)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; vis1, vis2;</span><br><span class="line">    vis1[init] = <span class="number">0</span>;</span><br><span class="line">    vis2[ans] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;string&gt; q1, q2;</span><br><span class="line">    q1.<span class="built_in">push</span>(init);</span><br><span class="line">    q2.<span class="built_in">push</span>(ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        string a = q1.<span class="built_in">front</span>();</span><br><span class="line">        string b = q2.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis1[a] + vis2[b] &gt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">///层数都只增不减，两者之和大于10，就算之后找到了也是no answer</span></span><br><span class="line">        <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(a)) <span class="keyword">return</span> vis1[a] + vis2[a];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(b)) <span class="keyword">return</span> vis1[b] + vis2[b];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; dir.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (~(pos = a.<span class="built_in">find</span>(dir[i].first, pos))) &#123;</span><br><span class="line">                string aa = a;</span><br><span class="line">                aa.<span class="built_in">replace</span>(pos, dir[i].first.<span class="built_in">size</span>(), dir[i].second);</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(aa)) <span class="keyword">continue</span>;</span><br><span class="line">                vis1[aa] = vis1[a] + <span class="number">1</span>;</span><br><span class="line">                q1.<span class="built_in">push</span>(aa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; dir.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (~(pos = b.<span class="built_in">find</span>(dir[i].second, pos))) &#123;</span><br><span class="line">                string bb = b;</span><br><span class="line">                bb.<span class="built_in">replace</span>(pos, dir[i].second.<span class="built_in">size</span>(), dir[i].first);</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(bb)) <span class="keyword">continue</span>;</span><br><span class="line">                vis2[bb] = vis2[b] + <span class="number">1</span>;</span><br><span class="line">                q2.<span class="built_in">push</span>(bb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string init, ans;</span><br><span class="line">    cin &gt;&gt; init &gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    string a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) dir.<span class="built_in">push_back</span>(&#123; a,b &#125;);</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bfs</span>(init, ans);</span><br><span class="line">    <span class="keyword">if</span> (~t) cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO ANSWER!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16742&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="字符串" scheme="https://blankyang233.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>NC51032 八数码</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC51032%20%E5%85%AB%E6%95%B0%E7%A0%81/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC51032%20%E5%85%AB%E6%95%B0%E7%A0%81/</id>
    <published>2022-07-16T09:16:12.000Z</published>
    <updated>2022-07-16T09:16:39.008Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/51032">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 1  2  3  4 </span><br><span class="line"></span><br><span class="line"> 5  6  7  8 </span><br><span class="line"></span><br><span class="line"> 9 10 11 12 </span><br><span class="line"></span><br><span class="line">13 14 15  x </span><br></pre></td></tr></table></figure><p>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 1  2  3  4    1  2  3  4    1  2  3  4    1  2  3  4 </span><br><span class="line"></span><br><span class="line"> 5  6  7  8    5  6  7  8    5  6  7  8    5  6  7  8 </span><br><span class="line"></span><br><span class="line"> 9  x 10 12    9 10  x 12    9 10 11 12    9 10 11 12 </span><br><span class="line"></span><br><span class="line">13 14 11 15   13 14 11 15   13 14  x 15   13 14 15  x </span><br><span class="line"></span><br><span class="line">           r-&gt;           d-&gt;           r-&gt; </span><br></pre></td></tr></table></figure><p>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively.<br>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course).<br>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement. </p><p><strong>输入描述</strong></p><p>You will receive a description of a configuration of the 8 puzzle. The description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  2  3</span><br><span class="line"></span><br><span class="line">x  4  6</span><br><span class="line"></span><br><span class="line">7  5  8</span><br></pre></td></tr></table></figure><p>is described by this list:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 x 4 6 7 5 8</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><p>You will print to standard output either the word &#96;&#96;unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line.</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2  3  4  1  5  x  7  6  8 </span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ullddrurdllurdruldr</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>很显然用bfs搜索，但状态保存是个问题，可以用c++自带的map进行状态保存，也可以用康托展开对局面字符串转化为整型保存（我居然还不会qwq）。</p><p>要注意的是，数据再复杂点可以卡普通的bfs，这时候需要优化搜索，可以用双向bfs或者A*，可以节省大量时间。这里我用了双向bfs（因为不会A*2333）。</p><p>最后注意无解情况可能超时，建议计数跳出（也有逆序对的方法）。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="type">char</span> dirs[<span class="number">4</span>] = &#123; <span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;d&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">(node init, node ans)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    map&lt;string, string&gt; vis1, vis2;</span><br><span class="line">    vis1[init.s] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    vis2[ans.s] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;node&gt; q1, q2;</span><br><span class="line">    q1.<span class="built_in">push</span>(init);</span><br><span class="line">    q2.<span class="built_in">push</span>(ans);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        node a = q1.<span class="built_in">front</span>();</span><br><span class="line">        node b = q2.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        q2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(a.s)) <span class="keyword">return</span> vis1[a.s] + vis2[a.s];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(b.s)) <span class="keyword">return</span> vis1[b.s] + vis2[b.s];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            node aa;</span><br><span class="line">            aa.x = a.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            aa.y = a.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (aa.x &gt;= <span class="number">0</span> &amp;&amp; aa.x &lt; <span class="number">3</span> &amp;&amp; aa.y &gt;= <span class="number">0</span> &amp;&amp; aa.y &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                aa.s = a.s;</span><br><span class="line">                <span class="built_in">swap</span>(aa.s[a.x * <span class="number">3</span> + a.y], aa.s[aa.x * <span class="number">3</span> + aa.y]);</span><br><span class="line">                <span class="keyword">if</span> (!vis1.<span class="built_in">count</span>(aa.s)) vis1[aa.s] = vis1[a.s] + dirs[i], q1.<span class="built_in">push</span>(aa);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node bb;</span><br><span class="line">            bb.x = b.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            bb.y = b.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (bb.x &gt;= <span class="number">0</span> &amp;&amp; bb.x &lt; <span class="number">3</span> &amp;&amp; bb.y &gt;= <span class="number">0</span> &amp;&amp; bb.y &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                bb.s = b.s;</span><br><span class="line">                <span class="built_in">swap</span>(bb.s[b.x * <span class="number">3</span> + b.y], bb.s[bb.x * <span class="number">3</span> + bb.y]);</span><br><span class="line">                <span class="keyword">if</span> (!vis2.<span class="built_in">count</span>(bb.s)) vis2[bb.s] = dirs[<span class="number">3</span> - i] + vis2[b.s], q2.<span class="built_in">push</span>(bb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unsolvable&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    node init, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">        <span class="type">char</span> tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        init.s += tmp;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">            init.x = i / <span class="number">3</span>;</span><br><span class="line">            init.y = i % <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.s = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    ans.x = <span class="number">2</span>;</span><br><span class="line">    ans.y = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(init, ans) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/51032&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC202589 魔法数字</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC202589%20%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC202589%20%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-16T08:46:10.000Z</published>
    <updated>2022-07-16T08:46:36.632Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/202589">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>牛妹给牛牛写了一个数字n，然后又给自己写了一个数字m，她希望牛牛能执行最少的操作将他的数字转化成自己的。<br> 操作共有三种，如下：<br> 1.在当前数字的基础上加一，如：4转化为5<br> 2.在当前数字的基础上减一，如：4转化为3<br> 3.将当前数字变成它的平方，如：4转化为16</p><p> 返回最少需要的操作数。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,10</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>$(1\leq n,m\leq1000)$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，数学。</strong></p><p>显然用bfs，不过要注意限制条件，只有小于目标时才能加法和乘方，其中乘方的结果不能超过 $1024$；减法结果不能小于 $0$ 。</p><p>时间复杂度 $O(1)$</p><p>空间复杂度 $O(1)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[<span class="number">1200</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    vis[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur == m) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[cur + <span class="number">1</span>]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur + <span class="number">1</span>);</span><br><span class="line">                vis[cur + <span class="number">1</span>] = vis[cur] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur * cur &lt;= <span class="number">1024</span> &amp;&amp; !vis[cur * cur]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur * cur);</span><br><span class="line">                vis[cur * cur] = vis[cur] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!vis[cur - <span class="number">1</span>]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(cur - <span class="number">1</span>);</span><br><span class="line">            vis[cur - <span class="number">1</span>] = vis[cur] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">bfs</span>(n, m);</span><br><span class="line">    cout &lt;&lt; vis[m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/202589&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="数学" scheme="https://blankyang233.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NC16498 [NOIP2014]寻找道路</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC16498%20[NOIP2014]%E5%AF%BB%E6%89%BE%E9%81%93%E8%B7%AF/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC16498%20[NOIP2014]%E5%AF%BB%E6%89%BE%E9%81%93%E8%B7%AF/</id>
    <published>2022-07-16T08:34:40.000Z</published>
    <updated>2022-07-16T08:38:09.437Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16498">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  在有向图G中，每条边的长度均为1，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件： </p><p>  <strong>1．路径上的所有点的出边所指向的点都直接或间接与终点连通。</strong>  </p><p>  <strong>2．在满足条件1的情况下使路径最短。</strong>  </p><p>  注意：图G中可能存在重边和自环，题目保证终点没有出边。 </p><p> 请你输出符合条件的路径的长度。</p><p><strong>输入描述</strong></p><p>第一行有两个用一个空格隔开的整数n和m，表示图有n个点和m条边。<br>接下来的m行每行2个整数x、y，之间用一个空格隔开，表示有一条边从点x指向点y。<br>最后一行有两个用一个空格隔开的整数s、t，表示起点为s，终点为t。</p><p><strong>输出描述</strong></p><p>输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出-1。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20180605/305281_1528203820886_3C024EF27056A621B6F25F13BE8D1FEA" alt="img"></p><p>如上图所示，箭头表示有向道路，圆点表示城市。起点1与终点3不连通，所以满足题目描述的路径不存在，故输出-1。</p><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6 6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 6</span><br><span class="line">2 5</span><br><span class="line">4 5</span><br><span class="line">3 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20180605/305281_1528203856548_EF70C5DF3C8055B79562AFF8ABFD40CB" alt="img"></p><p>如上图所示，满足条件的路径为1-&gt;3-&gt;4-&gt;5。注意点2不能在答案路径中，因为点2连了一条边到点6，而点6不与终点5连通。</p><p><strong>备注</strong></p><p>对于30%的数据，0&lt; n≤10，0&lt; m≤20；<br>对于60%的数据，0&lt; n≤100，0&lt; m≤2000；<br>对于100%的数据，0&lt; n≤10,000，0&lt; m≤200,000，0&lt; x,y,s,t≤n，x≠t。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS，图论。</strong></p><p>显然用bfs，但与普通走迷宫不同的是，迷宫路径上的点的任意邻接点都必须也能通往终点，这意味着最短路径并非合法路径。</p><p>首先筛选出哪些点能通往终点，选择反向建图，从终点出发走迷宫走到的点都是可达终点的点，用 $ck1[i]$ 表示编号 $i$ 的点可以到达终点。</p><p>然后遍历每个点，如果是不可行点，将其在反向图意义下的邻接点全都排除。因为图是反向的我们无法找到正向图意义下的邻接点，从而无法从一个可达点找其邻接点是否不可达，因此反过来，把不可达点的反向邻接点都排除即可，因为不可达点是反向邻接点的正向邻接点。用 $ck2[i]$ 表达这个点是否是满足条件的点。</p><p>随后在 $ck2$ 的限制下遍历图找最短路即可。</p><p>时间复杂度 $O(n+m)$</p><p>空间复杂度 $O(n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">10007</span>];</span><br><span class="line"><span class="type">bool</span> ck1[<span class="number">10007</span>], ck2[<span class="number">10007</span>];</span><br><span class="line"><span class="type">int</span> step[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsck</span><span class="params">(<span class="type">int</span> st)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    ck1[st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; g[cur].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">int</span> now = g[cur][i];</span><br><span class="line">            <span class="keyword">if</span> (ck1[now]) <span class="keyword">continue</span>;</span><br><span class="line">            ck1[now] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    step[st] = <span class="number">0</span>;</span><br><span class="line">    ck2[st] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur == ed) <span class="keyword">return</span> step[ed];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; g[cur].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">int</span> now = g[cur][i];</span><br><span class="line">            <span class="keyword">if</span> (!ck2[now]) <span class="keyword">continue</span>;</span><br><span class="line">            ck2[now] = <span class="number">0</span>;</span><br><span class="line">            step[now] = step[cur] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> st, ed;</span><br><span class="line">    cin &gt;&gt; st &gt;&gt; ed;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfsck</span>(ed);<span class="comment">///找到终点可达点</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ck2, ck1, <span class="built_in">sizeof</span>(ck1));<span class="comment">///复制出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>;u &lt;= n;u++) &#123;<span class="comment">///进一步筛选所有正向邻接点是终点可达点的终点可达点</span></span><br><span class="line">        <span class="comment">///因为通路反向了，不能通过找到终点可达点找到判断其正向邻接点是否是终点不可达点</span></span><br><span class="line">        <span class="comment">///而要通过终点不可达点排除其反向邻接点，因为终点不可达点的反向邻接点的正向邻接点是终点不可达点</span></span><br><span class="line">        <span class="keyword">if</span> (ck1[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; g[u].<span class="built_in">size</span>();j++)</span><br><span class="line">            ck2[g[u][j]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(ed, st) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">///找到终点到起点的最短路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16498&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
    <category term="图论" scheme="https://blankyang233.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>NC201613 Jelly</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC201613%20Jelly/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC201613%20Jelly/</id>
    <published>2022-07-16T08:24:03.000Z</published>
    <updated>2022-07-16T08:24:31.400Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/201613">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Nancy喜欢吃果冻！</p><p>  Nancy钻进了一个 $n \times n \times n$ 的果冻里，她想从(1,1,1)一路上、下、左、右、前、后六个方向吃到(n,n,n)。 </p><p>  但果冻毕竟是有许多口味的，标记为*的口味是Nancy不愿意吃的，其余的果冻均标记为.。 </p><p> Nancy不想吃坏肚子，于是她想尽可能少的吃果冻。<br> 下面给出果冻的情况，请你帮忙计算一下她能吃多少块果冻叭！</p><p><strong>输入描述</strong></p><p>第一行：一个整数n。<br>接下来n层，每组n行，每行n列，表示果冻(i,j,k)的情况（如题目描述所述）。<br>数据满足：$1 \leq n \leq 100$，保证果冻(1,1,1)不是Nancy不愿意吃的。</p><p><strong>输出描述</strong></p><p>如果可以到达(n,n,n)，请输出路上吃的果冻数量，否则请输出-1。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">.*</span><br><span class="line">..</span><br><span class="line">*.</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：BFS。</strong></p><p>一个三维迷宫板板题，没啥好说的，第一次写觉得挺好玩qwq。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> dt[<span class="number">110</span>][<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> step[<span class="number">110</span>][<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pos</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;pos&gt; q;</span><br><span class="line">    pos s = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    step[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pos now_pos = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (now_pos.x == n - <span class="number">1</span> &amp;&amp; now_pos.y == n - <span class="number">1</span> &amp;&amp; now_pos.z == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> step[n - <span class="number">1</span>][n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++) &#123;</span><br><span class="line">            pos cur_pos;</span><br><span class="line">            cur_pos.x = now_pos.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            cur_pos.y = now_pos.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            cur_pos.z = now_pos.z + dir[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= cur_pos.x &amp;&amp; cur_pos.x &lt; n &amp;&amp;</span><br><span class="line">                <span class="number">0</span> &lt;= cur_pos.y &amp;&amp; cur_pos.y &lt; n &amp;&amp;</span><br><span class="line">                <span class="number">0</span> &lt;= cur_pos.z &amp;&amp; cur_pos.z &lt; n &amp;&amp;</span><br><span class="line">                dt[cur_pos.x][cur_pos.y][cur_pos.z] == <span class="string">&#x27;.&#x27;</span> &amp;&amp;</span><br><span class="line">                !step[cur_pos.x][cur_pos.y][cur_pos.z]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur_pos);</span><br><span class="line">                step[cur_pos.x][cur_pos.y][cur_pos.z] = step[now_pos.x][now_pos.y][now_pos.z] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; dt[i][j];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/201613&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="BFS" scheme="https://blankyang233.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>NC16758 [NOIP2000]单词接龙</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC16758%20[NOIP2000]%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC16758%20[NOIP2000]%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</id>
    <published>2022-07-16T08:13:31.000Z</published>
    <updated>2022-07-16T08:13:51.703Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16758">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at和atide间不能相连。</p><p><strong>输入描述</strong></p><p>输入的第一行为一个单独的整数n(n ≤ 20)表示单词数，以下n行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.</p><p><strong>输出描述</strong></p><p>只需输出以此字母开头的最长的“龙”的长度</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">at</span><br><span class="line">touch</span><br><span class="line">cheat</span><br><span class="line">choose</span><br><span class="line">tact</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>连成的“龙”为 <code>atoucheatactactouchoose</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：DFS。</strong></p><p>先要预处理出单词之间互相能衔接的最短长度方便搜索，$link[i][j]$ 表示第 $i$ 个单词和第 $j$ 个单词能衔接的最短长度，如果不能衔接则为 $-1$ ，初始时用 $0$ 表示可开始的单词；用 $vis[i]$ 表示第 $i$ 个单词用到几次，两次就不能再用。然后一个简单的搜索，每次更新最大值。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(n^2)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string words[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> link[<span class="number">27</span>][<span class="number">27</span>];<span class="comment">///x,y单词的衔接长度</span></span><br><span class="line"><span class="type">int</span> vis[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; <span class="built_in">min</span>(words[x].<span class="built_in">size</span>(), words[y].<span class="built_in">size</span>());i++) &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = words[x].<span class="built_in">size</span>() - i;j &lt; words[x].<span class="built_in">size</span>();j++)</span><br><span class="line">            ok &amp;= words[x][j] == words[y][j - (words[x].<span class="built_in">size</span>() - i)];</span><br><span class="line">        <span class="keyword">if</span> (ok) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> sum = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">2</span> || !~link[pos][i]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i]++;</span><br><span class="line">        <span class="built_in">dfs</span>(i, sum + words[i].<span class="built_in">size</span>() - link[pos][i]);</span><br><span class="line">        vis[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; words[i];</span><br><span class="line">    cin &gt;&gt; words[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            link[i][j] = <span class="built_in">check</span>(i, j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) link[<span class="number">0</span>][i] = words[<span class="number">0</span>][<span class="number">0</span>] == words[i][<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16758&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NC20583 [SDOI2016]齿轮</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC20583%20[SDOI2016]%E9%BD%BF%E8%BD%AE/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC20583%20[SDOI2016]%E9%BD%BF%E8%BD%AE/</id>
    <published>2022-07-16T08:00:33.000Z</published>
    <updated>2022-07-16T08:01:15.489Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20583">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  现有一个传动系统，包含了N个组合齿轮和M个链条。每一个链条连接了两个组合齿轮u和v，并提供了一个传动比x : y。 </p><p>  即如果只考虑这两个组合齿轮，编号为u的齿轮转动x圈，编号为v的齿轮会转动y圈。传动比为正表示若编号为u的齿轮顺时针转动，则编号为v的齿轮也顺时针转动。传动比为负表示若编号为u的齿轮顺时针转动，则编号为v的齿轮会逆时针转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这Ｎ个组合齿轮能否同时转动。 </p><p><strong>输入描述</strong></p><p>有多组数据，第一行给定整数Ｔ，表示总的数据组数，之后依次给出Ｔ组数据。<br>每一组数据的第一行给定整数Ｎ和Ｍ，表示齿轮总数和链条总数。<br>之后有Ｍ行，依次描述了每一个链条，其中每一行给定四个整数u，v，x和y，表示只考虑这一组联动关系的情况下，编号为u的齿轮转动x圈，编号为v的齿轮会转动y圈。<br>请注意，x为正整数，而y为非零整数，但是y有可能为负数。<br>T ≤ 32，N ≤ 1000，M ≤ 10000且x与y的绝对值均不超过100</p><p><strong>输出描述</strong></p><p>输出T行，对应每一组数据。首先应该输出标识这是第几组数据，参见样例输出。之后输出判定结果，如果N个组合齿轮可以同时正常运行，则输出Yes，否则输出No。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">1 2 3 5</span><br><span class="line">2 3 5 -7</span><br><span class="line">1 3 3 -7</span><br><span class="line">3 3</span><br><span class="line">1 2 3 5</span><br><span class="line">2 3 5 -7</span><br><span class="line">1 3 3 7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: Yes</span><br><span class="line">Case #2: No</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：并查集。</strong></p><p>用带权并查集维护齿轮之间的关系，用权值表示根节点转一圈，这个节点转的圈数。</p><p>路径压缩，将父节点到根节点的权值乘以自己的权值。</p><p>集合合并，对于节点 $x$ 和 $y$ 以及其根节点 $rx$ 和 $ry$ ，将 $rx$ 合并到 $ry$ 需要得到 $rx$ 的新权值，即得到 $rx$ 和 $ry$ 的传动比，有：<br>$$<br>w_{rx}’ &#x3D; \frac{1}{w_{x}} \cdot \frac{x}{y} \cdot \frac{w_{y}}{1} \cdot 1<br>$$<br>即四个齿轮的三个传动比相乘得到 $rx$ 和 $ry$ 的传动比再将 $ry$ 圈数设为 $1$ ，于是 $w_{rx}$ 就等于 $rx$ 与 $ry$ 的传动比乘以 $ry$ 的圈数 $1$ 。</p><p>如果新加关系的两个点已经在一个关系集合中，那就检验是否合法：<br>$$<br>\frac{w_{x}}{w_{y}} &#x3D; \frac{x}{y}<br>$$<br>两者传动比是否相等，相等则合法。</p><p>注意精度问题，相等用小于误差表示。</p><p>时间复杂度 $O(n + m\log n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：DFS，图论。</strong></p><p>和并查集思路差不多，但建图时要建无向图，因为需要直到可能遍历时走的是反向的。给起点权值赋为 $1$ ，其他节点根据传动比赋值，上一个节点乘以这个方向的传动比的倒数的结果即是这个点实际转多少圈。</p><p>如果遇到遍历到一个访问过的节点，那就判断实际权值和目前算出来的权值是否相等。</p><p>时间复杂度 $O(n+m)$</p><p>空间复杂度 $O(n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">10007</span>];</span><br><span class="line"><span class="type">double</span> w[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> pre = fa[x];</span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    w[x] *= w[pre];</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (rx == ry)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(w[x] / w[y] - r) &lt; <span class="number">1e-6</span>;</span><br><span class="line">    fa[rx] = ry;</span><br><span class="line">    w[rx] = <span class="number">1</span> / w[x] * r * w[y];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i, w[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="type">double</span> x, y;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">        flag &amp;= <span class="built_in">merge</span>(u, v, x / y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= t;i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">    <span class="type">double</span> w;</span><br><span class="line">&#125;e[<span class="number">10007</span> &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">1007</span>], cnt;</span><br><span class="line"><span class="type">double</span> vis[<span class="number">1007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].nxt = h[u];</span><br><span class="line">    h[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u];~i;i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(vis[v] - vis[u] / e[i].w) &gt; <span class="number">1e-6</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vis[v] = vis[u] / e[i].w;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) h[i] = <span class="number">-1</span>, vis[i] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="type">double</span> x, y;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span>(u, v, x / y);</span><br><span class="line">        <span class="built_in">add</span>(v, u, y / x);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= t;i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20583&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
    <category term="图论" scheme="https://blankyang233.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>NC24623 Tree Decoration</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC24623%20Tree%20Decoration/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC24623%20Tree%20Decoration/</id>
    <published>2022-07-16T07:08:33.000Z</published>
    <updated>2022-07-16T07:09:20.330Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/24623">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Farmer John is decorating his Spring Equinox Tree (like a Christmas tree but popular about three months later). It can be modeled as a rooted mathematical tree with N (1 &lt;&#x3D; N &lt;&#x3D; 100,000) elements, labeled 1…N, with element 1 as the root of the tree. Each tree element e &gt; 1 has a parent, PeP_ePe (1 &lt;&#x3D; $P_e$ &lt;&#x3D; N). Element 1 has no parent (denoted ‘-1’ in the input), of course, because it is the root of the tree.<br> Each element i has a corresponding subtree (potentially of size 1) rooted there. FJ would like to make sure that the subtree corresponding to element i has a total of at least $C_i$ (0 &lt;&#x3D; $C_i$ &lt;&#x3D; 10,000,000) ornaments scattered among its members. He would also like to minimize the total amount of time it takes him to place all the ornaments (it takes time K*$T_i$ to place K ornaments at element i (1 &lt;&#x3D; $T_i$​ &lt;&#x3D; 100)).<br> Help FJ determine the minimum amount of time it takes to place ornaments that satisfy the constraints. Note that this answer might not fit into a 32-bit integer, but it will fit into a signed 64-bit integer. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">For example, consider the tree below where nodes located higher on</span><br><span class="line">the display are parents of connected lower nodes (1 is the root):</span><br><span class="line"></span><br><span class="line">               1 </span><br><span class="line">               |</span><br><span class="line">               2</span><br><span class="line">               |</span><br><span class="line">               5</span><br><span class="line">              / \</span><br><span class="line">             4   3</span><br><span class="line"></span><br><span class="line">Suppose that FJ has the following subtree constraints:</span><br><span class="line"></span><br><span class="line">                  Minimum ornaments the subtree requires</span><br><span class="line">                    |     Time to install an ornament</span><br><span class="line">       Subtree      |       |</span><br><span class="line">        root   |   C_i  |  T_i</span><br><span class="line">       --------+--------+-------</span><br><span class="line">          1    |    9   |   3</span><br><span class="line">          2    |    2   |   2</span><br><span class="line">          3    |    3   |   2</span><br><span class="line">          4    |    1   |   4</span><br><span class="line">          5    |    3   |   3</span><br><span class="line"></span><br><span class="line">Then FJ can place all the ornaments as shown below, for a total</span><br><span class="line">cost of 20:</span><br><span class="line"></span><br><span class="line">            1 [0/9(0)]     legend: element# [ornaments here/ |                      total ornaments in subtree(node install time)]</span><br><span class="line">            2 [3/9(6)]</span><br><span class="line">            |</span><br><span class="line">            5 [0/6(0)]</span><br><span class="line">           / \</span><br><span class="line"> [1/1(4)] 4   3 [5/5(10)]</span><br></pre></td></tr></table></figure><p><strong>输入描述</strong></p><ul><li>Line 1: A single integer: N</li><li>Lines 2..N+1: Line i+1 contains three space-separated integers: PiP_iPi, CiC_iCi, and TiT_iTi</li></ul><p><strong>输出描述</strong></p><ul><li>Line 1: A single integer: The minimum time to place all the ornaments</li></ul><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 </span><br><span class="line">-1 9 3 </span><br><span class="line">1 2 2 </span><br><span class="line">5 3 2 </span><br><span class="line">5 1 4 </span><br><span class="line">2 3 3 </span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，DFS，树形dp。</strong></p><p>每个节点为根的子树都有一个最小要求的装饰数量，显然叶子节点只能全挂上去，随后向上考虑。对于一个子树，肯定把装饰挂在花费最小的节点上，因此可以回溯同时更新子树最小值，同时还需要一个记录已经挂了多少的数组。</p><p>注意结果可能超 <code>int</code> 。</p><p>时间复杂度 $O(n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;e[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">100007</span>], cnt;</span><br><span class="line"><span class="type">int</span> root, c[<span class="number">100007</span>], t[<span class="number">100007</span>];<span class="comment">///某节点的需求装饰；某子树所有节点的最小t；</span></span><br><span class="line">ll ans, csum[<span class="number">100007</span>];   <span class="comment">///某子树已有装饰</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].nxt = h[u];</span><br><span class="line">    h[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!~h[u]) &#123;</span><br><span class="line">        ans += c[u] * t[u];</span><br><span class="line">        csum[u] = c[u];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u];~i;i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        csum[u] += csum[v];</span><br><span class="line">        t[u] = <span class="built_in">min</span>(t[u], t[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">max</span>(c[u] - csum[u], <span class="number">0LL</span>) * t[u];</span><br><span class="line">    csum[u] = <span class="built_in">max</span>(csum[u], <span class="number">0LL</span> + c[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; c[i] &gt;&gt; t[i];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">-1</span>) root = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/24623&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
    <category term="树形dp" scheme="https://blankyang233.github.io/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>NC20272 [SCOI2009]生日快乐</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC20272%20[SCOI2009]%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC20272%20[SCOI2009]%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</id>
    <published>2022-07-16T06:45:20.000Z</published>
    <updated>2022-07-16T06:45:51.695Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20272">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  windy的生日到了，为了庆祝生日，他的朋友们帮他买了一个边长分别为 X 和 Y 的矩形蛋糕。现在包括windy ，一共有 N 个人来分这块大蛋糕，要求每个人必须获得相同面积的蛋糕。 </p><p>  windy主刀，每一切只能平行于一块蛋糕 的一边（任意一边），并且必须把这块蛋糕切成两块。这样，要切成 N 块蛋糕，windy必须切 N-1 次。 </p><p>  为了使得每块蛋糕看起来漂亮，我们要求 N块蛋糕的长边与短边的比值的最大值最小。你能帮助windy求出这个比值么？ </p><p><strong>输入描述</strong></p><p>包含三个整数，X Y N。<br>1 ≤ X,Y ≤ 10000 ； 1 ≤ N ≤ 10</p><p><strong>输出描述</strong></p><p>包含一个浮点数，保留6位小数。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 5 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.800000</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>100%的数据，满足$1  \le  X,Y  \le  10000 ; 1  \le  N  \le  10$ 。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：DFS。</strong></p><p>最大值最小很容易想到二分，然鹅答案并不单调2333。</p><p>发现 $N$ 很小考虑暴搜。对于长宽为 $x$ 和 $y$ 的一块蛋糕，如果要切成 $n$ 块面积相等的，那么每块面积是 $\frac{xy}{n}$ ，则一定要切在长上 $\frac{x}{n}$ 的倍数点或宽上 $\frac{y}{n}$ 的倍数点上，其他切法都不能保证每块都是 $\frac{xy}{n}$ 。</p><p>方法有了就可以搜索了。对于每一块蛋糕（包括原蛋糕）切长或宽切 $i$ 倍的点，$i$ 只需到 $\lfloor \frac{n}{2} \rfloor$ 即可，再大会对称。然后再搜索切出来两块的答案，取两块中的长宽比最大值作为这种切法的答案，如果 $n&#x3D;1$ 返回长宽比作为答案。然后取长宽两种切法的所有切点中答案的最小值返回，作为这整块的蛋糕切出来的长宽比最大值的最小值。</p><p>时间复杂度 $O(?)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">int</span> n)</span> </span>&#123;<span class="comment">///长x宽y的蛋糕要切成n块</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">max</span>(x, y) / <span class="built_in">min</span>(x, y);</span><br><span class="line">    <span class="type">double</span> dx = x / n, dy = y / n, ans = <span class="number">1e9</span>;<span class="comment">///每刀只能切在x/n或y/n的倍数上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= (n &gt;&gt; <span class="number">1</span>);i++) &#123;<span class="comment">///切出1~n/2块的大小，再大就对称的了</span></span><br><span class="line">        <span class="type">double</span> l = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i * dx, y, i), <span class="built_in">dfs</span>(x - i * dx, y, n - i));<span class="comment">///切在长上</span></span><br><span class="line">        <span class="type">double</span> w = <span class="built_in">max</span>(<span class="built_in">dfs</span>(x, i * dy, i), <span class="built_in">dfs</span>(x, y - i * dy, n - i));<span class="comment">///切在宽上</span></span><br><span class="line">        ans = <span class="built_in">min</span>(&#123; ans, l, w &#125;);<span class="comment">///取两种情况的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">dfs</span>(x, y, n) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20272&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NC20566 [SCOI2010]游戏</title>
    <link href="https://blankyang233.github.io/2022/07/16/NC20566%20[SCOI2010]%E6%B8%B8%E6%88%8F/"/>
    <id>https://blankyang233.github.io/2022/07/16/NC20566%20[SCOI2010]%E6%B8%B8%E6%88%8F/</id>
    <published>2022-07-15T18:08:26.000Z</published>
    <updated>2022-07-15T18:08:58.437Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20566">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  lxhgww最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有2个属性，这些属性的值用[1,10000]之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 </p><p>  游戏进行到最后，lxhgww遇到了终极boss，这个终极boss很奇怪，攻击他的装备所使用的属性值必须从1开始连续递增地攻击，才能对boss产生伤害。也就是说一开始的时候，lxhgww只能使用某个属性值为1的装备攻击boss，然后只能使用某个属性值为2的装备攻击boss，然后只能使用某个属性值为3的装备攻击boss……以此类推。现在lxhgww想知道他最多能连续攻击boss多少次？ </p><p><strong>输入描述</strong></p><p>输入的第一行是一个整数N，表示lxhgww拥有N种装备<br>接下来N行，是对这N种装备的描述，每行2个数字，表示第i种装备的2个属性值</p><p><strong>输出描述</strong></p><p>输出一行，包括1个数字，表示lxhgww最多能连续攻击的次数。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>对于 $30%$ 的数据，保证 $N \leq 1000$<br>对于 $100%$ 的数据，保证 $N \leq 1000000$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：图论，DFS。</strong></p><p>把装备的两个属性值抽象成一条边的两个点，每条边只能选择一个点，那么对于一个连通图有大于等于点数量的边，那么这个连通图是存在环的，那就一定有方法使得所有点都选到，否则最大值不能选到。</p><p>于是，建图后枚举所有点的连通情况，如果存在环就是所有都能取到，如果不存在环则最大值取不到，将第一个不能取到的值设为最大值，如此遍历所有数字即可得到确定的第一个不能取到的数字，答案就是这个数字减一。</p><p>时间复杂度 $O(n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：并查集。</strong></p><p>原理和方法一一样，将存在关系的点放入一个集合，根节点权值设为这个集合的最大值，如果存在两个点在一个集合后又被合并一次说明这个集合的点存在环，否则没有。</p><p>遍历所有集合找到不能取到最大值的集合中的最小值，减一即是答案。</p><p>时间复杂度 $O(n)$</p><p>空间复杂度 $O(1)$</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p><strong>知识点：贪心。</strong> </p><p>对于每个装备取较小属性值，如果这个值已经取过了那就取较大的属性值，将访问信息存入一个数组，如此得到一个最小能取到的属性值的数组，遍历数组直到第一个不能去到的数为止，减一即是答案。</p><p>时间复杂度 $O(n)$</p><p>空间复杂度 $O(1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">10007</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10007</span>];</span><br><span class="line"><span class="type">int</span> maxn;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">///判断环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; g[u].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span> (fa == v) <span class="keyword">continue</span>; <span class="comment">///和其他标记不一样，父节点单独考虑</span></span><br><span class="line">        <span class="keyword">if</span> (vis[v]) &#123; flag = <span class="literal">true</span>; <span class="keyword">continue</span>; &#125;<span class="comment">///有环还不能跳出，要找到最大值</span></span><br><span class="line">        vis[v] = <span class="number">1</span>;<span class="comment">///标记</span></span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, v);<span class="comment">///更新连通块最大值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(v, u)) flag = <span class="literal">true</span>;<span class="comment">///传递环信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        ans = <span class="built_in">max</span>(&#123; ans,u,v &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ans++;<span class="comment">///表示不能到达的第一个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= ans - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            maxn = i;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>)) ans = <span class="built_in">min</span>(ans, maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///如果没访问，且所在连通块无环，则仅最大数一定不可达，更新为ans</span></span><br><span class="line">    <span class="comment">///其他数如果之前的数都可达，则一定可达，因此访问过的不需要再次访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">///遍历区间后能确定ans</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">10007</span>];</span><br><span class="line"><span class="type">int</span> maxn[<span class="number">10007</span>];<span class="comment">///维护连通块最大值</span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">10007</span>];<span class="comment">///维护环信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ru = <span class="built_in">find</span>(u);</span><br><span class="line">    <span class="type">int</span> rv = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (ru == rv) flag[ru] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fa[ru] = rv;</span><br><span class="line">        maxn[rv] = <span class="built_in">max</span>(maxn[ru], maxn[rv]);</span><br><span class="line">        flag[rv] |= flag[ru];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10000</span>;i++) fa[i] = i, maxn[i] = i;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">merge</span>(u, v);</span><br><span class="line">        ans = <span class="built_in">max</span>(&#123; ans,u,v &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ans++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= ans - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i &amp;&amp; !flag[i]) ans = <span class="built_in">min</span>(ans, maxn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三-1"><a href="#方法三-1" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (!vis[<span class="built_in">min</span>(u, v)]) vis[<span class="built_in">min</span>(u, v)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> vis[<span class="built_in">max</span>(u, v)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (vis[ans]) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20566&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="DFS" scheme="https://blankyang233.github.io/tags/DFS/"/>
    
    <category term="图论" scheme="https://blankyang233.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
</feed>
