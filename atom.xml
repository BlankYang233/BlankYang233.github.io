<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空白のBlog</title>
  
  <subtitle>For the future</subtitle>
  <link href="https://blankyang233.github.io/atom.xml" rel="self"/>
  
  <link href="https://blankyang233.github.io/"/>
  <updated>2022-07-10T16:03:09.066Z</updated>
  <id>https://blankyang233.github.io/</id>
  
  <author>
    <name>空白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDU3038 How Many Answers Are Wrong</title>
    <link href="https://blankyang233.github.io/2022/07/11/HDU3038%20How%20Many%20Answers%20Are%20Wrong/"/>
    <id>https://blankyang233.github.io/2022/07/11/HDU3038%20How%20Many%20Answers%20Are%20Wrong/</id>
    <published>2022-07-10T16:01:38.000Z</published>
    <updated>2022-07-10T16:03:09.066Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Problem Description</strong></p><p>TT and FF are … friends. Uh… very very good friends -________-b</p><p>FF is a bad boy, he is always wooing TT to play the following game with him. This is a very humdrum game. To begin with, TT should write down a sequence of integers-_-!!(bored).<br><img src="http://acm.hdu.edu.cn/data/images/exe3038-1.JPG" alt="img"><br>Then, FF can choose a continuous subsequence from it(for example the subsequence from the third to the fifth integer inclusively). After that, FF will ask TT what the sum of the subsequence he chose is. The next, TT will answer FF’s question. Then, FF can redo this process. In the end, FF must work out the entire sequence of integers.</p><p>Boring~~Boring~~a very very boring game!!! TT doesn’t want to play with FF at all. To punish FF, she often tells FF the wrong answers on purpose.</p><p>The bad boy is not a fool man. FF detects some answers are incompatible. Of course, these contradictions make it difficult to calculate the sequence.</p><p>However, TT is a nice and lovely girl. She doesn’t have the heart to be hard on FF. To save time, she guarantees that the answers are all right if there is no logical mistakes indeed.</p><p>What’s more, if FF finds an answer to be wrong, he will ignore it when judging next answers.</p><p>But there will be so many questions that poor FF can’t make sure whether the current answer is right or wrong in a moment. So he decides to write a program to help him with this matter. The program will receive a series of questions from FF together with the answers FF has received from TT. The aim of this program is to find how many answers are wrong. Only by ignoring the wrong answers can FF work out the entire sequence of integers. Poor FF has no time to do this job. And now he is asking for your help~(Why asking trouble for himself~~Bad boy)</p><p><strong>Input</strong></p><p>Line 1: Two integers, N and M (1 &lt;&#x3D; N &lt;&#x3D; 200000, 1 &lt;&#x3D; M &lt;&#x3D; 40000). Means TT wrote N integers and FF asked her M questions.</p><p>Line 2..M+1: Line i+1 contains three integer: Ai, Bi and Si. Means TT answered FF that the sum from Ai to Bi is Si. It’s guaranteed that 0 &lt; Ai &lt;&#x3D; Bi &lt;&#x3D; N.</p><p>You can assume that any sum of subsequence is fit in 32-bit integer.</p><p><strong>Output</strong></p><p>A single line with a integer denotes how many answers are wrong.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 10 100</span><br><span class="line">7 10 28</span><br><span class="line">1 3 32</span><br><span class="line">4 6 41</span><br><span class="line">6 6 1</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>Source</strong></p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2009+Multi-University+Training+Contest+13+-+Host+by+HIT&source=1&searchmode=source">2009 Multi-University Training Contest 13 - Host by HIT</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>因为给出的是区间和，我们拆分成两端前缀和方便用带权并查集维护。</p><p>依然用向量的思想会很好理解合并和压缩过程中的计算。</p><p>时间复杂度 $O(n+m\log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">200007</span>], sum[<span class="number">200007</span>];<span class="comment">///sum[i] 指 (i,根节点]的和</span></span><br><span class="line"><span class="comment">///可以理解为一个点到点的向量长度，这样就可以用向量加减理解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> pre = fa[x];</span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    sum[x] += sum[pre];<span class="comment">///递归求和，路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<span class="comment">///不是我的锅，是他没写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++) fa[i] = i, sum[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="type">int</span> a, b, S;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; S;</span><br><span class="line">            a--;</span><br><span class="line">            <span class="type">int</span> ra = <span class="built_in">find</span>(a);</span><br><span class="line">            <span class="type">int</span> rb = <span class="built_in">find</span>(b);</span><br><span class="line">            ll A = sum[a];</span><br><span class="line">            ll B = sum[b];</span><br><span class="line">            <span class="keyword">if</span> (ra == rb) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A - B != S) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum[ra] = B + S - A;<span class="comment">///(ra,rb]的大小,可以是逆序的，这样和就是相反数</span></span><br><span class="line">                fa[ra] = rb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3038&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ1984 Navigation Nightmare</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1984%20Navigation%20Nightmare/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1984%20Navigation%20Nightmare/</id>
    <published>2022-07-10T15:44:58.000Z</published>
    <updated>2022-07-10T15:45:44.326Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1984">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>Farmer John’s pastoral neighborhood has N farms (2 &lt;&#x3D; N &lt;&#x3D; 40,000), usually numbered&#x2F;labeled 1..N. A series of M (1 &lt;&#x3D; M &lt; 40,000) vertical and horizontal roads each of varying lengths (1 &lt;&#x3D; length &lt;&#x3D; 1000) connect the farms. A map of these farms might look something like the illustration below in which farms are labeled F1..F7 for clarity and lengths between connected farms are shown as (n):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F1 --- (13) ---- F6 --- (9) ----- F3</span><br><span class="line"> |                                 |</span><br><span class="line">(3)                                |</span><br><span class="line"> |                                (7)</span><br><span class="line">F4 --- (20) -------- F2            |</span><br><span class="line"> |                                 |</span><br><span class="line">(2)                               F5</span><br><span class="line"> | </span><br><span class="line">F7 </span><br></pre></td></tr></table></figure><p>Being an ASCII diagram, it is not precisely to scale, of course.</p><p>Each farm can connect directly to at most four other farms via roads that lead exactly north, south, east, and&#x2F;or west. Moreover, farms are only located at the endpoints of roads, and some farm can be found at every endpoint of every road. No two roads cross, and precisely one path<br>(sequence of roads) links every pair of farms.</p><p>FJ lost his paper copy of the farm map and he wants to reconstruct it from backup information on his computer. This data contains lines like the following, one for every road:</p><p>There is a road of length 10 running north from Farm #23 to Farm #17<br>There is a road of length 7 running east from Farm #1 to Farm #17<br>…</p><p>As FJ is retrieving this data, he is occasionally interrupted by questions such as the following that he receives from his navigationally-challenged neighbor, farmer Bob:</p><p>What is the Manhattan distance between farms #1 and #23?</p><p>FJ answers Bob, when he can (sometimes he doesn’t yet have enough data yet). In the example above, the answer would be 17, since Bob wants to know the “Manhattan” distance between the pair of farms.<br>The Manhattan distance between two points (x1,y1) and (x2,y2) is just |x1-x2| + |y1-y2| (which is the distance a taxicab in a large city must travel over city streets in a perfect grid to connect two x,y points).</p><p>When Bob asks about a particular pair of farms, FJ might not yet have enough information to deduce the distance between them; in this case, FJ apologizes profusely and replies with “-1”.</p><p><strong>Input</strong></p><ul><li><p>Line 1: Two space-separated integers: N and M</p></li><li><p>Lines 2..M+1: Each line contains four space-separated entities, F1,<br>F2, L, and D that describe a road. F1 and F2 are numbers of<br>two farms connected by a road, L is its length, and D is a<br>character that is either ‘N’, ‘E’, ‘S’, or ‘W’ giving the<br>direction of the road from F1 to F2.</p></li><li><p>Line M+2: A single integer, K (1 &lt;&#x3D; K &lt;&#x3D; 10,000), the number of FB’s<br>queries</p></li><li><p>Lines M+3..M+K+2: Each line corresponds to a query from Farmer Bob<br>and contains three space-separated integers: F1, F2, and I. F1<br>and F2 are numbers of the two farms in the query and I is the<br>index (1 &lt;&#x3D; I &lt;&#x3D; M) in the data after which Bob asks the<br>query. Data index 1 is on line 2 of the input data, and so on.</p></li></ul><p><strong>Output</strong></p><ul><li>Lines 1..K: One integer per line, the response to each of Bob’s<br>queries.  Each line should contain either a distance<br>measurement or -1, if it is impossible to determine the<br>appropriate distance.</li></ul><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7 6</span><br><span class="line">1 6 13 E</span><br><span class="line">6 3 9 E</span><br><span class="line">3 5 7 S</span><br><span class="line">4 1 3 N</span><br><span class="line">2 4 20 W</span><br><span class="line">4 7 2 S</span><br><span class="line">3</span><br><span class="line">1 6 1</span><br><span class="line">1 4 3</span><br><span class="line">2 6 6</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">-1</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>Hint</strong></p><p>At time 1, FJ knows the distance between 1 and 6 is 13.<br>At time 3, the distance between 1 and 4 is still unknown.<br>At the end, location 6 is 3 units west and 7 north of 2, so the distance is 10.</p><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=USACO+2004+February">USACO 2004 February</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>显然用带权并查集维护子节点到根节点的坐标变化。</p><p>考虑用 $x$ 代表东西方向位移 ，$y$ 代表南北方向位移，取北和东为正方向。</p><p>压缩路径和合并都可以向量理解：</p><p>压缩路径，$\vec{ar} &#x3D; \vec{ab} + \vec{br}$ ，其中 $a$ 是待压缩节点，$b$ 是父节点，$r$ 是根节点。</p><p>合并集合，$\vec{AB} &#x3D; -\vec{aA} + \vec{ab} + \vec{bB}$ ，$a$ 和 $b$ 是条件给出节点，$A$ 和 $B$ 是条件节点所在集合的根节点，目的是把 $A$ 合并到 $B$。</p><p>输入输出极度复杂，需要先保存信息，再离线处理，在每个时间点记录答案，最后输出。</p><p>时间复杂度 $O(n + m\log n + k\log k)$</p><p>空间复杂度 $O(n+m+k)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;v[<span class="number">40007</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">40007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info1</span> &#123;</span><br><span class="line">    <span class="type">int</span> f1, f2, l;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125;in1[<span class="number">40007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info2</span> &#123;</span><br><span class="line">    <span class="type">int</span> f1, f2, t, id;</span><br><span class="line">&#125;in2[<span class="number">40007</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">40007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> pre = fa[x];</span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    v[x].x += v[pre].x;</span><br><span class="line">    v[x].y += v[pre].y;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Info2 a, Info2 b)</span> </span>&#123; <span class="keyword">return</span> a.t &lt; b.t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        cin &gt;&gt; in1[i].f1 &gt;&gt; in1[i].f2 &gt;&gt; in1[i].l &gt;&gt; in1[i].d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        cin &gt;&gt; in2[i].f1 &gt;&gt; in2[i].f2 &gt;&gt; in2[i].t;</span><br><span class="line">        in2[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(in2 + <span class="number">1</span>, in2 + <span class="number">1</span> + k, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>, pos = <span class="number">1</span>;t &lt;= m;t++) &#123;</span><br><span class="line">        <span class="type">int</span> r1 = <span class="built_in">find</span>(in1[t].f1);</span><br><span class="line">        <span class="type">int</span> r2 = <span class="built_in">find</span>(in1[t].f2);</span><br><span class="line">        <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;N&#x27;</span> || in1[t].d == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;N&#x27;</span>) y = in1[t].l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;S&#x27;</span>) y = -in1[t].l;</span><br><span class="line">            v[r1].x = -v[in1[t].f1].x + v[in1[t].f2].x;</span><br><span class="line">            v[r1].y = -v[in1[t].f1].y + y + v[in1[t].f2].y;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;E&#x27;</span> || in1[t].d == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;E&#x27;</span>) x = in1[t].l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (in1[t].d == <span class="string">&#x27;W&#x27;</span>) x = -in1[t].l;</span><br><span class="line">            v[r1].x = -v[in1[t].f1].x + x + v[in1[t].f2].x;</span><br><span class="line">            v[r1].y = -v[in1[t].f1].y + v[in1[t].f2].y;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[r1] = r2;</span><br><span class="line">        <span class="keyword">while</span> (t == in2[pos].t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(in2[pos].f1) == <span class="built_in">find</span>(in2[pos].f2)) &#123;</span><br><span class="line">                ans[in2[pos].id] = <span class="built_in">abs</span>(v[in2[pos].f1].x - v[in2[pos].f2].x) + <span class="built_in">abs</span>(v[in2[pos].f1].y - v[in2[pos].f2].y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ans[in2[pos].id] = <span class="number">-1</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1984&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ1417 True Liars</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1417%20True%20Liars/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1417%20True%20Liars/</id>
    <published>2022-07-10T15:29:25.000Z</published>
    <updated>2022-07-10T15:48:16.050Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1417">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>After having drifted about in a small boat for a couple of days, Akira Crusoe Maeda was finally cast ashore on a foggy island. Though he was exhausted and despaired, he was still fortunate to remember a legend of the foggy island, which he had heard from patriarchs in his childhood. This must be the island in the legend. In the legend, two tribes have inhabited the island, one is divine and the other is devilish, once members of the divine tribe bless you, your future is bright and promising, and your soul will eventually go to Heaven, in contrast, once members of the devilish tribe curse you, your future is bleak and hopeless, and your soul will eventually fall down to Hell.</p><p>In order to prevent the worst-case scenario, Akira should distinguish the devilish from the divine. But how? They looked exactly alike and he could not distinguish one from the other solely by their appearances. He still had his last hope, however. The members of the divine tribe are truth-tellers, that is, they always tell the truth and those of the devilish tribe are liars, that is, they always tell a lie.</p><p>He asked some of them whether or not some are divine. They knew one another very much and always responded to him “faithfully” according to their individual natures (i.e., they always tell the truth or always a lie). He did not dare to ask any other forms of questions, since the legend says that a devilish member would curse a person forever when he did not like the question. He had another piece of useful informationf the legend tells the populations of both tribes. These numbers in the legend are trustworthy since everyone living on this island is immortal and none have ever been born at least these millennia.</p><p>You are a good computer programmer and so requested to help Akira by writing a program that classifies the inhabitants according to their answers to his inquiries.</p><p><strong>Input</strong></p><p>The input consists of multiple data sets, each in the following format :</p><p>n p1 p2<br>xl yl a1<br>x2 y2 a2<br>…<br>xi yi ai<br>…<br>xn yn an</p><p>The first line has three non-negative integers n, p1, and p2. n is the number of questions Akira asked. pl and p2 are the populations of the divine and devilish tribes, respectively, in the legend. Each of the following n lines has two integers xi, yi and one word ai. xi and yi are the identification numbers of inhabitants, each of which is between 1 and p1 + p2, inclusive. ai is either yes, if the inhabitant xi said that the inhabitant yi was a member of the divine tribe, or no, otherwise. Note that xi and yi can be the same number since “are you a member of the divine tribe?” is a valid question. Note also that two lines may have the same x’s and y’s since Akira was very upset and might have asked the same question to the same one more than once.</p><p>You may assume that n is less than 1000 and that p1 and p2 are less than 300. A line with three zeros, i.e., 0 0 0, represents the end of the input. You can assume that each data set is consistent and no contradictory answers are included.</p><p><strong>Output</strong></p><p>For each data set, if it includes sufficient information to classify all the inhabitants, print the identification numbers of all the divine ones in ascending order, one in a line. In addition, following the output numbers, print end in a line. Otherwise, i.e., if a given data set does not include sufficient information to identify all the divine members, print no in a line.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2 1 1</span><br><span class="line">1 2 no</span><br><span class="line">2 1 no</span><br><span class="line">3 2 1</span><br><span class="line">1 1 yes</span><br><span class="line">2 2 yes</span><br><span class="line">3 3 yes</span><br><span class="line">2 2 1</span><br><span class="line">1 2 yes</span><br><span class="line">2 3 no</span><br><span class="line">5 4 3</span><br><span class="line">1 2 yes</span><br><span class="line">1 3 no</span><br><span class="line">4 5 yes</span><br><span class="line">5 6 yes</span><br><span class="line">6 7 no</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">end</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=Japan+2002+Kanazawa">Japan 2002 Kanazawa</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：并查集，背包dp。</strong></p><p>这题第一眼看上去用扩展域并查集能做，但确实能做，就是烦死人。因为扩展域并查集不记录元素之间的相对关系，之后不是判断条件矛盾，而是需要把每个关系集合的各类人数具体记录，因此一开始就记录在一个关系集合的带权并查集会更好，免去了查找某个元素在哪个关系集合的麻烦。</p><p>时间复杂度 $O(n\log(p_1+p_2) + np_1+p_2)$</p><p>空间复杂度 $O(p_1\cdot (p_1+p_2))$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：并查集，背包dp。</strong></p><p>用带权并查集是最优解，在处理完关系后能直接分类。随后是一个简单的计数dp，如果 $dp[tot][p1] &#x3D; 1$ 则说明有且仅有一种方法能凑成 $p1$ 的好人，所以是可行的，然后逆推求每次选择在各个关系集合选择类别，最后遍历编号，输出对应集合选择类别和自己相应的人的编号即可。</p><p>时间复杂度 $O(n\log(p_1+p_2) + np_1 + p_2)$</p><p>空间复杂度 $O(p_1\cdot (p_1+p_2))$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">1207</span>], feat[<span class="number">607</span>], num[<span class="number">1207</span>], cnt[<span class="number">607</span>][<span class="number">2</span>], dp[<span class="number">607</span>][<span class="number">607</span>], ans[<span class="number">607</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, p1, p2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; p1 &gt;&gt; p2, n || p1 || p2) &#123;</span><br><span class="line">        <span class="type">int</span> m = p1 + p2;</span><br><span class="line">        <span class="built_in">memset</span>(feat, <span class="number">0</span>, <span class="built_in">sizeof</span>(feat));</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span> * m;i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            string a;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; a;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&quot;yes&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x, y);</span><br><span class="line">                <span class="built_in">merge</span>(x + m, y + m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">&quot;no&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x, y + m);</span><br><span class="line">                <span class="built_in">merge</span>(x + m, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///扩展域（种类）并查集把每个元素的所有可能扩展为一个独立的种类元素，将等价的种类元素（必然同时出现）放入一个集合，构成</span></span><br><span class="line">        <span class="comment">///因为种类元素列出了所有可能，故可以容易检验新关系的合法性，只需检验与新关系矛盾的所有集合是否存在</span></span><br><span class="line">        <span class="comment">///因为构造了等价类，所以容易检验元素的等价关系（能否同时出现），但访问在同一关系集合中原元素的互相的具体种类关系需要划分等价类</span></span><br><span class="line">        <span class="comment">///确立一个标准等价类，其他同一关系集合的等价类元素以此基准分类，难点在需要检验标准等价类是否已经存在</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///带权并查集将同一关系集合的元素放入一个集合，用权值确定一个集合的元素互相的具体种类关系，使得划分了等价类非常容易</span></span><br><span class="line">        <span class="comment">///通过权值可以容易检验新关系的合法性，可以容易访问元素的种类关系（等价关系更容易）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num[<span class="built_in">find</span>(i)] &amp;&amp; !num[<span class="built_in">find</span>(i + m)]) num[<span class="built_in">find</span>(i)] = ++tot;</span><br><span class="line">            <span class="keyword">if</span> (!num[<span class="built_in">find</span>(i)]) feat[i] = <span class="number">1</span>, cnt[num[<span class="built_in">find</span>(i + m)]][<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!num[<span class="built_in">find</span>(i + m)]) feat[i] = <span class="number">0</span>, cnt[num[<span class="built_in">find</span>(i)]][<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///如果自己等价类和其他同一关系集合的等价类都没编号，则给自己等价类记录编号，自己等价类和其他等价类有且仅有一个有编号，作为基准</span></span><br><span class="line">        <span class="comment">///权值是相对于基准等价类</span></span><br><span class="line">        <span class="comment">///如果自己集合没编号，则自己在标准等价类的同一关系集合下的其他等价类，根据种类位置，种类值为1</span></span><br><span class="line">        <span class="comment">///如果自己集合有编号，则自己在标准等价类，因此种类值为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= p1;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cnt[i][<span class="number">0</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cnt[i][<span class="number">1</span>]) dp[i][j] += dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">1</span>]];</span><br><span class="line">            &#125;<span class="comment">///简单的计数DP</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[tot][p1] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = tot, j = p1;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]]) ans[i] = <span class="number">0</span>, j -= cnt[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> ans[i] = <span class="number">1</span>, j -= cnt[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (feat[i] == ans[num[<span class="built_in">find</span>(i)] ? num[<span class="built_in">find</span>(i)] : num[<span class="built_in">find</span>(i + m)]]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">///扩展域并查集遗留问题，没有把同一关系集合元素放在一起</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">607</span>], num[<span class="number">607</span>], cnt[<span class="number">607</span>][<span class="number">2</span>], dp[<span class="number">607</span>][<span class="number">607</span>], ans[<span class="number">607</span>];</span><br><span class="line"><span class="type">bool</span> v[<span class="number">607</span>];<span class="comment">///0表示与父节点同类，1表示异类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> pre = fa[x];</span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    v[x] ^= v[pre];</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, p1, p2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; p1 &gt;&gt; p2, n || p1 || p2) &#123;</span><br><span class="line">        <span class="type">int</span> m = p1 + p2;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            string a;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; a;</span><br><span class="line">            <span class="type">bool</span> z = a == <span class="string">&quot;no&quot;</span>;</span><br><span class="line">            <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">            v[rx] = v[x] ^ z ^ v[y];</span><br><span class="line">            fa[rx] = ry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="type">int</span> ri = <span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!num[ri]) num[ri] = ++tot;</span><br><span class="line">            cnt[num[ri]][v[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= p1;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cnt[i][<span class="number">0</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cnt[i][<span class="number">1</span>]) dp[i][j] += dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[tot][p1] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = tot, j = p1;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]]) ans[i] = <span class="number">0</span>, j -= cnt[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> ans[i] = <span class="number">1</span>, j -= cnt[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i] == ans[num[<span class="built_in">find</span>(i)]]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1417&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="背包dp" scheme="https://blankyang233.github.io/tags/%E8%83%8C%E5%8C%85dp/"/>
    
  </entry>
  
  <entry>
    <title>POJ1456 Supermarket</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1456%20Supermarket/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1456%20Supermarket/</id>
    <published>2022-07-10T15:15:16.000Z</published>
    <updated>2022-07-10T15:16:41.790Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1456">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>A supermarket has a set Prod of products on sale. It earns a profit px for each product x∈Prod sold by a deadline dx that is measured as an integral number of time units starting from the moment the sale begins. Each product takes precisely one unit of time for being sold. A selling schedule is an ordered subset of products Sell ≤ Prod such that the selling of each product x∈Sell, according to the ordering of Sell, completes before the deadline dx or just when dx expires. The profit of the selling schedule is Profit(Sell)&#x3D;Σx∈Sellpx. An optimal selling schedule is a schedule with a maximum profit. </p><p>For example, consider the products Prod&#x3D;{a,b,c,d} with (pa,da)&#x3D;(50,2), (pb,db)&#x3D;(10,1), (pc,dc)&#x3D;(20,2), and (pd,dd)&#x3D;(30,1). The possible selling schedules are listed in table 1. For instance, the schedule Sell&#x3D;{d,a} shows that the selling of product d starts at time 0 and ends at time 1, while the selling of product a starts at time 1 and ends at time 2. Each of these products is sold by its deadline. Sell is the optimal schedule and its profit is 80.</p><p> <img src="http://poj.org/images/1456_1.jpg" alt="img"> </p><p>Write a program that reads sets of products from an input text file and computes the profit of an optimal selling schedule for each set of products.</p><p><strong>Input</strong></p><p>A set of products starts with an integer 0 &lt;&#x3D; n &lt;&#x3D; 10000, which is the number of products in the set, and continues with n pairs pi di of integers, 1 &lt;&#x3D; pi &lt;&#x3D; 10000 and 1 &lt;&#x3D; di &lt;&#x3D; 10000, that designate the profit and the selling deadline of the i-th product. White spaces can occur freely in input. Input data terminate with an end of file and are guaranteed correct.</p><p><strong>Output</strong></p><p>For each set of products, the program prints on the standard output the profit of an optimal selling schedule for the set. Each result is printed from the beginning of a separate line.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4  50 2  10 1   20 2   30 1</span><br><span class="line"></span><br><span class="line">7  20 1   2 1   10 3  100 2   8 2</span><br><span class="line">   5 20  50 10</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">80</span><br><span class="line">185</span><br></pre></td></tr></table></figure><p><strong>Hint</strong></p><p>The sample input contains two product sets. The first set encodes the products from table 1. The second set is for 7 products. The profit of an optimal schedule for these products is 185.</p><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=Southeastern+Europe+2003">Southeastern Europe 2003</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：并查集，贪心。</strong></p><p>这道题和并查集结合起来还是挺妙的。</p><p>首先考虑一个贪心，每次先安排价值最高的。如此选择，如果一个货物在期限之前无法安排，那说明其期限之前的所有天数都被比他价值高的货物占据了，此时这个货物可以被抛弃，强行售出只会降低总收益。</p><p>为了判断货物是否存在某天能够被安排，需要知道其距离期限最近的一个可用天数，因为如果选过早的话，可能会把其他期限靠前的货物的机会使用掉。考虑使用并查集维护从过期时间向前数的第一个未占用位置，如果第一个未被占用位置为 $0$ 则说明没有位置。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：贪心，优先队列。</strong></p><p>典型的后悔贪心题。花费是常数 $1$ ，限制和收益是变量。使用小顶堆维护后悔操作，按从限制从小到大排序入队。</p><p>时间复杂度 $O(n\log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, d;</span><br><span class="line">&#125;a[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.p &gt; b.p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1e4</span>;i++) fa[i] = i;<span class="comment">///注意是天数的集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)  cin &gt;&gt; a[i].p &gt;&gt; a[i].d;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">find</span>(a[i].d);</span><br><span class="line">            <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                <span class="built_in">merge</span>(r, r - <span class="number">1</span>);<span class="comment">///以之前的第一个可用天为根，即把之前的第一个可用天当作从此天开始的可用天</span></span><br><span class="line">                sum += a[i].p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, d;</span><br><span class="line">&#125;a[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> a.d &lt; b.d; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i].p &gt;&gt; a[i].d;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; pq;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(a[i].p);</span><br><span class="line">            sum += a[i].p;</span><br><span class="line">            <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; a[i].d) &#123;</span><br><span class="line">                sum -= pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1456&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC235745 拆路</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC235745%20%E6%8B%86%E8%B7%AF/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC235745%20%E6%8B%86%E8%B7%AF/</id>
    <published>2022-07-10T14:05:46.000Z</published>
    <updated>2022-07-10T15:53:41.035Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/235745">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  有 $n$ 个城镇，城镇之间有 $m$ 条道路相连，道路可以看成无向边。每一个城镇都有自己的一个繁荣度 $v_i$ ，一个城镇 $u$ 受到的影响 $p$ 是与$u$ 直接或者间接相连的所有城镇中，繁荣度的最大值。一个城镇 $u$ 与城镇 $v$ 是被视为直接或者间接相连的，当且仅当 $u&#x3D;v$ 或者从 $u$ 出发，可以沿着某些道路到达 $v$ 。为了减少维护成本，现准备拆除其中的某一些路。具体来说，你需要维护以下两种操作：  </p><ol><li>​    ‘Q’ $a$，询问 $a$ 城镇受到的影响 $p$ ；    </li><li>​    ‘D’ $a\ b$ ，删除 $a\ b$ 之间的道路。</li></ol><p><strong>输入描述</strong></p><p>第一行输入两个整数 $n,m(1\le n,m \le 10^5)$ ，分别表示城镇的数量和道路的数量。第二行输入 $n$ 个整数 $v_1,v_2,…,v_n(1\le v_i \le 10^9)$ ，分别表示每一个城镇的繁荣度。接下来 $m$ 行，每行两个整数 $u,v(1\le u,v \le n)$ ，表示城镇 $u,v$ 之间有一条道路连接。保证不含有重边、自环。<br>接下来一行，输入一个整数 $Q(1\le Q \le 10^5)$ ，表示操作的个数。<br>接下来 $Q$ 行，每行描述一个操作，以’Q’  $a(1\le a \le n)$ 或者’D’ $a\ b(1\le a,b \le n)$ 的形式给出。对于删除操作，保证被删除的道路是存在的。</p><p><strong>输出描述</strong></p><p>对于每一个操作1，你都需要输出一个整数 $p$ ，表示城镇 $a$ 受到的影响。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4</span><br><span class="line">Q 1</span><br><span class="line">D 2 3</span><br><span class="line">Q 1</span><br><span class="line">Q 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集，离线。</strong></p><p>普通并查集不支持撤销操作，这使得这道题难以解答，但转换一下思路，撤销的逆过程是新增，是并查集适用的操作，于是可以保存所有访问数据，离线逆向处理，再将答案保存最后输出即可。</p><p>时间复杂度 $O((m \log n + q)\log q + n)$</p><p>空间复杂度 $O(q+n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> u[<span class="number">100007</span>], v[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> du[<span class="number">100007</span>], dv[<span class="number">100007</span>];</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; s;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (w[rx] &lt; w[ry]) fa[rx] = ry;</span><br><span class="line">    <span class="keyword">else</span> fa[ry] = rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cin &gt;&gt; u[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;Q&#x27;</span>) cin &gt;&gt; du[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; du[i] &gt;&gt; dv[i];</span><br><span class="line">            s.<span class="built_in">insert</span>(&#123; du[i],dv[i] &#125;);</span><br><span class="line">            s.<span class="built_in">insert</span>(&#123; dv[i],du[i] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(&#123; u[i],v[i] &#125;) == s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">merge</span>(u[i], v[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = q;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dv[i]) <span class="built_in">merge</span>(du[i], dv[i]);</span><br><span class="line">        <span class="keyword">else</span> ans[i] = w[<span class="built_in">find</span>(du[i])];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/235745&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="离线" scheme="https://blankyang233.github.io/tags/%E7%A6%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>NC51097 Parity game</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC51097%20Parity%20game/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC51097%20Parity%20game/</id>
    <published>2022-07-10T13:45:16.000Z</published>
    <updated>2022-07-10T15:09:57.450Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/51097">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Now and then you play the following game with your friend. Your friend writes down a sequence consisting of zeroes and ones. You choose a continuous subsequence (for example the subsequence from the third to the fifth digit inclusively) and ask him, whether this subsequence contains even or odd number of ones. Your friend answers your question and you can ask him about another subsequence and so on. Your task is to guess the entire sequence of numbers.<br> You suspect some of your friend’s answers may not be correct and you want to convict him of falsehood. Thus you have decided to write a program to help you in this matter. The program will receive a series of your questions together with the answers you have received from your friend. The aim of this program is to find the first answer which is provably wrong, i.e. that there exists a sequence satisfying answers to all the previous questions, but no such sequence satisfies this answer.</p><p><strong>输入描述</strong></p><p>The first line of input contains one number, which is the length of the sequence of zeroes and ones. This length is less or equal to 1000000000. In the second line, there is one positive integer which is the number of questions asked and answers to them. The number of questions and answers is less or equal to 5000. The remaining lines specify questions and answers. Each line contains one question and the answer to this question: two integers (the position of the first and last digit in the chosen subsequence) and one word which is either <code>even</code> or <code>odd</code> (the answer, i.e. the parity of the number of ones in the chosen subsequence, where <code>even</code> means an even number of ones and <code>odd</code> means an odd number).</p><p><strong>输出描述</strong></p><p>There is only one line in output containing one integer X. Number X says that there exists a sequence of zeroes and ones satisfying first X parity conditions, but there exists none satisfying X+1 conditions. If there exists a sequence of zeroes and ones satisfying all the given conditions, then number X should be the number of all the questions asked.</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5</span><br><span class="line">1 2 even</span><br><span class="line">3 4 odd</span><br><span class="line">5 6 even</span><br><span class="line">1 6 even</span><br><span class="line">7 10 odd</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>每次条件给出了一个区间 $[l,r]$ 的 $01$ 串中 $1$ 的个数是奇数还是偶数，区间很难处理，但我们可以转化为 $sum[r]-sum[l-1]$ ，即 $sum[i]$ 表示 $[1,i]$ 之间 $1$ 的个数。若 $[l,r]$ 是偶数，则 $sum[r]$ 和 $sum[l-1]$ 一定是同奇偶；否则就是异奇偶。</p><p>如此就转换成端点的种类的相对关系了，而且题目只需要我们检查条件矛盾个数，那就自然而然使用扩展域并查集。</p><p>由于节点编号很大，采用遇到一个节点初始化一个节点的策略，并用 $map$ 离散化记录。</p><p>时间复杂度 $O(q \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; fa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    n++;<span class="comment">///范围从0开始到n</span></span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>;cnt &lt; q;cnt++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (!fa.<span class="built_in">count</span>(x - <span class="number">1</span>)) fa[x - <span class="number">1</span>] = x - <span class="number">1</span>, fa[x - <span class="number">1</span> + n] = x - <span class="number">1</span> + n;</span><br><span class="line">        <span class="keyword">if</span> (!fa.<span class="built_in">count</span>(y)) fa[y] = y, fa[y + n] = y + n;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;even&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x - <span class="number">1</span>) == <span class="built_in">find</span>(y + n)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span>, y);</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span> + n, y + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;odd&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x - <span class="number">1</span>) == <span class="built_in">find</span>(y)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span>, y + n);</span><br><span class="line">                <span class="built_in">merge</span>(x - <span class="number">1</span> + n, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/51097&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC16884 [NOI2001]食物链</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC16884%20[NOI2001]%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC16884%20[NOI2001]%E9%A3%9F%E7%89%A9%E9%93%BE/</id>
    <published>2022-07-10T13:31:16.000Z</published>
    <updated>2022-07-10T15:50:38.447Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16884">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。 </p><p>  现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 </p><p>  有人用两种说法对这N个动物所构成的食物链关系进行描述： </p><p>  第一种说法是“1 X Y”，表示X和Y是同类。 </p><p>  第二种说法是“2 X Y”，表示X吃Y。 </p><p>  此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 </p><p>  1） 当前的话与前面的某些真的话冲突，就是假话； </p><p>  2） 当前的话中X或Y比N大，就是假话； </p><p>  3） 当前的话表示X吃X，就是假话。 </p><p>  你的任务是根据给定的N（1≤N≤50,000）和K句话（0≤K≤100,000），输出假话的总数。 </p><p><strong>输入描述</strong></p><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D&#x3D;1，则表示X和Y是同类。<br>若D&#x3D;2，则表示X吃Y。</p><p><strong>输出描述</strong></p><p>只有一个整数，表示假话的数目。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1   </span><br><span class="line">2 1 2     </span><br><span class="line">2 2 3     </span><br><span class="line">2 3 3     </span><br><span class="line">1 1 3     </span><br><span class="line">2 3 1     </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p> <img src="https://uploadfiles.nowcoder.com/images/20180701/305473_1530452990874_8C754812CCEC7267CC44FF197D74283A" alt="img"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：并查集。</strong></p><p>用权值代表其关于根节点的种类，根节点设为 $0$ ，其他的同类为 $0$ ，根节点是猎物为 $1$ ，根节点是天敌为 $2$ 。</p><p>因为种类形成环状具有传递性关系，因此路径压缩可以利用自身权值加父节点路径压缩后的权值对 $3$ 取模即可，递归实现。</p><p>合并集合时，已知两个节点 $a$ 和 $b$ 路径压缩后的权值以及$a$ 关于 $b$ 的权值，要求出集合根节点 $A$ 认 $B$ 为父后的权值，因为具有环状传递性，所以可以利用向量的思想，$\vec{AB} &#x3D; -\vec{aA}+\vec{ab}+\vec{bB}$ ，随后对 $|\vec{AB}|$ 模 $3$ 即可，注意不要出现负数。</p><p>如果给出的关系的两个对象已经在同一个关系集合，那么检查他们关系是否和给出的条件吻合，即 $\vec{ab} &#x3D;&#x3D; \vec{aA} - \vec{bA}$ ，左边是条件右边是已有的关系，不吻合的答案加一。</p><p>时间复杂度 $O(k\log n + n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：并查集。</strong></p><p>实际上第一种解法较为繁琐，我们只关心条件之间是否矛盾，即给出的条件的两个对象已经建立了关系，检测已有关系和给出的关系是否矛盾。因此可以用扩展域并查集，其把元素的所有可能种类扩展各个独立元素，只对有具体种类的元素建立关系集合中的具体等价类（等价类的元素会同时出现），而不把相关的具体等价类并在一个集合产生完整的关系集合，利用权值进行相对分类（带权并查集是记录了一整个关系集合，并用权值做了相对根节点的关系划分），而这对于检测矛盾已经足够了。</p><p>具体地说，一个动物元素只有三种种类，我们记为 $A$，$B$，$C$，其中 $A$ 吃 $B$ ， $B$ 吃 $C$ ， $C$ 吃 $A$ 。扩展域并查集把每个动物元素扩展成这 $3$ 个有具体种类的动物元素，分别放在 $[1,n],[n+1,2n],[2n+1，3n] $ 中。</p><p>假设给出 $a$ 吃 $b$，则会合并三个等价类 $[a]$ 与 $[b+n]$ ， $[a+n]$ 与 $[b+2n]$ ， $[a+2n]$ 与 $[b]$ ，表示 $a$ 是 $A$ 时 $b$ 一定是 $B$， $a$ 是 $B$ 时 $b$ 一定是 $C$，$a$ 是 $C$ 时 $b$ 一定是 $A$ ，这样就根据条件合并了两个对象的三组具体种类的等价类。注意一个条件一定能合并三组等价类，因为这三个等价类是一个关系集合的三个具体种类表现，同样的一个等价类出现一定有其余两个等价类，且他们种类刚好补全所有情况。比如， $[a] &#x3D; [b]$ 出现则一定有 $[a+n] &#x3D; [b+n]$ 和 $[a+2n] &#x3D; [b +2n]$，因为他们是一个同一个相对关系（同类）的三个具体表现。</p><p>另一方面，对于 $a$ 吃 $b$ 的条件，如果它们已经在一个关系集合（已有相对关系），则它们之间一定产生了三个等价类，而如果这些等价类刚好是 $[a] &#x3D; [b]$ 或者 $[a] &#x3D; [b+2n]$ ，即表达 $a$ 与 $b$ 同类或者 $a$ 的天敌是 $b$ 就很容易判断出已知条件与给出的这个条件矛盾。</p><p>因此，扩展域并查集能够维护元素不同种类之间同时出现的集合，即等价类，容易直接判断出条件是否矛盾。但弊端也很明显，只适合检验某个条件相对关系是否满足现有关系，而不能直接列举出元素的相对关系，因为扩展域并查集只保存了元素具体种类的等价关系，而没有完整记录元素在关系集合中的相对关系，导致等价类之间是割裂的，没有直接相关性的。比如我想要知道动物 $a$ 和 动物 $b$ 的相对关系，就得先拿 $a$ 的某个种类所在的等价类集合作为一个基准集合，再枚举 $b$ 的所有种类($A,B,C$)是否处在这个基准集合，如果有关系则有且仅有一个具体种类处在基准集合进而判断其相对关系，而都没有处在基准集合说明 $a$ 和 $b$ 尚未建立关系。这个过程带权并查集能在合并和查询过程中直接实现，因此如果题目要求并不是检验条件矛盾这么简单的话，比如要求得知 $a$ 和 $b$ 的相对关系用以后续解题，那带权并查集会更加合适。</p><p>时间复杂度 $O(k\log n + n)$</p><p>空间复杂度 $O(n)$ ，实际上是三倍空间</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">50007</span>], dist[<span class="number">50007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x) &#123;</span><br><span class="line">        <span class="type">int</span> pre = fa[x];</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(pre);</span><br><span class="line">        dist[x] = (dist[x] + dist[pre]) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="type">int</span> delta = (dist[x] - dist[y] + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span> delta == op;</span><br><span class="line">    fa[rx] = ry;</span><br><span class="line">    dist[rx] = (op - delta + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        op--;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">merge</span>(x, y, op)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);c = <span class="built_in">getchar</span>(); &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">150007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span> * n;i++) fa[i] = i;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> op = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n)ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + n) || <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + <span class="number">2</span> * n)) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">merge</span>(x, y), <span class="built_in">merge</span>(x + n, y + n), <span class="built_in">merge</span>(x + <span class="number">2</span> * n, y + <span class="number">2</span> * n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + <span class="number">2</span> * n) || <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">merge</span>(x, y + n), <span class="built_in">merge</span>(x + n, y + <span class="number">2</span> * n), <span class="built_in">merge</span>(x + <span class="number">2</span> * n, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16884&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC24608 [USACO 2011 Ope S]Learning Languages</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC24608%20[USACO%202011%20Ope%20S]Learning%20Languages/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC24608%20[USACO%202011%20Ope%20S]Learning%20Languages/</id>
    <published>2022-07-10T10:34:55.000Z</published>
    <updated>2022-07-10T15:52:29.592Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/24608">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Farmer John’s N (2 &lt;&#x3D; N &lt;&#x3D; 10,000) cows, conveniently numbered 1..N, are fluent in some M (1 &lt;&#x3D; M &lt;&#x3D; 30,000) languages, also conveniently numbered from 1..M. Cow i can speak in KiK_iKi (1 &lt;&#x3D; $K_i$ &lt;&#x3D; M) languages, namely $L_{i_1}, L_{i_2},…, L_{i_{K_i}}$ (1 &lt;&#x3D; $L_{i_j}$ &lt;&#x3D; M). FJ’s cows aren’t THAT smart, so the sum of $K_i$ over all cows i is at most 100,000.<br> Two cows can’t directly talk to each other unless both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows A and B can have a conversation if and only if there exists a sequence of cows $T_1, T_2, …, T_k$​ such that A and $T_1$​ share a language, $T_1$​ and $T_2$​ share a language, etc., and $T_k$​ and B share a language.<br> Farmer John wishes that his cows could be even more social, so he wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being a fairly frugal farmer, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:<br> * The minimum number of books he must purchase<br> * Any set of books assigned to cows in any order which will help him meet this goal; a program will grade your output.</p><p>  By way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone. </p><p> #1   #2   #3<br> Alberta           x    x<br> Bessie            x<br> Contessa     x</p><p> FJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.<br> Note that an alternate solution exists: instead, FJ could buy<br> Contessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.</p><p><strong>输入描述</strong></p><ul><li>Line 1: Two space-separated integers: N and M</li><li>Lines 2..N+1: Line i+1 describes the languages that cow i can speak with Ki+1K_i+1Ki+1 space-separated integers: $K_i$, $L_{i_1}, L_{i_2},…, L_{i_{K_i}}$.</li></ul><p><strong>输出描述</strong></p><ul><li>Line 1: A single integer that is the minimum number of books that FJ must purchase.</li><li>Lines 2..B+1: Line i+1 contains two space-separated integers: the language id # and the id # of the cow to receive book i. If multiple solutions exist, print any one.</li></ul><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 </span><br><span class="line">2 3 2 </span><br><span class="line">1 2 </span><br><span class="line">1 1 </span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>本题显然用并查集，但需要做扩展域。</p><p>牛与牛之间关系不是简单联系的，而是通过语言种类作为桥梁。因此将语言种类集合并入牛集合作为合并的桥梁集合，只要牛通过语言桥梁集合与另一只牛连通，即能够交流。</p><p>具体上，在牛的集合 $[1,n]$ 后加入语言集合 $[n+1,m]$ 即可，每次合并务必用牛作为根节点，是为了防止有些语言所有牛不会单独成为集合，干扰有效集合计数。只要把牛作为根节点，就只需要在 $[1,n]$ 计数，不会产生桥梁集合单独存在的问题。</p><p>最后牛区间中不同集合的数量减一，就是要连接的(牛-&gt;语言)边的数量。</p><p>时间复杂度 $O(nk\log (n+m)+m)$</p><p>空间复杂度 $P(n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">40007</span>];<span class="comment">///牛与书的扩展集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n + m;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="type">int</span> l;</span><br><span class="line">            cin &gt;&gt; l;</span><br><span class="line">            <span class="built_in">merge</span>(i, l + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;<span class="comment">///语言可能多出来</span></span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/24608&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC15976 小C的周末</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC15976%20%E5%B0%8FC%E7%9A%84%E5%91%A8%E6%9C%AB/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC15976%20%E5%B0%8FC%E7%9A%84%E5%91%A8%E6%9C%AB/</id>
    <published>2022-07-10T08:23:48.000Z</published>
    <updated>2022-07-10T08:24:14.514Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15976">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>愉快的周末到了，小C和他的N-1个朋友买了M个游戏，游戏编号从1~M。每个游戏都是多人游戏，他们打算周末一起打游戏。</p><p> 小C的每个朋友都决定好了要玩哪一款游戏（会有一组人打同一款游戏），并且每人手上都有一台游戏机，这种游戏机可以通过特定的游戏机连接线连接起来。</p><p> 但是，他们面临着一个问题：目前没有一个朋友的游戏机是互相连接的。所以它们必须用可用的游戏机连接线连接起来。小C决定依次使用第 i 条连接线把他的朋友 ui 和 vi 的游戏机连接起来。也就是说，假设有Q条连接线，小C只能先使用第一条，然后使用第二条，然后使用第三条。。。最后使用第Q条。</p><p> 一个游戏能开始的条件是所有玩这个游戏的朋友的游戏机都被连接起来（如果不是直接连接的话，那么就必须存在一条连接它们的路径）。他们希望尽快开始比赛。</p><p> 在每个游戏中，找出在添加了第几条连接线之后能开始游戏。如果在一个游戏中只有一个人玩，则输出0（因为他立马可以开始游戏）。如果不存在，则输出-1</p><p><strong>输入描述</strong></p><p>多组输入</p><p>第一行包含三个整数N，M，Q。</p><p>第二行给N个用空格分隔的整数，第 i 个整数代表第 i 个朋友想玩的游戏。</p><p>接下来的Q行，每行两个整数(u, v)，代表电线 i 连接的两个人的电脑</p><p>1 &lt;&#x3D; N, M &lt;&#x3D; 10^5<br>0 &lt;&#x3D; Q &lt;&#x3D; 10^5</p><p><strong>输出描述</strong></p><p>对于每个游戏，输出一个整数，表示添加了第几条连接线之后能开始游戏，每行以换行符结束</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 2 4</span><br><span class="line">1 2 2 2 1</span><br><span class="line">1 2 </span><br><span class="line">2 3</span><br><span class="line">1 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>第一个游戏有两个人参加（1，5），在添加了第三条电线之后他们电脑互相连接</p><p>第二个游戏三个人参加（2， 3， 4），在添加第四条电线之后他们电脑互相连接</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>这道题用单纯的并查集维护互联关系是不够的，需要权值去表达哪些有些连了那些人。由于每个人只可能玩一个游戏，那么只要计数相等那么就说明人齐了。</p><p>所以先用 $cnt[i]$ 记录第 $i$ 个游戏有多少人。权值用 $map$ 数组维护，$map[i]$ 代表第 $i$ 个人作为根节点时，其集合里游戏以及对应的人数。</p><p>合并时遍历被合并的权值 $map$ 加入父集合的权值 $map$ ，过程中用 $ans[i]$ 记录第 $i$ 个游戏在第几根线连接时能够开始游戏，因为要按游戏编号输出所以用游戏编号作为下标记下来。</p><p>最后按顺序输出 $ans$ 即可。</p><p>要注意有些游戏可能只有一个人，那么在输出时先判断是不是一个人，再输出 $0$ 即可；也有可能有些游戏没人玩，直接输出 $-1$ 。$ans$ 初始化为 $-1$ 因为某些游戏可能能玩的人到最后还不够所以没更改 $ans$ 就可以直接输出 $-1$。</p><p>注意是多组数据输入。</p><p>时间复杂度 $O(q\log n + (n+m)\log m)$</p><p>空间复杂度 $O(n+m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>], cnt[<span class="number">100007</span>], ans[<span class="number">100007</span>];<span class="comment">///fa表示连接起来的人，cnt记录每个游戏人数，ans记录答案因为最后按游戏排序</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp[<span class="number">100007</span>];<span class="comment">///mp[i][j] 第i个根节点的游戏种类及其对应数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i, mp[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            cin &gt;&gt; tmp;</span><br><span class="line">            cnt[tmp]++;</span><br><span class="line">            mp[i][tmp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>;t &lt;= q;t++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            u = <span class="built_in">find</span>(u);</span><br><span class="line">            v = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (mp[u].<span class="built_in">size</span>() &gt; mp[v].<span class="built_in">size</span>()) <span class="built_in">swap</span>(u, v);</span><br><span class="line">            fa[u] = v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp[u]) &#123;</span><br><span class="line">                mp[v][i] += j;</span><br><span class="line">                <span class="keyword">if</span> (mp[v][i] == cnt[i]) ans[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &lt;= <span class="number">1</span>) cout &lt;&lt; cnt[i] - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15976&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ1988 Cube Stacking</title>
    <link href="https://blankyang233.github.io/2022/07/10/POJ1988%20Cube%20Stacking/"/>
    <id>https://blankyang233.github.io/2022/07/10/POJ1988%20Cube%20Stacking/</id>
    <published>2022-07-10T08:05:22.000Z</published>
    <updated>2022-07-10T15:49:39.672Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1988">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Description</strong></p><p>Farmer John and Betsy are playing a game with N (1 &lt;&#x3D; N &lt;&#x3D; 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;&#x3D; P &lt;&#x3D; 100,000) operation. There are two types of operations:<br>moves and counts.<br>* In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.<br>* In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.</p><p>Write a program that can verify the results of the game.</p><p>Input</p><p>* Line 1: A single integer, P</p><p>* Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.</p><p>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.</p><p>Output</p><p>Print the output from each of the count operations in the same order as the input file.</p><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">M 1 6</span><br><span class="line">C 1</span><br><span class="line">M 2 4</span><br><span class="line">M 2 6</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>Source</strong></p><p><a href="http://poj.org/searchproblem?field=source&key=USACO+2004+U+S+Open">USACO 2004 U S Open</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>一道典型的带权并查集题。我们用栈底方块作为根节点，权值代表到栈底（根节点）有多少个方块。但还有个问题，两个栈合并时我们并不知道合并到底部的栈有多少个方块，该给被合并的栈的根节点多少权值，于是我们可以用另一个权值数组，或者直接用原来的根节点权值代表这个栈有多少方块，这样合并时候就能直到给根节点赋值多少了。</p><p>带权并查集的路径压缩和合并操作都能用向量理解。</p><p>首先是路径压缩，已知 $A$ 到父节点 $B$ 的权值，即 $A$ 下面到 $B$ 有多少方块，以及 $B$  到根节点的权值，那么 $A$ 到根节点的权值就是 $A$ 到父节点 $B$ 的权值加上 $B$  到根节点的权值，即 $\vec{AB} + \vec{BR} &#x3D; \vec{AR}$。这样递归实现即可，先解决 $B$ 到根节点的权值问题，再解决 $A$ 到根节点的权值问题。</p><p>其次是合并操作，我们要把栈 $A$ 放在栈 $B$ 之上，那么 $B$ 权就为 $A$ 方块数加上 $B$ 的方块数，$A$ 权就为 $B$ 的方块数，即 $\vec{AB} &#x3D; |B|$ ，$|B| &#x3D; |A|+|B|$ 。这里因为根节点的权值与其他节点意义不同，没有体现向量解释的妙qwq。</p><p>时间复杂度 $O(P\log N + N)$</p><p>空间复杂度 $O(N)$   </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">30007</span>], a[<span class="number">30007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x; <span class="comment">///返回根节点</span></span><br><span class="line">    <span class="type">int</span> pre = fa[x];<span class="comment">///保存原父节点</span></span><br><span class="line">    fa[x] = <span class="built_in">find</span>(fa[x]);<span class="comment">///更新原父节点到根节点的距离，更新父节点为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (pre != fa[pre]) a[x] += a[pre];<span class="comment">///原父节点不是根节点，则距离为原父节点到根节点距离加自身到原父节点距离</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];<span class="comment">///返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///根节点栈底元素，权值表示整个栈元素个数</span></span><br><span class="line"><span class="comment">///其他节点表示非栈底元素，权值表示到父节点的距离</span></span><br><span class="line"><span class="comment">///当然也可以把距离和栈大小分开成两个数组，而不是合并在一个权值里，会方便一点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">30000</span>;i++) a[i] = <span class="number">1</span>, fa[i] = i;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> rx = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> ry = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">            fa[rx] = ry;<span class="comment">///x根的父更新为y根</span></span><br><span class="line">            <span class="type">int</span> t = a[ry];<span class="comment">///y权 = 原x权+原y权，x权 = 原y权</span></span><br><span class="line">            a[ry] += a[rx];</span><br><span class="line">            a[rx] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; (<span class="built_in">find</span>(x) == x ? <span class="number">0</span> : a[x]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">///距离在查之前要更新的，因为不知道这条路径是否查询过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1988&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>CF1132D Stressful Training</title>
    <link href="https://blankyang233.github.io/2022/07/10/CF1132D%20Stressful%20Training/"/>
    <id>https://blankyang233.github.io/2022/07/10/CF1132D%20Stressful%20Training/</id>
    <published>2022-07-10T07:26:54.000Z</published>
    <updated>2022-07-10T07:27:36.489Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1132/D">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：贪心，优先队列，二分。</strong></p><p>显然，这道题可以用二分答案做。<code>check</code> 函数可以用小根堆，让维持时间最小的先充电。</p><p>但是不优化这道题会炸。有两个关键优化：一个是快读快写能省不少时间，还有一个是把维持天数当一个变量存起来以免重复运算浪费时间。其他一些小优化：用 <code>pop</code> 把元素弹出代替析构函数自己初始化能省一点时间，只让天数小于 $k$ 的电脑入队，每次充完电检测维持天数小于 $k$ 的才重新入队。优化前是超 $3$ 秒限制的，优化后是 $1.5$ 秒还算可以。</p><p>时间复杂度 $O((n+k)\log n)$ ，常数应该在 $(100,1000)$ </p><p>空间复杂度 $O(n)$ </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：贪心，二分。</strong></p><p>方法一的检验并非正解，其实有一个更妙的方法去验证电脑是否会在 $k$ 天之前关机。</p><p>我们用一个数组 $cnt[i]$ 表示有多少电脑最晚第 $i$ 天前要充一次电。比如一台电脑是初始电量是 $20$ 每天耗电 $15$ 要维持到 $8$ 天，每次充电 $40$ ，那么它最晚在第 $2$ 、$5$、$7$ 天要充一次电，于是 $cnt[{2,5,7}]$ 都要加一。</p><p>我们不关心电脑在哪天充电，我们只关心电脑最晚要在什么时候前充电，所以 $cnt[i]$ 在某些天超过 $1$ 是可行的。因为既然我们知道在这天之后有三台电脑会关机，只要在这天之前什么时候充电都行，不过要满足之前有空闲的天数。</p><p>于是，现在我们把它从 $1$ 到 $i$ 累和，得到一个结果 $sum$ ，表示到 $i$ 天要至少要充几次电，显然每天只能充一次，那么如果 $sum &gt; i$ ，则存在电脑没在最晚时间前充上电，关机了，是这个答案是不可行的。如果 $sum \leq i$ ，说明到第 $i$ 天充电次数完全够用，可以继续。</p><p>时间复杂度 $O(n+k)$ ，常数在 $(50,200)$</p><p>空间复杂度 $O(n+k)$  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;<span class="comment">///整数符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;<span class="comment">///挪位加数</span></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;<span class="comment">///关键优化，快读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll a, b, v;<span class="comment">///关键优化，存储天数</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;<span class="comment">///大根堆重载小于，小根堆重载大于,true代表优先级小,必须是常函数或者友元函数</span></span><br><span class="line">        <span class="keyword">return</span> v &gt; x.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">200007</span>];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct cmp &#123;</span></span><br><span class="line"><span class="comment">//     bool operator()(const node &amp;a, const node &amp;b) &#123;</span></span><br><span class="line"><span class="comment">//         return a.a / a.b &gt; b.a / b.b;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;  ///也可以写个比较类</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; pq;</span><br><span class="line"><span class="comment">//priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; pq;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) pq.<span class="built_in">pop</span>();<span class="comment">///优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="keyword">if</span> (a[i].v &lt; k)pq.<span class="built_in">push</span>(a[i]); <span class="comment">///优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        node x = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (x.v &lt; i) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">///加之前判断是否能撑到这个时候</span></span><br><span class="line">        x.a += mid;</span><br><span class="line">        x.v = x.a / x.b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x.v &lt; k) pq.<span class="built_in">push</span>(x);<span class="comment">///优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) a[i].a = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) a[i].b = <span class="built_in">read</span>(), a[i].v = a[i].a / a[i].b + <span class="number">1</span>;<span class="comment">///因为一天结束才扣电，而到了这天就算，所以取下整能过几天，加一是往后一天也算到了。</span></span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">2e12</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (l &gt; <span class="number">2e12</span> ? <span class="number">-1</span> : l) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">ll a[<span class="number">200007</span>], b[<span class="number">200007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        ll tmp = a[i];</span><br><span class="line">        <span class="keyword">while</span> (tmp / b[i] + <span class="number">1</span> &lt; k &amp;&amp; r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum[tmp / b[i] + <span class="number">1</span>]++;</span><br><span class="line">            tmp += mid;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; k;i++) &#123;</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt; i) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">///充电次数超过天数，不可能实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; b[i];</span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">2e12</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (l &gt; <span class="number">2e12</span> ? <span class="number">-1</span> : l) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1132/D&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="二分" scheme="https://blankyang233.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>NC16417 [NOIP2017]奶酪</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC16417%20[NOIP2017]%E5%A5%B6%E9%85%AA/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC16417%20[NOIP2017]%E5%A5%B6%E9%85%AA/</id>
    <published>2022-07-09T18:21:02.000Z</published>
    <updated>2022-07-09T18:21:31.877Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16417">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>现有一块大奶酪，它的高度为 h，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多<strong>半径相同</strong>的球形空洞。我们可以在这块奶酪中建立空间坐标系， 在坐标系中，奶酪的下表面为 z &#x3D; 0，奶酪的上表面为 z &#x3D; h。<br> 现在， 奶酪的下表面有一只小老鼠 Jerry， 它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交， Jerry 则可以从奶酪下表面跑进空洞； 如果一个空洞与上表面相切或是相交， Jerry 则可以从空洞跑到奶酪上表面。<br> 位于奶酪下表面的 Jerry 想知道， 在<strong>不破坏奶酪</strong>的情况下，能否利用已有的空洞跑到奶酪的上表面去?<br> 空间内两点 P1(x1,y1,z1) 、P2(x2,y2,z2) 的距离公式如下：<br> $dist(P_1,P_2)&#x3D;\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$</p><p><strong>输入描述</strong></p><p>每个输入文件包含多组数据。<br>输入文件的第一行，包含一个正整数 T，代表该输入文件中所含的数据组数。<br>接下来是 T 组数据，每组数据的格式如下：<br>第一行包含三个正整数 n， h 和 r， 两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。<br>接下来的 n 行，每行包含三个整数 x, y, z， 两个数之间以一个空格分开， 表示空洞球心坐标为 (x,y,z)。</p><p><strong>输出描述</strong></p><p>输出文件包含 T 行，分别对应 T 组数据的答案，如果在第 i 组数据中， Jerry 能从下表面跑到上表面，则输出“Yes”，如果不能，则输出“No”（均不包含引号）。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 4 1</span><br><span class="line">0 0 1</span><br><span class="line">0 0 3</span><br><span class="line">2 5 1</span><br><span class="line">0 0 1</span><br><span class="line">0 0 4</span><br><span class="line">2 5 2</span><br><span class="line">0 0 2</span><br><span class="line">2 0 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20180531/304952_1527734385285_E90A87D6E2F9E148285DFB89F9CFF06F" alt="img"></p><p><strong>备注</strong></p><p>对于 20%的数据， n &#x3D; 1， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 40%的数据， 1 ≤ n ≤ 8， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 80%的数据，1 ≤ n ≤ 1,000， 1 ≤ h , r ≤ 10,000，坐标的绝对值不超过 10,000。<br>对于 100%的数据， 1 ≤ n ≤ 1,000， 1 ≤ h , r ≤ 1,000,000,000， T ≤ 20，坐标的绝对值不超过 1,000,000,000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：计算几何，并查集。</strong></p><p>这道题可以用带权并查集维护空球体之间的连通性，以及集合的 $z$ 坐标上下限。每次读入一个球心坐标，其自身作为一个集合的 $z$ 上限是 半径加球心 $z$ 坐标，下限就是球心 $z$ 坐标减去半径。随后暴力搜索所有已有球体是否与其连通，球心距离小于等于两倍半径即相交或者相切，则合并集合，并且更新集合权值。</p><p>注意的是多组输入数据不能中途跳出，会导致不完全输入影响下一次输入。</p><p>还要注意浮点数精度问题，一般能用整数运算尽量用整数，这里要注意超长整型的问题，在计算球心距离时先判断 $x$ 和 $y$ 平面距离，再判断空间距离。不过，这道题数据没有卡浮点。</p><p>时间复杂度 $O(n^2 \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">1007</span>];</span><br><span class="line"><span class="type">double</span> hmn[<span class="number">1007</span>], hmx[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">&#125;p[<span class="number">1007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));</span><br><span class="line">&#125;<span class="comment">///double有可能有精度问题，能用整数就用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> h, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; h &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i, cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].z;<span class="comment">///多组数据一定要保证输入完，不然后面数据会到下一组然后炸掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        hmn[i] = p[i].z - r;</span><br><span class="line">        hmx[i] = p[i].z + r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dist</span>(p[i], p[j]) &lt;= <span class="number">2</span> * r) &#123;</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">find</span>(i);</span><br><span class="line">                <span class="type">int</span> b = <span class="built_in">find</span>(j);</span><br><span class="line">                fa[a] = b;</span><br><span class="line">                hmx[b] = <span class="built_in">max</span>(hmx[b], hmx[a]);</span><br><span class="line">                hmn[b] = <span class="built_in">min</span>(hmn[b], hmn[a]);</span><br><span class="line">                <span class="keyword">if</span> (hmx[b] &gt;= h &amp;&amp; hmn[b] &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">///不能跳出，也许有很多集合相连</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16417&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="计算几何" scheme="https://blankyang233.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>NC14685 加边的无向图</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC14685%20%E5%8A%A0%E8%BE%B9%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC14685%20%E5%8A%A0%E8%BE%B9%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE/</id>
    <published>2022-07-09T17:30:48.000Z</published>
    <updated>2022-07-10T15:54:23.379Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14685">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  给你一个 n 个点，m 条边的无向图，求至少要在这个的基础上加多少条无向边使得任意两个点可达~  </p><p><strong>输入描述</strong></p><p>第一行两个正整数 n 和 m 。<br>接下来的m行中，每行两个正整数 i 、 j ，表示点i与点j之间有一条无向道路。</p><p><strong>输出描述</strong></p><p>输出一个整数，表示答案</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>对于100%的数据，有n,m&lt;&#x3D;100000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>用并查集维护点和点之间是否连通，在一个集合就是连通的。只要求出集合数量，那么减一就是要连的边。</p><p>时间复杂度 $O(m\log n + n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">merge</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) ans++;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14685&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC14545 经商</title>
    <link href="https://blankyang233.github.io/2022/07/10/NC14545%20%E7%BB%8F%E5%95%86/"/>
    <id>https://blankyang233.github.io/2022/07/10/NC14545%20%E7%BB%8F%E5%95%86/</id>
    <published>2022-07-09T17:09:25.000Z</published>
    <updated>2022-07-09T17:10:33.716Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14348">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>小d是一个搞房地产的土豪。每个人经商都有每个人经商的手段，当然人际关系是需要放在首位的。<br> 小d每一个月都需要列出来一个人际关系表，表示他们搞房地产的人的一个人际关系网，但是他的精力有限，对应他只能和能够接触到的人交际。比如1认识2,2认识3，那么1就可以接触3进行交际，当然1和2也可以交际。<br> 小d还很精明，他知道他和谁交际的深获得的利益大，接下来他根据自己的想法又列出来一个利益表，表示他和这些人交际需要耗用多少精力，能够获得的利益值为多少。<br> 小d想知道，他在精力范围内，能够获得的利益值到底是多少。<br> 设定小d自己的编号为1.并且对应一个人的交际次数限定为1.</p><p><strong>输入描述</strong></p><p>本题包含多组输入，第一行输入一个数t，表示测试数据的组数<br>每组数据的第一行输入三个数，N,M，C，表示这个人际关系网一共有多少个人，关系网的关系数，以及小d的精力值<br>接下来N-1行，每行两个数ai，bi。这里第i行表示和编号为i+1的人认识需要花费ai的精力，能够获得的利益值为bi。<br>再接下来M行，每行两个数x，y，表示编号为x的人能够和编号为y的人接触<br>t&lt;&#x3D;50<br>2&lt;&#x3D;N&lt;&#x3D;10000<br>1&lt;&#x3D;M&lt;&#x3D;10*N<br>1&lt;&#x3D;ai，bi&lt;&#x3D;10<br>1&lt;&#x3D;C&lt;&#x3D;500<br>1&lt;&#x3D;x,y&lt;&#x3D;N</p><p><strong>输出描述</strong></p><p>输出包含一行，表示小d能够获得的最大利益值</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 3 7</span><br><span class="line">5 10</span><br><span class="line">3 2</span><br><span class="line">4 3</span><br><span class="line">1 100</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>小明能够接触到的人的编号有：2 3 4，那么对应接触编号为2的人花费5精力能够获得10的利益值是最优方案。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：背包dp，并查集。</strong></p><p>用并查集维护关系集合，最后遍历所有元素，与 $1$ 同根的就是小d能接触到的人。接下来是背包dp，只要考虑与 $1$ 有关系的即可。</p><p>时间复杂度 $O(m \log n + cn)$</p><p>空间复杂度 $O(n+c)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10007</span>], b[<span class="number">10007</span>], fa[<span class="number">10007</span>], dp[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">    fa[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++) cin &gt;&gt; a[i] &gt;&gt; b[i], fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///后悔贪心不能用于背包问题</span></span><br><span class="line">    <span class="comment">///因为后悔贪心变量是限制和花费或收益，花费和收益中有一个是每个点相同的，后悔另一个</span></span><br><span class="line">    <span class="comment">///而背包问题限制固定，变量是花费和收益</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == <span class="built_in">find</span>(<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = c;j &gt;= a[i];j--)</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + b[i]);</span><br><span class="line">    cout &lt;&lt; dp[c] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14348&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="背包dp" scheme="https://blankyang233.github.io/tags/%E8%83%8C%E5%8C%85dp/"/>
    
  </entry>
  
  <entry>
    <title>NC23803 DongDong认亲戚</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC23803%20DongDong%E8%AE%A4%E4%BA%B2%E6%88%9A/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC23803%20DongDong%E8%AE%A4%E4%BA%B2%E6%88%9A/</id>
    <published>2022-07-09T14:45:45.000Z</published>
    <updated>2022-07-10T15:55:17.591Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/23803">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  DongDong每年过春节都要回到老家探亲，然而DongDong记性并不好，没法想起谁是谁的亲戚（定义:若A和B是亲戚，B和C是亲戚，那么A和C也是亲戚），她只好求助于会编程的你了。 </p><p><strong>输入描述</strong></p><p>第一行给定n,m表示有n个人，m次操作</p><p>第二行给出n个字符串，表示n个人的名字分别是什么(如果出现多个人名字相同，则视为同一个人)（保证姓名是小写字符串）</p><p>接下来m行，每行输入一个数opt,两个字符串x,y</p><p>当opt&#x3D;1时，表示x,y是亲戚</p><p>当opt&#x3D;2时，表示询问x,y是否是亲戚，若是输出1，不是输出0</p><p>数据范围:1&lt;&#x3D;n,m&lt;&#x3D;20000，名字字符长度小等于10</p><p><strong>输出描述</strong></p><p>对于每个2操作给予回答</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">chen lin yi cheng</span><br><span class="line">2 chen lin</span><br><span class="line">1 chen lin</span><br><span class="line">1 yi lin</span><br><span class="line">2 yi lin</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：并查集。</strong></p><p>并查集模板题。并查集把有关系的一类放进一个集合，用其中一个节点作为根节点代表这个集合，于是建立关系就相当于把两个集合的根节点相连合并成一个集合（因此要满足传递性），查询时就看根节点是不是同一个就知道是不是在一个集合。</p><p>并查集查询时间在路径压缩后是常数的，合并时间是对数的。启发式合并（按秩合并）查询时间是对数的，合并时间是常数的。如果并查集同时使用启发式合并和路径压缩，那么合并时间和查询时间都是近似于常数的，准确的说是 $O(\alpha(n))$ ，其中 $\alpha$ 函数在 $10^{80}$ 内不超过 $4$ ，所以可以认为是常数的。通常我们只使用路径压缩即可。</p><p>时间复杂度 $O(m \log n + n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[<span class="number">20007</span>];</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        mp[s] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        string x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) fa[<span class="built_in">find</span>(mp[x])] = <span class="built_in">find</span>(mp[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) cout &lt;&lt; (<span class="built_in">find</span>(mp[x]) == <span class="built_in">find</span>(mp[y])) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/23803&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并查集" scheme="https://blankyang233.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NC216012 Let&#39;sPlayCurling</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC216012%20Let&#39;sPlayCurling/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC216012%20Let&#39;sPlayCurling/</id>
    <published>2022-07-09T14:14:58.000Z</published>
    <updated>2022-07-09T14:15:28.376Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/216012">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Curling is a sport in which players slide stones on a sheet of ice toward a target area. The team with the nearest stone to the center of the target area wins the game.</p><p> Two teams, Red and Blue, are competing on the number axis. After the game there are $(n+m)$ stones remaining on the axis, $n$ of them for the Red team and the other $m$ of them for the Blue. The iii-th stone of the Red team is positioned at $a_i$ and the $i$-th stone of the Blue team is positioned at $b_i$.</p><p> Let $c$ be the position of the center of the target area. From the description above we know that if there exists some $i$ such that $1 \le i \le n$ and for all $1 \le j \le m$ we have$|c - a_i| &lt; |c - b_j|$ then Red wins the game. What’s more, Red is declared to win $p$ points if the number of $i$ satisfying the constraint is exactly $p$.</p><p> Given the positions of the stones for team Red and Blue, your task is to determine the position $c$ of the center of the target area so that Red wins the game and scores as much as possible. Note that $c$ can be any real number, not necessarily an integer.</p><p><strong>输入描述</strong></p><p>There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:</p><p>The first line contains two integers nnn and mmm ($1 \le n, m \le 10^5$) indicating the number of stones for Red and the number of stones for Blue.</p><p>The second line contains nnn integers $a_1, a_2, \cdots, a_n$ ($1 \le a_i \le 10^9$) indicating the positions of the stones for Red.</p><p>The third line contains mmm integers $b_1, b_2, \cdots, b_m$ ($1 \le b_i \le 10^9$) indicating the positions of the stones for Blue.</p><p>It’s guaranteed that neither the sum of nnn nor the sum of $m$ will exceed $5 \times 10^5$ .</p><p><strong>输出描述</strong></p><p>For each test case output one line. If there exists some $c$ so that Red wins and scores as much as possible, output one integer indicating the maximum possible score of Red (NOT $c$). Otherwise output “Impossible” (without quotes) instead.</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">6 5</span><br><span class="line">2 5 3 7 1 7</span><br><span class="line">3 4 3 1 10</span><br><span class="line">1 1</span><br><span class="line">7</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">Impossible</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>For the first sample test case we can assign $c &#x3D; 2.5$ so that the stones at position 2 and 3 for Red will score.</p><p>For the second sample test case we can assign $c &#x3D; 7$ so that the stones at position 5 and 7 for Red will score.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL，模拟。</strong></p><p>选择一个点作为目标，如果存在红色石头比所有蓝色石头都严格接近目标，则红方胜利。进一步，满足比所有蓝色石头都严格接近目标的红色石头的数量是红方最后得分。</p><p>显然，红色石头会连成一段区间，中间不能有蓝色石头（包括端点），目标可以选在他们中间，使得这段红色石头都包括其中，并不含蓝色石头，最终得分就是连续红色石头的个数。地图上有很多蓝色石头分割了许多红色石头的区间，所以首先用一个 $map$ 将坐标映射到红色石头数量，再将蓝色石头坐标的红色石头数量设为 $0$ ，这样就有了所有石头的坐标，不为 $0$ 的就是红色石头数量。遍历一遍，计算每个区间的红色石头个数，取其中最大值即可。</p><p>时间复杂度 $O((n+m) \log (n+m))$ </p><p>空间复杂度 $O(n+m)$  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        mp[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; m;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        mp[tmp] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j) sum += j;</span><br><span class="line">        <span class="keyword">else</span> sum = <span class="number">0</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans) cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/216012&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="模拟" scheme="https://blankyang233.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>UVALive7146 Defeat the Enemy</title>
    <link href="https://blankyang233.github.io/2022/07/09/UVALive7146%20Defeat%20the%20Enemy/"/>
    <id>https://blankyang233.github.io/2022/07/09/UVALive7146%20Defeat%20the%20Enemy/</id>
    <published>2022-07-09T10:28:00.000Z</published>
    <updated>2022-07-09T10:28:32.935Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/124063">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，STL。</strong></p><p>首先要保证我方军队能消灭对方军队才行，因此只要我们按攻击力从大到小排，对方按防御力从大到小排，从大到小遍历，用我方所有攻击力大于敌方目前防御力军队中的一个打，就能保证对方小的防御力不会先把我方大的攻击力用掉，导致对方大的防御力没有办法消灭，即能消灭就一定消灭，不能就一定不能返回 $-1$。</p><p>现在考虑保证我方被消灭最少，发现如果在我方攻击力大于对方防御力的军队里面选，一定优先选择防御力刚好大于对方攻击力的军队，这样就可以保证大的防御力能保留，小的防御力不会被消灭；但如果最大的防御力都小于等于对方攻击力，那一定选择防御力最小的军队打，因为既然都会同归于尽，那么就让大的防御力保留，把最小的防御力同归于尽，保证后面有足够的防御力。因此我们这时候需要一个容器能够排序，查询，删除，插入，可以有相同元素，那么就要选择 $multiset$ 存储我方军队防御力。</p><p>于是，每次先把大于等于的军队放入多重集，如果没有则返回 $-1$ 。然后查找一个刚好防御力大于其攻击力的军队打，否则就用防御力最小的打，然后军队存活数量减一。</p><p>时间复杂度 $O((n+m) \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> atk, def;</span><br><span class="line">&#125;a[<span class="number">100007</span>], b[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin &gt;&gt; a[i].atk &gt;&gt; a[i].def;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)cin &gt;&gt; b[i].def &gt;&gt; b[i].atk;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.atk &gt; b.atk;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(b, b + m, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.def &gt; b.def;&#125;);</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i].atk &gt;= b[j].def) ms.<span class="built_in">insert</span>(a[i++].def);</span><br><span class="line">        <span class="keyword">if</span> (ms.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">upper_bound</span>(b[j].atk);</span><br><span class="line">        <span class="keyword">if</span> (it == ms.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ms.<span class="built_in">erase</span>(ms.<span class="built_in">begin</span>());</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ms.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/124063&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>UVA11020 Efficient Solutions</title>
    <link href="https://blankyang233.github.io/2022/07/09/UVA11020%20Efficient%20Solutions/"/>
    <id>https://blankyang233.github.io/2022/07/09/UVA11020%20Efficient%20Solutions/</id>
    <published>2022-07-09T09:28:07.000Z</published>
    <updated>2022-07-09T15:18:54.740Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/116634">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL，思维。</strong></p><p>首先不考虑新加入的操作，先考虑一个固定的局面，给定了所有人的两个属性值 $L$ 和 $C$，找出有竞争力的人。</p><p>这类双变量的条件一般可以画在坐标系 $L-C$ 查看，发现如果一个点坐标到原点构成的矩形内部（包括边，但不包括这个点本身）有其他点，则这个点就没有竞争力。于是发现有竞争力人群规律，其中 $L$ 小的人相对于其他人 $C$ 会较大，而 $L$ 大的人相对于其他人 $C$ 会较小。因为对于一个 $L$ 小的人，那么后面 $L$ 大的人 $C$ 要比 $L$ 小的人的 $C$ 小，不然就没竞争力，所以整体会呈现一个反比例函数的形式。因此对已有的人按 $L$ 为第一关键字从小到大排， $C$ 为第二关键字从小到大排。</p><p>现在考虑插入一个人，先找到 <code>lower_bound</code>到 $L$ 大或 $L$ 等于但 $C$ 大于等于的第一个点，那么上一个点就是 $L$ 小于他的最后一个点，则 $C$ 要比上一个点的 $C$ 严格小，才有资格插入。</p><p>随后开始排除后面那些 $L$ 大于等于他的人，但 $C$ 大于他的人。先 <code>upper_bound</code> 找到 $L$ 大 或 $L$ 等于且 $C$ 大的第一个点，从这里往后所有 $C$ 小于等于他的  $C$ 的人全都没有竞争力了（因为 <code>upper_bound</code> ，所以如果 $L$ 相等只可能 $C$ 比他大）。</p><p>每次插入后容器大小是有竞争力的人的人数。注意到容器要满足排序，插入，删除，查找，且元素可能重复，因此用 <code>multiset</code> 。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node a, node b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    multiset&lt;node&gt; ms;<span class="comment">///画x-y图分析得出，有效点若按x从小到大，则y一定从大到小，且一个x点处，不可能有y不同的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        node a = &#123; x,y &#125;;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">lower_bound</span>(a);<span class="comment">///找到x大或x等于但y大于等于的第一个点，则上一个点一定是x小于的点</span></span><br><span class="line">        <span class="keyword">if</span> (it == ms.<span class="built_in">begin</span>() || (--it)-&gt;y &gt; y) &#123;<span class="comment">///这个点的y要比上一个点的y严格小,则有资格，开始踢后面的人</span></span><br><span class="line">            ms.<span class="built_in">insert</span>(a);</span><br><span class="line">            it = ms.<span class="built_in">upper_bound</span>(a);<span class="comment">///找到x大 或 x等于且y大的第一个点</span></span><br><span class="line">            <span class="keyword">while</span> (it != ms.<span class="built_in">end</span>() &amp;&amp; it-&gt;y &gt;= y) it = ms.<span class="built_in">erase</span>(it);<span class="comment">///往后这些点的x大于等于a的x，若y比a的y大于等于，就扔掉（x等于只有y大的情况）</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ms.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; (t ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/116634&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="思维" scheme="https://blankyang233.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>NC207569 牛牛爱奇数</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC207569%20%E7%89%9B%E7%89%9B%E7%88%B1%E5%A5%87%E6%95%B0/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC207569%20%E7%89%9B%E7%89%9B%E7%88%B1%E5%A5%87%E6%95%B0/</id>
    <published>2022-07-09T08:54:37.000Z</published>
    <updated>2022-07-09T08:55:22.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/207569">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  在牛牛面前放着 $n$ 个数，这些数字既有奇数也有偶数，只不过牛牛对奇数情有独钟，他特别想让这些数都变成奇数。 </p><p>  现在牛牛获得了一种能力，他可以执行一种操作：每次选中一个偶数，然后把这些数中与该数相等的数都除以 $2$ ，例如现在有一个数组为$[2,2,3]$ ，那么牛牛可以执行一次操作，使得这个数组变为 $[1,1,3]$ 。 </p><p>  牛牛现在想知道，对于任意的 $n$ 个数，他最少需要操作多少次，使得这些数都变成奇数？ </p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,[2,2,3]</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>只需做一次操作，会将其中的偶数 $2$ 都变成 $1$ ，满足了所有的数都是奇数的要求。</p><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,[1,3,7]</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>不需要做任何操作，因为所有的数原本就是奇数。</p><p><strong>备注</strong></p><p>$1 \leq n \leq 10^{6}$ ，代表一个有多少数字</p><p>$a_{1},a_{2},a_{3}…a_{n}(1 \leq a_{i} \leq 10^{9})$ 代表数字的大小</p><p>对于 $25%$ 的数据, $1 \leq n \leq 10^{2},1 \leq a_{i} \leq 10^{3}$</p><p>对于 $75%$ 的数据, $1 \leq n \leq 10^{4},1 \leq a_{i} \leq 10^{6}$</p><p>对于 $100%$ 的数据, $1 \leq n \leq 10^{6},1 \leq a_{i} \leq 10^{9}$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，STL，优先队列。</strong></p><p>先把偶数放进优先队列从大到小排，因为大的偶数可能变成已有的小偶数，用小偶数除一次即可，因此从大的偶数开始除。并且因为同一个数字只要除一次，所以把一个除完的数字放回队列即可，剩下的同种数字全部弹出。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (!(tmp &amp; <span class="number">1</span>)) pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() == x) pq.<span class="built_in">pop</span>();</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(x &amp; <span class="number">1</span>)) pq.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/207569&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>NC17889 新建 Microsoft Office Word 文档</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC17889%20%E6%96%B0%E5%BB%BA%20Microsoft%20Office%20Word%20%E6%96%87%E6%A1%A3/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC17889%20%E6%96%B0%E5%BB%BA%20Microsoft%20Office%20Word%20%E6%96%87%E6%A1%A3/</id>
    <published>2022-07-09T08:39:43.000Z</published>
    <updated>2022-07-09T08:40:23.505Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/17889">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>CSL正在学习《计算机办公自动化》文件的建立与删除。</p><p> CSL发现，当他新建一个word文档时，会得到一个名为”新建 Microsoft Office Word 文档.doc”的文件，再新建一个，则名为”新建 Microsoft Office Word 文档(2).doc”，再新建，便是”新建 Microsoft Office Word 文档(3).doc”。不断新建，编号不断递增。倘若他已经新建了三个文档，然后删除了”新建 Microsoft Office Word 文档(2).doc”，再新建一个就又会得到一个”新建 Microsoft Office Word 文档(2).doc”。</p><p> 严格来说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。</p><p> 现在，请你编程模拟以上过程，支持以下两种操作：</p><p> New：新建一个word文档，反馈新建的文档的编号；</p><p> Delete id：删除一个编号为id的word文档，反馈删除是否成功。</p><p> 初始时一个文件都没有，”新建 Microsoft Office Word 文档.doc”的编号算作1。</p><p><strong>输入描述</strong></p><p>第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为:Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。操作次数不超过100000，删除编号的数值不超过100000。</p><p><strong>输出描述</strong></p><p>对于输入的每一个操作，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">Delete 2</span><br><span class="line">New</span><br><span class="line">Delete 4</span><br><span class="line">Delete 3</span><br><span class="line">Delete 1</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">Delete 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Successful</span><br><span class="line">2</span><br><span class="line">Failed</span><br><span class="line">Successful</span><br><span class="line">Successful</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Successful</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL，模拟，优先队列。</strong></p><p>简单但不是完全简单的模拟。</p><p>用一个优先队列记录当前空缺编号的从小到大排列，方便新建时候找到最小的空缺编号。</p><p>用一个变量记录当前最大文件编号，方便 <code>failed</code> 的判断。</p><p>用一个布尔数组记录当前编号的空缺状态，方便 <code>failed</code> 的判断。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;New&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">empty</span>())  cout &lt;&lt; ++pos &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> vis[pq.<span class="built_in">top</span>()] = <span class="number">0</span>, cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;Delete&quot;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (vis[x] || x &gt; pos) cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                vis[x] = <span class="number">1</span>;</span><br><span class="line">                pq.<span class="built_in">push</span>(x);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Successful&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17889&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="模拟" scheme="https://blankyang233.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
</feed>
