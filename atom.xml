<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空白のBlog</title>
  
  <subtitle>For the future</subtitle>
  <link href="https://blankyang233.github.io/atom.xml" rel="self"/>
  
  <link href="https://blankyang233.github.io/"/>
  <updated>2022-07-09T10:28:32.935Z</updated>
  <id>https://blankyang233.github.io/</id>
  
  <author>
    <name>空白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UVALive7146 Defeat the Enemy</title>
    <link href="https://blankyang233.github.io/2022/07/09/UVALive7146%20Defeat%20the%20Enemy/"/>
    <id>https://blankyang233.github.io/2022/07/09/UVALive7146%20Defeat%20the%20Enemy/</id>
    <published>2022-07-09T10:28:00.000Z</published>
    <updated>2022-07-09T10:28:32.935Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/124063">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，STL。</strong></p><p>首先要保证我方军队能消灭对方军队才行，因此只要我们按攻击力从大到小排，对方按防御力从大到小排，从大到小遍历，用我方所有攻击力大于敌方目前防御力军队中的一个打，就能保证对方小的防御力不会先把我方大的攻击力用掉，导致对方大的防御力没有办法消灭，即能消灭就一定消灭，不能就一定不能返回 $-1$。</p><p>现在考虑保证我方被消灭最少，发现如果在我方攻击力大于对方防御力的军队里面选，一定优先选择防御力刚好大于对方攻击力的军队，这样就可以保证大的防御力能保留，小的防御力不会被消灭；但如果最大的防御力都小于等于对方攻击力，那一定选择防御力最小的军队打，因为既然都会同归于尽，那么就让大的防御力保留，把最小的防御力同归于尽，保证后面有足够的防御力。因此我们这时候需要一个容器能够排序，查询，删除，插入，可以有相同元素，那么就要选择 $multiset$ 存储我方军队防御力。</p><p>于是，每次先把大于等于的军队放入多重集，如果没有则返回 $-1$ 。然后查找一个刚好防御力大于其攻击力的军队打，否则就用防御力最小的打，然后军队存活数量减一。</p><p>时间复杂度 $O((n+m) \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> atk, def;</span><br><span class="line">&#125;a[<span class="number">100007</span>], b[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin &gt;&gt; a[i].atk &gt;&gt; a[i].def;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)cin &gt;&gt; b[i].def &gt;&gt; b[i].atk;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.atk &gt; b.atk;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(b, b + m, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.def &gt; b.def;&#125;);</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i].atk &gt;= b[j].def) ms.<span class="built_in">insert</span>(a[i++].def);</span><br><span class="line">        <span class="keyword">if</span> (ms.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">upper_bound</span>(b[j].atk);</span><br><span class="line">        <span class="keyword">if</span> (it == ms.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ms.<span class="built_in">erase</span>(ms.<span class="built_in">begin</span>());</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ms.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/124063&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>UVA11020 Efficient Solutions</title>
    <link href="https://blankyang233.github.io/2022/07/09/UVA11020%20Efficient%20Solutions/"/>
    <id>https://blankyang233.github.io/2022/07/09/UVA11020%20Efficient%20Solutions/</id>
    <published>2022-07-09T09:28:07.000Z</published>
    <updated>2022-07-09T09:28:50.268Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/116634">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>见链接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL，思维。</strong></p><p>首先不考虑新加入的操作，先考虑一个固定的局面，给定了所有人的两个属性值 $L$ 和 $C$，找出有竞争力的人。</p><p>这类双变量的条件一般可以画在坐标系 $L-C$ 查看，发现如果一个点坐标到原点构成的矩形内部（包括边，但不包括这个点本身）有其他点，则这个点就没有竞争力。于是发现有竞争力人群规律，其中 $L$ 小的人相对于其他人 $C$ 会较大，而 $L$ 大的人相对于其他人 $C$ 会较小。因为对于一个 $L$ 小的人，那么后面 $L$ 大的人 $C$ 要比 $L$ 小的人的 $C$ 小，不然就没竞争力，所以整体会呈现一个反比例函数的形式。因此对已有的人按 $L$ 为第一关键字从小到大排， $C$ 为第二关键字从小到大排。</p><p>现在考虑插入一个人，先找到 $lower_bound$到 $L$ 大或 $L$ 等于但 $C$ 大于等于的第一个点，那么上一个点就是 $L$ 小于他的最后一个点，则 $C$ 要比上一个点的 $C$ 严格小，才有资格插入。</p><p>随后开始排除后面那些 $L$ 大于等于他的人，但 $C$ 大于他的人。先 $upper_bound$ 找到 $L$ 大 或 $L$ 等于且 $C$ 大的第一个点，从这里往后所有 $C$ 小于等于他的  $C$ 的人全都没有竞争力了（因为 $upper_bound$ ，所以如果 $L$ 相等只可能 $C$ 比他大）。</p><p>每次插入后容器大小是有竞争力的人的人数。注意到容器要满足排序，插入，删除，查找，且元素可能重复，因此用 $multiset$ 。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node a, node b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    multiset&lt;node&gt; ms;<span class="comment">///画x-y图分析得出，有效点若按x从小到大，则y一定从大到小，且一个x点处，不可能有y不同的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        node a = &#123; x,y &#125;;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">lower_bound</span>(a);<span class="comment">///找到x大或x等于但y大于等于的第一个点，则上一个点一定是x小于的点</span></span><br><span class="line">        <span class="keyword">if</span> (it == ms.<span class="built_in">begin</span>() || (--it)-&gt;y &gt; y) &#123;<span class="comment">///这个点的y要比上一个点的y严格小,则有资格，开始踢后面的人</span></span><br><span class="line">            ms.<span class="built_in">insert</span>(a);</span><br><span class="line">            it = ms.<span class="built_in">upper_bound</span>(a);<span class="comment">///找到x大 或 x等于且y大的第一个点</span></span><br><span class="line">            <span class="keyword">while</span> (it != ms.<span class="built_in">end</span>() &amp;&amp; it-&gt;y &gt;= y) it = ms.<span class="built_in">erase</span>(it);<span class="comment">///往后这些点的x大于等于a的x，若y比a的y大于等于，就扔掉（x等于只有y大的情况）</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ms.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; (t ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/116634&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="思维" scheme="https://blankyang233.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>NC207569 牛牛爱奇数</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC207569%20%E7%89%9B%E7%89%9B%E7%88%B1%E5%A5%87%E6%95%B0/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC207569%20%E7%89%9B%E7%89%9B%E7%88%B1%E5%A5%87%E6%95%B0/</id>
    <published>2022-07-09T08:54:37.000Z</published>
    <updated>2022-07-09T08:55:22.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/207569">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  在牛牛面前放着 $n$ 个数，这些数字既有奇数也有偶数，只不过牛牛对奇数情有独钟，他特别想让这些数都变成奇数。 </p><p>  现在牛牛获得了一种能力，他可以执行一种操作：每次选中一个偶数，然后把这些数中与该数相等的数都除以 $2$ ，例如现在有一个数组为$[2,2,3]$ ，那么牛牛可以执行一次操作，使得这个数组变为 $[1,1,3]$ 。 </p><p>  牛牛现在想知道，对于任意的 $n$ 个数，他最少需要操作多少次，使得这些数都变成奇数？ </p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,[2,2,3]</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>只需做一次操作，会将其中的偶数 $2$ 都变成 $1$ ，满足了所有的数都是奇数的要求。</p><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,[1,3,7]</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>不需要做任何操作，因为所有的数原本就是奇数。</p><p><strong>备注</strong></p><p>$1 \leq n \leq 10^{6}$ ，代表一个有多少数字</p><p>$a_{1},a_{2},a_{3}…a_{n}(1 \leq a_{i} \leq 10^{9})$ 代表数字的大小</p><p>对于 $25%$ 的数据, $1 \leq n \leq 10^{2},1 \leq a_{i} \leq 10^{3}$</p><p>对于 $75%$ 的数据, $1 \leq n \leq 10^{4},1 \leq a_{i} \leq 10^{6}$</p><p>对于 $100%$ 的数据, $1 \leq n \leq 10^{6},1 \leq a_{i} \leq 10^{9}$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，STL，优先队列。</strong></p><p>先把偶数放进优先队列从大到小排，因为大的偶数可能变成已有的小偶数，用小偶数除一次即可，因此从大的偶数开始除。并且因为同一个数字只要除一次，所以把一个除完的数字放回队列即可，剩下的同种数字全部弹出。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (!(tmp &amp; <span class="number">1</span>)) pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() == x) pq.<span class="built_in">pop</span>();</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(x &amp; <span class="number">1</span>)) pq.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/207569&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>NC17889 新建 Microsoft Office Word 文档</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC17889%20%E6%96%B0%E5%BB%BA%20Microsoft%20Office%20Word%20%E6%96%87%E6%A1%A3/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC17889%20%E6%96%B0%E5%BB%BA%20Microsoft%20Office%20Word%20%E6%96%87%E6%A1%A3/</id>
    <published>2022-07-09T08:39:43.000Z</published>
    <updated>2022-07-09T08:40:23.505Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/17889">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>CSL正在学习《计算机办公自动化》文件的建立与删除。</p><p> CSL发现，当他新建一个word文档时，会得到一个名为”新建 Microsoft Office Word 文档.doc”的文件，再新建一个，则名为”新建 Microsoft Office Word 文档(2).doc”，再新建，便是”新建 Microsoft Office Word 文档(3).doc”。不断新建，编号不断递增。倘若他已经新建了三个文档，然后删除了”新建 Microsoft Office Word 文档(2).doc”，再新建一个就又会得到一个”新建 Microsoft Office Word 文档(2).doc”。</p><p> 严格来说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。</p><p> 现在，请你编程模拟以上过程，支持以下两种操作：</p><p> New：新建一个word文档，反馈新建的文档的编号；</p><p> Delete id：删除一个编号为id的word文档，反馈删除是否成功。</p><p> 初始时一个文件都没有，”新建 Microsoft Office Word 文档.doc”的编号算作1。</p><p><strong>输入描述</strong></p><p>第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为:Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。操作次数不超过100000，删除编号的数值不超过100000。</p><p><strong>输出描述</strong></p><p>对于输入的每一个操作，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">Delete 2</span><br><span class="line">New</span><br><span class="line">Delete 4</span><br><span class="line">Delete 3</span><br><span class="line">Delete 1</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">New</span><br><span class="line">Delete 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Successful</span><br><span class="line">2</span><br><span class="line">Failed</span><br><span class="line">Successful</span><br><span class="line">Successful</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Successful</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL，模拟，优先队列。</strong></p><p>简单但不是完全简单的模拟。</p><p>用一个优先队列记录当前空缺编号的从小到大排列，方便新建时候找到最小的空缺编号。</p><p>用一个变量记录当前最大文件编号，方便 <code>failed</code> 的判断。</p><p>用一个布尔数组记录当前编号的空缺状态，方便 <code>failed</code> 的判断。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;New&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">empty</span>())  cout &lt;&lt; ++pos &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> vis[pq.<span class="built_in">top</span>()] = <span class="number">0</span>, cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;Delete&quot;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (vis[x] || x &gt; pos) cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                vis[x] = <span class="number">1</span>;</span><br><span class="line">                pq.<span class="built_in">push</span>(x);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Successful&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17889&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="模拟" scheme="https://blankyang233.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>NC22596 Rinne Loves Data Structure</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC22596%20Rinne%20Loves%20Data%20Structure/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC22596%20Rinne%20Loves%20Data%20Structure/</id>
    <published>2022-07-09T08:22:06.000Z</published>
    <updated>2022-07-09T08:23:40.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/22596">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  Rinne 喜欢 OI。在 9102 年的 PION 中，她在初赛遇到了这样一道题目： </p><p> 阅读下列代码，然后回答问题。<br><img src="https://uploadfiles.nowcoder.com/images/20190127/310583_1548557182210_007691A41DEBE9190B70C58D79BEA139" alt="img"></p><p>  补充：建树过程中会更新lc和rc，这实质上是一个二叉查找树的插入过程。 </p><p>  定义一个玄学节点叫做 R，每次操作读入 val ，执行 Insert(R,val)。 </p><p> 问题：每次 Insert 操作结束之后，输出当前节点的深度和。<br> 这里我们定义 R 节点的深度为 0。</p><p><strong>输入描述</strong></p><p>第一行一个整数 N，表示操作次数。</p><p>接下来 N 行，第 i 行有一个值 $val_i$，表示第 i 次操作的 $val_i$。</p><p><strong>输出描述</strong></p><p>N 行，每行输出该次操作完后的答案。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">11</span><br><span class="line">13</span><br><span class="line">15</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>$N \leq 3 \times 10^5$。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：树，STL。</strong></p><p>画图易知二叉排序树插入的节点有 $4$ 种情况：插入节点比所有节点都小，那会存放在最小节点的左孩子；插入节点比所有节点都大，那会存放在最大节点的右孩子；插入节点比某子树根小，但比其左子树根大，那会存放在左子树的右孩子；插入节点比某子树根大，但比其右子树根小，那会存放在右子树的左孩子。</p><p>因为二叉排序树不能出现相同键值的节点，用 $set$ 存储比较好，特判一下插入相同元素的情况。再用一个 $map$ 存储相应节点的深度。</p><p>随后用 $set$ 成员函数 $lower_bound$ (比STL泛用函数要快)查找第一个大于等于插入元素的节点位置，然后如果是 $begin()$ 或者 $end()$ ，则取相应的头&#x2F;尾节点的深度加一；如果是中间某个元素，则取前后两个元素的深度最大值加一。最后别忘记插入回去。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dep;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        cin &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(val);</span><br><span class="line">            dep[val] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> pos = s.<span class="built_in">lower_bound</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (*pos == val) &#123;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == s.<span class="built_in">begin</span>()) dep[val] = dep[*pos] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == s.<span class="built_in">end</span>()) pos--, dep[val] = dep[*pos] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dep[val] = dep[*pos];</span><br><span class="line">            pos--;</span><br><span class="line">            dep[val] = <span class="built_in">max</span>(dep[*pos], dep[val]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += dep[val];</span><br><span class="line">        s.<span class="built_in">insert</span>(val);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/22596&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="树" scheme="https://blankyang233.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>NC17508 指纹锁</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC17508%20%E6%8C%87%E7%BA%B9%E9%94%81/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC17508%20%E6%8C%87%E7%BA%B9%E9%94%81/</id>
    <published>2022-07-09T08:06:45.000Z</published>
    <updated>2022-07-09T08:07:26.202Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/17508">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>​    HA实验有一套非常严密的安全保障体系，在HA实验基地的大门，有一个指纹锁。 </p><p>​    该指纹锁的加密算法会把一个指纹转化为一个不超过1e7的数字，两个指纹数值之差越小，就说明两个指纹越相似，当两个指纹的数值差≤k时，这两个指纹的持有者会被系统判定为同一个人。<br>   现在有3种操作，共m个，<br> 操作1：add x，表示为指纹锁录入一个指纹，该指纹对应的数字为x，如果系统内有一个与x相差≤k的指纹，则系统会忽略这次添加操作<br> 操作2：del x，表示删除指纹锁中的指纹x，若指纹锁中多个与x相差≤k的指纹，则全部删除，若指纹锁中没有指纹x，则可以忽略该操作，<br> 操作3：query x，表示有一个持有指纹x的人试图打开指纹锁，你需要设计一个判断程序，返回该人是否可以打开指纹锁（只要x与存入的任何一个指纹相差≤k即可打开锁）。<br>   初始状态，指纹锁中没有任何指纹。</p><p><strong>输入描述</strong></p><p>第一行有2个正整数m，k。<br>接下来m行，每行描述一种操作：add x，del x或query x。</p><p><strong>输出描述</strong></p><p>对于每个query操作，输出一行，包含一个单词“Yes”或“No”，表示该人是否可以打开指纹锁。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">add 1</span><br><span class="line">add 10</span><br><span class="line">query 5</span><br><span class="line">query 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">add 1</span><br><span class="line">query 4</span><br><span class="line">del 1</span><br><span class="line">query 4</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">add 10</span><br><span class="line">query 10</span><br><span class="line">add 5 </span><br><span class="line">query 5</span><br><span class="line">del 7//系统将指纹10和指纹5全部删除</span><br><span class="line">query 8</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：模拟，STL。</strong></p><p>这道题运用了 $set$ 的自定义比较规则。我们把相差绝对值在 $k$ 之内的数定义为相等，即 $&lt;$ 和 $&gt;$ 都是 $false$ 因为 $&gt;$ 是用 $&lt;$ 实现的，我们只要重载 $&lt;$ 并把这一情况直接 <code>return false</code> 即可被判定为等于。随后只要按操作模拟。</p><p>时间复杂度 $O(m \log m)$</p><p>空间复杂度 $O(m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(a - b) &lt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;<span class="comment">///更改比较规则，使得绝对值差小于等于k的数是等价的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    set&lt;<span class="type">int</span>, cmp&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;add&quot;</span>) s.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;del&quot;</span>) s.<span class="built_in">erase</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;query&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(x) != s.<span class="built_in">end</span>())</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17508&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
    <category term="模拟" scheme="https://blankyang233.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>NC15128 老子的全排列呢</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC15128%20%E8%80%81%E5%AD%90%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E5%91%A2/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC15128%20%E8%80%81%E5%AD%90%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E5%91%A2/</id>
    <published>2022-07-09T07:46:59.000Z</published>
    <updated>2022-07-09T07:47:32.496Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15128">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>老李见和尚赢了自己的酒，但是自己还舍不得，所以就耍起了赖皮，对和尚说，光武不行，再来点文的，你给我说出来1-8的全排序，我就让你喝，这次绝不耍你，你能帮帮和尚么？</p><p><strong>输入描述</strong></p><p>无</p><p><strong>输出描述</strong></p><p>1~8的全排列，按照全排列的顺序输出，每行结尾无空格。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No_Input</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Full arrangement of 1~8</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1~3的全排列  ：</span><br><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：STL。</strong></p><p>这题用STL中的 $next_permutation$ 函数，可以获得当前序列的下一个字典序较大的排列，$prev_permutation$ 函数与其相反。</p><p>于是用 $next_permutation$ 函数遍历到没有下一个更大的字典序排列为止。</p><p>时间复杂度 $O(1)$</p><p>空间复杂度 $O(1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++) cout &lt;&lt; s[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15128&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>NC14661 简单的数据结构</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC14661%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC14661%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-07-09T07:35:49.000Z</published>
    <updated>2022-07-09T07:37:18.346Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14661">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  栗酱有一天在网上冲浪的时候发现了一道很有意思的数据结构题。  </p><p>  该数据结构形如长条形。  </p><p>  一开始该容器为空，有以下七种操作。  </p><p>  1 a从前面插入元素a  </p><p>  2 从前面删除一个元素  </p><p>  3 a从后面插入一个元素  </p><p>  4 从后面删除一个元素  </p><p>  5 将整个容器头尾翻转  </p><p>  6 输出个数和所有元素  </p><p>  7 对所有元素进行从小到大排序  </p><p><strong>输入描述</strong></p><p>只有一组数据，第一行 $n≤50000,m≤200000, a≤100000$ 代表最大数据数目和操作次数。<br>接下来每一行一个操作如上描述。保证所有操作合法（不会在容器为空时删除元素）。<br>6、7操作共计不会超过10次。</p><p><strong>输出描述</strong></p><p>当执行6操作时，第一行先输出当前的个数，然后从头到尾按顺序输出，每两个元素之间用一个空格隔开，末尾不能有空格。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 1</span><br><span class="line">3 5</span><br><span class="line">3 4</span><br><span class="line">6</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 5 4</span><br><span class="line">2</span><br><span class="line">5 1</span><br><span class="line">2</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：队列，STL。</strong></p><p>一道双端队列的模板题，用 stl 的 $deque$ 能完美解决。</p><p>注意的是反转操作并非真反转，只要标记是否是反转状态，然后队头弹出&#x2F;压入和队尾弹出&#x2F;压入互相交换，排序用正向迭代器和反向迭代器交换就行。</p><p>stl 的双端队列存储的内存并非连续内存，是分段连续内存，在跨段时用通常会慢一些，因此时间复杂度常数比 $vector$ 大。通常 $queue$ 以及 $stack$ 是继承 $deque$ 的因此速度也是比较慢的。</p><p>时间复杂度 压入&#x2F;弹出&#x2F;反转 $O(1)$ ，随机存取 $O(1)$ ，排序 $O(n \log n)$ </p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    <span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span> (rev) d.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">else</span> d.<span class="built_in">push_front</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev) d.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span> d.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span> (rev) d.<span class="built_in">push_front</span>(t);</span><br><span class="line">            <span class="keyword">else</span> d.<span class="built_in">push_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev) d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">else</span> d.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) rev ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) &#123;</span><br><span class="line">            cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev) <span class="keyword">for</span> (<span class="type">int</span> j = d.<span class="built_in">size</span>() - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--) cout &lt;&lt; d[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; d.<span class="built_in">size</span>();j++) cout &lt;&lt; d[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev) <span class="built_in">sort</span>(d.<span class="built_in">rbegin</span>(), d.<span class="built_in">rend</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14661&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="队列" scheme="https://blankyang233.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="STL" scheme="https://blankyang233.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>NC15688 Operating System</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC15688%20Operating%20System/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC15688%20Operating%20System/</id>
    <published>2022-07-09T07:29:23.000Z</published>
    <updated>2022-07-09T07:29:58.961Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15688">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>在学习Operating System的过程中，Glory遇到了这样一个问题，现在有一个大小为可以容纳N个页面的内存，硬盘内的内容被分成M个页面，用1~M来标识，一开始内存里没有任何页面，接下来用户会请求Q个页面，你需要设计一个置换算法，使得缺页发生的次数最少。缺页是指用户请求某个编号的页面，但这个页面没有在内存中的情况。发生缺页之后，你必须要把硬盘内对应的页面调入内存中，如果内存已满，你需要置换掉当前内存中的某个页面。</p><p><strong>输入描述</strong></p><p>多组数据，请处理到输入结束。<br>每组数据，第一行为三个整数N，M，Q （0 &lt; N，M，Q &lt;&#x3D; 50000）<br>接下来一行Q个数，表示用户请求的页面编号。</p><p><strong>输出描述</strong></p><p>对于每组数据，输出一个数，表示最少的缺页次数。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 3 5</span><br><span class="line">3 1 2 1 2</span><br><span class="line">3 4 5 </span><br><span class="line">3 2 1 4 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，优先队列。</strong></p><p>显然，OPT算法贪心一下即可，预处理后用优先队列维护。具体可以看我另一篇博客 **“NC20185 [JSOI2010]缓存交换” ** 。</p><p>时间复杂度 $O(Q \log Q)$</p><p>空间复杂度 $O(Q+N)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">50007</span>], last[<span class="number">50007</span>], nxt[<span class="number">50007</span>], vis[<span class="number">50007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; q;i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">memset</span>(last, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(last));<span class="comment">///初始化下一位置无穷大,7f是最大，ff会变成负数</span></span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = q - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;<span class="comment">///倒序遍历，更新右侧最新位置</span></span><br><span class="line">            nxt[i] = last[a[i]];<span class="comment">///第 i 个元素的下一个出现位置</span></span><br><span class="line">            last[a[i]] = i;<span class="comment">///更新值为a[i]元素的最新位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq; <span class="comment">///优先队列默认从大到小</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">///cnt代替内存使用长度，因为pq每次不管有没有都会插入，而pq长度并非真实长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[a[i]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= n) vis[a[pq.<span class="built_in">top</span>().second]] = <span class="number">0</span>, pq.<span class="built_in">pop</span>();</span><br><span class="line">                vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123; nxt[i],i &#125;);<span class="comment">///持续插入，并不会导致反复删除同一个重复元素，因为如果出现重复元素一定从序列尾部的元素开始，等价于弹出了尾部元素，更新了到了前面</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15688&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC20185 [JSOI2010]缓存交换</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC20185%20[JSOI2010]%E7%BC%93%E5%AD%98%E4%BA%A4%E6%8D%A2/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC20185%20[JSOI2010]%E7%BC%93%E5%AD%98%E4%BA%A4%E6%8D%A2/</id>
    <published>2022-07-09T07:05:49.000Z</published>
    <updated>2022-07-09T07:26:19.159Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20185">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  在计算机中，CPU只能和高速缓存Cache直接交换数据。当所需的内存单元不在Cache中时，则需要从主存里把数据调入Cache。此时，如果Cache容量已满，则必须先从中删除一个。 </p><p>  例如，当前Cache容量为3，且已经有编号为10和20的主存单元。 此时，CPU访问编号为10的主存单元，Cache命中。 接着，CPU访问编号为21的主存单元，那么只需将该主存单元移入Cache中，造成一次缺失（Cache Miss）。 接着，CPU访问编号为31的主存单元，则必须从Cache中换出一块，才能将编号为31的主存单元移入Cache，假设我们移出了编号为10的主存单元。 接着，CPU再次访问编号为10的主存单元，则又引起了一次缺失。 </p><p>  我们看到，如果在上一次删除时，删除其他的单元，则可以避免本次访问的缺失。 在现代计算机中，往往采用LRU(最近最少使用)的算法来进行Cache调度——可是，从上一个例子就能看出，这并不是最优的算法。 </p><p>  对于一个固定容量的空Cache和连续的若干主存访问请求，聪聪想知道如何在每次Cache缺失时换出正确的主存单元，以达到最少的Cache缺失次数。 </p><p><strong>输入描述</strong></p><p>输入文件第一行包含两个整数N和M(1 ≤ M ≤ N ≤ 100,000)，分别代表了主存访问的次数和Cache的容量。<br>第二行包含了N个空格分开的正整数，按访问请求先后顺序给出了每个主存块的编号(不超过1,000,000,000)。</p><p><strong>输出描述</strong></p><p>输出一行，为Cache缺失次数的最小值。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 2</span><br><span class="line">1 2 3 1 2 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，优先队列。</strong></p><p>这是一道典型的最佳页面置换(OPT)算法题。OPT算法描述的是，在内存有限的情况下，如果每次缺页把内存中下一次出现最晚的页面置换掉，会到达缺页次数的理论最小值。<a href="https://stackoverflow.com/questions/47642881/proof-for-optimal-page-replacement-opt">看具体证明</a>。</p><p>因此，我们要知道内存中最晚出现的单元，那就必须先知道对于队列中的每个内存下一个出现的位置。所以从右到左遍历，用 $last[i]$ 维护编号为 $i$ 的内存单元最新出现的位置，于是用 $nxt[i]$ 维护第 $i$ 个请求单元的下一个出现位置。在第 $i$ 个位置遇到编号为 $a[i]$ 的内存单元，先给 $nxt[i]$ 赋值 $last[a[i]]$ ，再更新 $last[a[i]]$ ，就可以得到队列中的每个内存下一个出现的位置。</p><p>然后对内存中的元素用大顶堆维护，按最晚出现时间从大到小排序，如果内存满了取堆顶即可。</p><p>这里有个小细节，因为遇到了内存中已有的元素，虽然不需要弹出堆顶，但是还是要找到这个元素然后更新其最晚出现时间，这并不可以用堆维护。但注意到如果遇到了已有元素，那这个元素一定是最早出现的，应该在堆底，那现在只要把附带新时间信息的同一个单元放入堆中即可，那么因为内存大小不变但是堆里多了个元素其一定在堆底上面，所以堆底自然就排除在外了。但要注意的是，这样就不能用堆的真实大小当作内存已有的元素个数了，需要额外用一个变量保存现在内存中元素的大小。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n + m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100007</span>], nxt[<span class="number">100007</span>];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; last, vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;<span class="comment">///右侧第一次出现位置(&gt;=1)</span></span><br><span class="line">        <span class="keyword">if</span> (last.<span class="built_in">count</span>(a[i])) nxt[i] = last[a[i]];</span><br><span class="line">        <span class="keyword">else</span> nxt[i] = <span class="number">2e9</span>;</span><br><span class="line">        last[a[i]] = i;</span><br><span class="line">        vis[a[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">///缺页次数</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[a[i]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= m) vis[pq.<span class="built_in">top</span>().second] = <span class="number">0</span>, pq.<span class="built_in">pop</span>();<span class="comment">///之前缺页次数大于等于m说明内存满了</span></span><br><span class="line">            cnt++;<span class="comment">///缺页加一</span></span><br><span class="line">            vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123; nxt[i],a[i] &#125;);</span><br><span class="line">        <span class="comment">///直接持续插入，不需要考虑元素是否已在内存中，但不能用队列长度代表已使用内存长度，需要额外记录。</span></span><br><span class="line">        <span class="comment">///如果不是同一种元素，则之前已经置换过了，现在新插入。</span></span><br><span class="line">        <span class="comment">///如果是同一种元素，不必去找到这个元素修改其下一次出现位置，直接插入即可，理由如下。</span></span><br><span class="line">        <span class="comment">///如果是同一种，那么新元素一定排在旧元素之前。并且现在是最先遇到这个元素，所以旧元素的下一次出现位置一定是内存里最小，在最后。</span></span><br><span class="line">        <span class="comment">///而内存长度是固定的，后面插入的元素一定都在旧元素之前，旧元素直接出内存范围了，等价于把旧元素更新成新元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20185&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC22604 小A与任务</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC22604%20%E5%B0%8FA%E4%B8%8E%E4%BB%BB%E5%8A%A1/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC22604%20%E5%B0%8FA%E4%B8%8E%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-07-08T18:22:35.000Z</published>
    <updated>2022-07-08T18:23:10.572Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/22604">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  小A手头有 n 份任务，他可以以任意顺序完成这些任务，只有完成当前的任务后，他才能做下一个任务 </p><p>  第 i 个任务需要花费 $x_i$ 的时间，同时完成第 i 个任务的时间不能晚于 $y_i$ ，时间掌控者向小A提出了一个条件：如果完成第 i 个任务的时间本应是 t ，但小A支付 m 个金币的话，他可以帮助小A在 $t-m\times z_i$ 时刻完成第 i 个任务，$z_i$ 是时间参数，会在输入中给出 </p><p>  小A想按时完成所有任务，请你帮他制定一个花费金币最少的方案</p><p><strong>注意：不能使得某个任务的花费时间小于 0 ,花费的金币可以不是整数</strong></p><p><strong>输入描述</strong></p><p>第一行一个整数 n ，表示小A的任务数量<br>接下来n行，每行三个整数，分别表示$z_i,x_i,y_i$</p><p><strong>输出描述</strong></p><p>一行一个实数，表示小A最少需要花费的金币数，四舍五入保留一位小数</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 1 2</span><br><span class="line">1 1 3</span><br><span class="line">1 2 4</span><br><span class="line">1 1 4</span><br><span class="line">1 2 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>在1时刻完成第一个任务,2时刻完成第二个任务,4时刻完成第三个任务,花费1金币在4时刻完成第四个任务,花费1金币在5时刻完成第五个任务</p><p><strong>备注</strong></p><p>$1\leq n \leq 2\times 10^5$<br>$1\leq x_i,z_i\leq 3\times10^3$<br>$1\leq y_i \leq 10^5$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，优先队列。</strong></p><p>这是一道后悔贪心变种，这里的限制是截止时间，花费是任务消耗时间，收益是按时完成的任务数，即少花费的金币。如果不考虑金币能够补任务的问题，只要按照截止时间从小到大排序，每次超时再将花费时间多的踢出去，最后即可获得最多按时完成的任务。</p><p>但是这里要完成所有任务，那么就不能不做任务了，每次超时要用金币补齐。但注意到不一定要补当前做不完的任务，可以缩短之前 $z$ 最大的任务，即可补上相同时间，但是花费最少，因为花费金币数为 $\frac{\Delta t}{z}$ ，$z$ 越大花费越小。</p><p>注意任务完成时间不能小于 $0$，因为减到 $0$ 之后就不能回队列了，要是没减完要换下一个减 。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;a[<span class="number">200007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i].z &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.y &lt; b.y;&#125;);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    priority_queue &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        sum += a[i].x;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123; a[i].z,a[i].x &#125;);</span><br><span class="line">        <span class="keyword">while</span> (sum &gt; a[i].y) &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; task = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> delta = <span class="built_in">min</span>(sum - a[i].y, task.second);</span><br><span class="line">            ans += (<span class="type">double</span>)delta / task.first;</span><br><span class="line">            sum -= delta;</span><br><span class="line">            task.second -= delta;</span><br><span class="line">            <span class="keyword">if</span> (task.second) pq.<span class="built_in">push</span>(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/22604&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC20154 [JSOI2007]建筑抢修</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC20154%20[JSOI2007]%E5%BB%BA%E7%AD%91%E6%8A%A2%E4%BF%AE/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC20154%20[JSOI2007]%E5%BB%BA%E7%AD%91%E6%8A%A2%E4%BF%AE/</id>
    <published>2022-07-08T17:45:17.000Z</published>
    <updated>2022-07-08T17:45:46.940Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20154">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  小刚在玩JSOI提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T部落消灭了所有z部落的入侵者。但是T部落的基地里已经有N个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全 毁坏。 </p><p>  现在的情况是：T部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。 </p><p>  如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。 </p><p><strong>输入描述</strong></p><p>第一行是一个整数N接下来N行每行两个整数T1,T2描述一个建筑：修理这个建筑需要T1秒，如果在T2秒之内还没有修理完成，这个建筑就报废了。</p><p><strong>输出描述</strong></p><p>输出一个整数S，表示最多可以抢修S个建筑.<br>N &lt; 150,000;  T1 &lt; T2 &lt; maxlongint</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">100 200</span><br><span class="line">200 1300</span><br><span class="line">1000 1250</span><br><span class="line">2000 3200</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，优先队列。</strong></p><p>这是典型的后悔贪心题，其符合限制和花费是变量，收益是常量 $1$ 。显然，随着限制截止时间从小到大开放，可选修的建筑增多，因为截止时间晚的可行情况，截止时间早的不一定可以尝试；但截至时间早的适合的情况，截止时间晚的一定可以去尝试，前者会丢失机会，后者不会。因此选择先按截止时间从小到大排序，随后后悔花费多的即可。</p><p>时间复杂度 $O(n\log n)$</p><p>空间复杂度 $O(n)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> t1, t2;</span><br><span class="line">&#125;a[<span class="number">150007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i].t1 &gt;&gt; a[i].t2;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.t2 &lt; b.t2;&#125;);</span><br><span class="line">    <span class="comment">///这里对可选建筑的限制是总体ddl，由最小ddl决定，ddl越大可选建筑越多，故从小到大放大ddl</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(a[i].t1);</span><br><span class="line">        sum += a[i].t1;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">while</span> (sum &gt; a[i].t2) sum -= pq.<span class="built_in">top</span>(), pq.<span class="built_in">pop</span>(), cnt--;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20154&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC50439 tokitsukaze and Soldier</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC50439%20tokitsukaze%20and%20Soldier/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC50439%20tokitsukaze%20and%20Soldier/</id>
    <published>2022-07-08T17:33:32.000Z</published>
    <updated>2022-07-08T17:34:01.300Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/50439">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>在一个游戏中，tokitsukaze需要在n个士兵中选出一些士兵组成一个团去打副本。<br> 第i个士兵的战力为v[i]，团的战力是团内所有士兵的战力之和。<br> 但是这些士兵有特殊的要求：如果选了第i个士兵，这个士兵希望团的人数不超过s[i]。(如果不选第i个士兵，就没有这个限制。)<br> tokitsukaze想知道，团的战力最大为多少。</p><p><strong>输入描述</strong></p><p>第一行包含一个正整数 $n(1≤n≤10^5)$ 。<br>接下来 $n$ 行，每行包括 $2$ 个正整数 $v,s(1≤v≤10^9,1≤s≤n)$ 。</p><p><strong>输出描述</strong></p><p>输出一个正整数，表示团的最大战力。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">100 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，优先队列。</strong></p><p>这是一道典型的后悔贪心。</p><p>根据经验，<strong>后悔贪心</strong>一般具有三个因素：<strong>限制，花费和收益</strong>，其中花费和收益必定有一个是<strong>常量</strong>。比如这道题花费就是常量每次加入一个人，人数作为花费只增加 $1$ ；而有的题则是收益是常量，比如建筑抢修，收益是抢修建筑数量每次只增加 $1$ 。<strong>背包问题</strong>同样也有这三个因素，但其<strong>不同</strong>的是，限制容积是个常量，但花费和收益都是变量，因此无法使用后悔贪心。但鄙人水平有限，具体无法证明，只是经验之谈。</p><p>后悔贪心总体思路：把对选项数量的限制从严到松开放，则可选项会逐渐增多，并且原先选中的扔掉不会影响限制。这里的可选人数的限制是人数限制，由人数限制的最小值决定，人数限制越小可选的人越多，故缩小人数限制。</p><p>一开始不会踢人，直到人数与最小值缩小到相等开始踢人。此时缩小最小值，可选的人数变多，并且原来选中的人的限制人数并不影响最小值。考虑加入新人后，踢出战斗力最小的直到满足人数限制，此时就是当前人数限制下的最优解，这里是维护动态数组有序性，用堆处理。有可能会踢掉刚刚加进来的，不影响后面过程，因为后面限制人数只会比现在更小。最后得到了所有人数情况下的最优解，答案取最大值即可。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, s;</span><br><span class="line">&#125;a[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].v &gt;&gt; a[i].s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.s &gt; b.s;&#125;);<span class="comment">///按人数限制排序</span></span><br><span class="line">    <span class="comment">///后悔贪心总体思路：把对选项数量的限制从严到松开放，则可选项会逐渐增多，并且原先选中的扔掉不会影响限制。</span></span><br><span class="line">    <span class="comment">///这里的可选人数的限制是人数限制，由人数限制的最小值决定，人数限制越小可选的人越多，故缩小人数限制。</span></span><br><span class="line">    <span class="comment">///一开始不会踢人，直到人数与最小值缩小到相等开始踢人。</span></span><br><span class="line">    <span class="comment">///此时缩小最小值，可选的人数变多，并且原来选中的人的限制人数并不影响最小值。</span></span><br><span class="line">    <span class="comment">///考虑加入新人后，踢出战斗力最小的直到满足人数限制，此时就是当前人数限制下的最优解。这里是维护动态数组有序性，用堆处理。</span></span><br><span class="line">    <span class="comment">///有可能会踢掉刚刚加进来的，不影响后面过程，因为后面限制人数只会比现在更小。</span></span><br><span class="line">    <span class="comment">///最后得到了所有人数情况下的最优解，答案取最大值即可。</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    ll ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(a[i].v);</span><br><span class="line">        sum += a[i].v;</span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; a[i].s) sum -= pq.<span class="built_in">top</span>(), pq.<span class="built_in">pop</span>();</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50439&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC17315 背包</title>
    <link href="https://blankyang233.github.io/2022/07/09/NC17315%20%E8%83%8C%E5%8C%85/"/>
    <id>https://blankyang233.github.io/2022/07/09/NC17315%20%E8%83%8C%E5%8C%85/</id>
    <published>2022-07-08T17:15:08.000Z</published>
    <updated>2022-07-08T18:26:32.981Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/17315">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>Applese有 $1$ 个容量为 $v$ 的背包，有 $n$ 个物品，每一个物品有一个价值 $a_i$ ，以及一个大小 $b_i$<br> 然后他对此提出了自己的疑问，如果我不要装的物品装的价值最大，只是一定需要装 $m$ 个物品，要使得求出来的物品价值的中位数最大<br> Applese觉得这个题依然太菜，于是他把这个问题丢给了你<br> 当物品数量为偶数时，中位数即中间两个物品的价值的平均值</p><p><strong>输入描述</strong></p><p>第一行三个数 $v, n, m$ ，分别代表背包容量，物品数量以及需要取出的物品数量</p><p>接下来n行，每行两个数 $a_i,b_i$ ，分别代表物品价值以及大小</p><p>$n ≤ 1e5, 1 ≤ m ≤ n, a_i ≤ 1e9, v ≤ 1e9, b_i ≤ v$</p><p><strong>输出描述</strong></p><p>仅一行，代表最大的中位数</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20 5 3</span><br><span class="line">3 5</span><br><span class="line">5 6</span><br><span class="line">8 7</span><br><span class="line">10 6</span><br><span class="line">15 10</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：优先队列，贪心，二分。</strong></p><p>由于要求的长为 $m$ 的序列的中位数最大值，直接从 $n$ 个数里枚举 $m$ 个数会很困难。用dp解决的话，每种可能都要记录还要求一下中位数，也是不可行的。</p><p>但是因为是中位数，所以换一种角度，把每个数当作中位数，去匹配一组使其成为中位数的序列。这是很好处理的，只要比这个数小的数存在一定数量个，比这个数大的数存在一定数量个即可，然后从其中取得最小的一组序列重量值，因为我们不关心除了中位数的其他数的价值。</p><p>具体地说，我们先考虑 $m$ 为奇数，那么一个数左右侧都需要有 $\lfloor \frac{m}{2} \rfloor$  个数，取他们重量最小值。因此为了使得枚举中位数更加方便，我们先从小到大排序价值，然后从左往右遍历维护一个长度为 $\lfloor \frac{m}{2} \rfloor$ 的按重量的小顶堆，并在过程中维护动态前 $\lfloor \frac{m}{2} \rfloor$ 小的和 $s1[i]$ ，即可得到 $[1,i]$ 中重量前 $\lfloor \frac{m}{2} \rfloor$ 小的和 。同理从右到左维护一个 $s2[i]$ ，即 $[i,n]$ 中重量前 $\lfloor \frac{m}{2} \rfloor$ 小的和。</p><p>之后我们对每个数进行判断 <code>s1[i - 1] + a[i].b + s2[i + 1] &lt;= v</code> ，满足的即合法，那么就可以参与最大值的判断。</p><p>接下来考虑 $m$ 为偶数，因为偶数序列中位数是中间两个数之和取下整，因此我们要考虑两个数，一个数维护左侧，一个数维护右侧。那先枚举左边的数，而另一个数因为只需要考虑右侧重量和，由于价值会从左往右递增，而最小重量和一定是递增的（假设一定满足中位数的右侧个数需求），那么会存在一个点使得右侧数字不能成为中位数，左侧数字可以成为中位数但比这个数小，即符合单调性可以二分求解。要注意的是前后缀最小重量和在偶数情况维护的是前 $\lfloor \frac{m}{2} \rfloor - 1$ 小个。</p><p>时间复杂度 $O(n\log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v, n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125;a[<span class="number">100007</span>];</span><br><span class="line">ll s1[<span class="number">100007</span>], s2[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i].a &gt;&gt; a[i].b;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.a &lt; b.a;&#125;);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;<span class="comment">///k小前缀和，维护中位数左侧</span></span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + a[i].b;</span><br><span class="line">        pq.<span class="built_in">push</span>(a[i].b);</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; m / <span class="number">2</span> - !(m &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            s1[i] -= pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) pq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i--) &#123;<span class="comment">///k小后缀和，维护中位数右侧</span></span><br><span class="line">        s2[i] = s2[i + <span class="number">1</span>] + a[i].b;</span><br><span class="line">        pq.<span class="built_in">push</span>(a[i].b);</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; m / <span class="number">2</span> - !(m &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            s2[i] -= pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; <span class="number">1</span>) &#123;<span class="comment">///奇数直接枚举中位数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m / <span class="number">2</span> + <span class="number">1</span>;i &lt;= n - m / <span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] + a[i].b + s2[i + <span class="number">1</span>] &lt;= v)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">///偶数枚举一个之后，二分另一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m / <span class="number">2</span>;i &lt;= n - m / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] + a[i].b + s2[i + <span class="number">1</span>] &lt;= v) &#123;<span class="comment">///小优化</span></span><br><span class="line">                <span class="type">int</span> l = i + <span class="number">1</span>, r = n - m / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s1[i - <span class="number">1</span>] + a[i].b + a[mid].b + s2[mid + <span class="number">1</span>] &lt;= v) l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r &gt; i)ans = <span class="built_in">max</span>(ans, a[i].a + a[r].a &gt;&gt; <span class="number">1</span>);<span class="comment">///不一定找得到</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17315&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="二分" scheme="https://blankyang233.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>NC214362 第k小</title>
    <link href="https://blankyang233.github.io/2022/07/08/NC214362%20%E7%AC%ACk%E5%B0%8F/"/>
    <id>https://blankyang233.github.io/2022/07/08/NC214362%20%E7%AC%ACk%E5%B0%8F/</id>
    <published>2022-07-08T15:49:54.000Z</published>
    <updated>2022-07-08T15:50:28.822Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/214362">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>  有一个长度为n的数组，值为 a[i], 牛牛想找到数组中第 k 小的数。比如 1 2 2 3 4 6 中，第 3 小的数就是2. </p><p>  牛牛觉得这个游戏太简单了，想加一点难度，现在牛牛有 m 个操作，每个操作有两种类型。 </p><p>  1 x 1 代表操作一，给数组中加一个元素 x 。(0 ≤ x ≤ 1e9) </p><p>  2   2 代表操作二，查询第 k 小的数。如果没有 k 个数就输出−1 </p><p><strong>输入描述</strong></p><p>第一行有三个整数，n m k,(1≤n,m,k≤2e5)<br>第二行包含 n 个整数 a[i] ( 0 ≤ a[i] ≤ 1e9)<br>接下来m行，每行代表一个操作。具体见题目描述</p><p><strong>输出描述</strong></p><p>每次查询输出一个第  k  小的数。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4 3</span><br><span class="line">1 2 3 4 5</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：优先队列。</strong></p><p>这和输出一个固定序列的第 $k$ 小不同，这里要维护一个动态变化的序列，故用小顶堆维护前 $k$ 个数，那么队头就是第 $k$ 个数。</p><p>要注意有可能不足 $k$ 个数。</p><p>时间复杂度 $O(n\log n + m\log m)$</p><p>空间复杂度 $O(n + m)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            cin &gt;&gt; tmp;</span><br><span class="line">            pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            cout &lt;&lt; (pq.<span class="built_in">size</span>() == k ? pq.<span class="built_in">top</span>() : <span class="number">-1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/214362&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC50940 Running Median</title>
    <link href="https://blankyang233.github.io/2022/07/08/NC50940%20Running%20Median/"/>
    <id>https://blankyang233.github.io/2022/07/08/NC50940%20Running%20Median/</id>
    <published>2022-07-08T15:39:35.000Z</published>
    <updated>2022-07-08T15:40:12.556Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/50940">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>For this problem, you will write a program that reads in a sequence of 32-bit signed integers. After each odd-indexed value is read, output the median (middle value) of the elements received so far.</p><p><strong>输入描述</strong></p><p>The first line of input contains a single integer $P(1 \leq P  \leq 1000)$ , which is the number of data sets that follow. The first line of each data set contains the data set number, followed by a space, followed by an odd decimal integer $M (1  \leq M  \leq 9999)$ , giving the total number of signed integers to be processed. The remaining line(s) in the dataset consists of the values, 10 per line, separated by a single space. The last line in the dataset may contain less than 10 values.</p><p><strong>输出描述</strong></p><p>For each data set the first line of output contains the data set number, a single space and the number of medians output (which should be one-half the number of input values plus one). The output medians will be on the following lines, 10 per line separated by a single space. The last line may have less than 10 elements, but at least 1 element. There should be no blank lines in the output.</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">1 9 </span><br><span class="line">1 2 3 4 5 6 7 8 9 </span><br><span class="line">2 9 </span><br><span class="line">9 8 7 6 5 4 3 2 1 </span><br><span class="line">3 23 </span><br><span class="line">23 41 13 22 -3 24 -31 -11 -8 -7 </span><br><span class="line">3 5 103 211 -311 -45 -67 -73 -81 -99 </span><br><span class="line">-33 24 56</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">2 5</span><br><span class="line">9 8 7 6 5</span><br><span class="line">3 12</span><br><span class="line">23 23 22 22 13 3 5 5 3 -3 </span><br><span class="line">-7 -3</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：优先队列。</strong></p><p>用两个优先队列维护中位数左边和右边的序列，因为中位数一定在序列的中间位置，左边比他大，右边比他小且数量几乎一样（相差不超过 $1$ ）。因此左边维护大顶堆，右边维护小顶堆，每次存入数据后比较两序列的大小，那边比那边大超过 $1$ 就把队头转移直至平衡，就可以维护一个动态中位数了。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p, m;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (m + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq1;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq2;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    cin &gt;&gt; tmp;</span><br><span class="line">    pq1.<span class="built_in">push</span>(tmp);</span><br><span class="line">    cout &lt;&lt; pq1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt;= pq1.<span class="built_in">top</span>()) pq1.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">else</span> pq2.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (pq1.<span class="built_in">size</span>() &gt; <span class="number">1</span> + pq2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            pq2.<span class="built_in">push</span>(pq1.<span class="built_in">top</span>());</span><br><span class="line">            pq1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pq1.<span class="built_in">size</span>() + <span class="number">1</span> &lt; pq2.<span class="built_in">size</span>()) &#123;<span class="comment">///注意，不要size相减，会ULL溢出，-1变最大值</span></span><br><span class="line">            pq1.<span class="built_in">push</span>(pq2.<span class="built_in">top</span>());</span><br><span class="line">            pq2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) cout &lt;&lt; (pq1.<span class="built_in">size</span>() &gt; pq2.<span class="built_in">size</span>() ? pq1.<span class="built_in">top</span>() : pq2.<span class="built_in">top</span>()) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(i % <span class="number">20</span>)) cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50940&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC20951 网络优化</title>
    <link href="https://blankyang233.github.io/2022/07/08/NC20951%20%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    <id>https://blankyang233.github.io/2022/07/08/NC20951%20%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/</id>
    <published>2022-07-08T15:29:19.000Z</published>
    <updated>2022-07-08T15:30:22.488Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20951">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong>                    </p><p>《梦三国2》是一款3D MOBA类网游。游戏继承《梦三国》的三国文化背景和基础玩法，并加入许多全新地图和全新竞技玩法。由于人气高，游戏在线人数与日俱增，我们知道当在线人数不断增长的时候，会给服务器带来巨大的压力。<br> 已知该游戏中共有n名用户，编号从1到n，服务器共有m条服务线，每个用户最多只能登陆一条线，第i条线最多可以容纳v[i]名用户同时在线，且只能给编号在[l[i],r[i]]范围内的用户提供服务。现在希望找出一种合理的资源分配方案，使得同时在线人数最大化，请输出这个最大人数。</p><p><strong>输入描述</strong></p><p>数据组数不超过10<br>对于每组数据。<br>第一行包括两个正整数n，m(1&lt;&#x3D;n，m&lt;&#x3D;10000)<br>接下来m行，每行三个整数l[i],r[i],v[i]</p><p><strong>输出描述</strong></p><p>对于每组数据输出一个正整数，即最多容纳的用户数量</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 1 1</span><br><span class="line">2 4 2</span><br><span class="line">2 3 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>我们可以让1号服务线服务用户1，2号服务线服务用户4，3号服务线服务用户2和3</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>知识点：贪心，优先队列。</strong></p><p>第一个想到的贪心是让区间的右端点从小到大排序，然后从第一个人开始遍历，看看在不在这个区间。因为这样做前面的人匹配到靠前的线路，可以让更多后面的人有机会匹配到线路。若是人的编号超过右端点了，对于这个人，这条线路就用不了了，可以丢了。</p><p>但还需要注意左端点，因为假设左端点够不到某个人，但其右端点是靠前的，那对于后面能用的人这个线路就被扔掉了，是浪费了。因此我们要对每个人，把从他开始的线路，即左端点刚好是他编号的线路，先放入优先队列按右端点从小到大排序，这样优先队列里参与匹配的线路就都是够得到当前点，且是按右端点排序好的。</p><p>所以我们一开始把线路按左端点从小到大排序，遇到一个人就把从他开始的线路加入优先队列，这样选的时候就都是够得到的线路。再把有效的线路按右端点从小到大排序，尽可能用掉右端点靠前的线路，少占用右端点靠后的线路，给后面人留机会。最后编号超过队头右端点就可以弹出队头，因为这条线路不可能用得到了。</p><p>注意，没用完的线路要放回队列。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, v;</span><br><span class="line">&#125;a[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++) cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].v;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + m, [&amp;](node a, node b) &#123;<span class="keyword">return</span> a.l &lt; b.l;&#125;);</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, pos = <span class="number">0</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().first &lt; i) pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; m &amp;&amp; a[pos].l == i) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123; a[pos].r,a[pos].v &#125;);</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; x = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                x.second--;</span><br><span class="line">                <span class="keyword">if</span> (x.second) pq.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20951&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NC14291 Cut</title>
    <link href="https://blankyang233.github.io/2022/07/08/NC14291%20Cut/"/>
    <id>https://blankyang233.github.io/2022/07/08/NC14291%20Cut/</id>
    <published>2022-07-08T15:08:52.000Z</published>
    <updated>2022-07-08T15:10:24.421Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14291">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>给你一个长度为 $n$ 的序列，你每次可以将一个序列分割成两个连续的的子序列，<br> 分割的代价为原序列的总和。<br> 现在允许你在初始时将序列重新排列一次。<br> 问分割成 $n$ 个长度为 $1$ 的序列的最大总代价是多少？</p><p><strong>输入描述</strong></p><p>第一行一个数 $n$ 表示原序列的长度；<br>接下来一行 $n$ 个数 $a_i$ 表示原序列的第 $i$ 个数。<br>$2&lt;&#x3D;n&lt;&#x3D;100000$<br>$0&lt;&#x3D;a_i&lt;&#x3D;10000$</p><p><strong>输出描述</strong></p><p>一行一个整数表示答案。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 2 4 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>[3,2,4,1]重排-&gt;[1,2,3,4]-&gt;[1],[2,3,4]-&gt;[1],[2],[3,4]-&gt;[1],[2],[3],[4]。</p><p><strong>示例2</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：贪心，数学。</strong></p><p>显然，每次把最小的取出来，大的加的机会就更多。</p><p>不妨再进一步思考，实际上从小到大取，第 $i$ 个数会加 $i$ 次。特别地，最后一个数只有 $n-1$ 次，因为最后一次没有取。</p><p>所以有 $ans &#x3D; \sum_{i&#x3D;1}^n i \cdot a_i - a_n$ 。</p><p>时间复杂度 $O(n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：贪心，优先队列。</strong></p><p>贪心思路还是一样的，不过这次用优先队列傻瓜式维护即可。</p><p>不过需要注意的是，为了方便我们假设一个等价情形，元素还未合并，要求每次合并两段序列，使得最后花费最多。显然是从大的先合并，答案和从小开始的分割序列等价。于是，很容易用优先队列维护。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    ll ans = -a[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        ans += <span class="number">1LL</span> * i * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;ll&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++) cin &gt;&gt; tmp, pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        ll sum = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        sum += pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        pq.<span class="built_in">push</span>(sum);</span><br><span class="line">        ans += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14291&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="数学" scheme="https://blankyang233.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NC16663 [NOIP2004]合并果子</title>
    <link href="https://blankyang233.github.io/2022/07/08/NC16663%20[NOIP2004]%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/"/>
    <id>https://blankyang233.github.io/2022/07/08/NC16663%20[NOIP2004]%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/</id>
    <published>2022-07-08T14:48:35.000Z</published>
    <updated>2022-07-08T14:50:34.053Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16663">题目链接</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述</strong></p><p>​    在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。   </p><p>​    每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。   </p><p>​    因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。  </p><p> 例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力&#x3D;3+12&#x3D;15。可以证明15为最小的体力耗费值。</p><p><strong>输入描述</strong></p><p>输入包括两行，第一行是一个整数 $n(1\leq n\leq 10000)$ ，表示果子的种类数。第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1 \leq a_i \leq 20000)$是第 $i$ 种果子的数目。 </p><p><strong>输出描述</strong></p><p>输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于$2^{31}$。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 9</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>对于30％的数据，保证有n&lt;&#x3D;1000：<br>对于50％的数据，保证有n&lt;&#x3D;5000；<br>对于全部的数据，保证有n&lt;&#x3D;10000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>知识点：队列，贪心。</strong></p><p>此题用优先队列能很容易解答，复杂度是 $O(n\log n)$ 。这里用队列实现，利用了合并方式固定的条件，实现了一组单调的队列，而不需要用 $\log n$ 花费排序，循环的复杂度是 $O(n)$，包括开始排序的总复杂度是 $O(n \log n)$ ，但常数比优先队列小很多。</p><p>显然，因为合并次数是固定的，先合并的果堆重复计算次数就多，所以选最小的两堆合并，因此先从小到大排序，全部入队后开始合并。</p><p>注意到，从小到大选取合并出的新果堆必然是递增的，因此可以考虑用一个新队列存放新的果堆，然后每次在两个队头的选两次最小值。因为最小的两个果堆，无论从哪个取的，都一定比之前两个大，所以所有新果堆都可以放在新队列队尾，而不破坏新队列里的递增性。</p><p>最后循环 $n$ 次并累加即可。</p><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><strong>知识点：优先队列，贪心。</strong></p><p>每次选最小两个，可以用优先队列维护，常数高但方便。</p><p>这道题可以熟悉一下优先队列的用法，改变比较规则有 <code>greater&lt;&gt;</code> 和 <code>less&lt;&gt;</code> 两个仿函数，前者是小根堆后者是大根堆，默认是大根堆，也可以自定义仿函数，或者直接在自定义类型里面重载不等号。</p><p>要注意的，优先队列的比较规则与 <code>sort</code> 不同，它是满足比较规则（返回true）则是优先级低的排在队后，不满足的优先级高在前面，所以自定义时候要注意，因此用 <code>less&lt;&gt;</code> 时候要重载小于号，用 <code>greater&lt;&gt;</code> 时候要重载大于号，但是一般重载的时候直接用默认的 <code>less&lt;&gt;</code> 重载小于就行了。</p><p>其他的容器也是一样的，比如 $set$ ，$map$ ，$multiset$ 等等。</p><p>重载方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;<span class="comment">//注意要const，也可以写成友元函数</span></span><br><span class="line">        <span class="keyword">return</span> a&gt;x.a;<span class="comment">///满足大于的优先级低排后面，所以这是小根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿函数方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><span class="type">const</span></span>&#123;<span class="comment">//重载括号只能是成员函数</span></span><br><span class="line">        <span class="keyword">return</span> a.a&gt;b.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(n \log n)$</p><p>空间复杂度 $O(n)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1, q2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) q1.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">2</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q2.<span class="built_in">empty</span>() || !q1.<span class="built_in">empty</span>() &amp;&amp; q1.<span class="built_in">front</span>() &lt; q2.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                sum += q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += sum;</span><br><span class="line">        q2.<span class="built_in">push</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++) cin &gt;&gt; tmp, pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        sum += pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        pq.<span class="built_in">push</span>(sum);</span><br><span class="line">        ans += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16663&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A题笔记" scheme="https://blankyang233.github.io/categories/A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贪心" scheme="https://blankyang233.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://blankyang233.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="队列" scheme="https://blankyang233.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
